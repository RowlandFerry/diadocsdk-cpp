// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Invoicing/InvoiceInfo.proto

#ifndef PROTOBUF_Invoicing_2fInvoiceInfo_2eproto__INCLUDED
#define PROTOBUF_Invoicing_2fInvoiceInfo_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "Invoicing/Signer.pb.h"
#include "Invoicing/OrganizationInfo.pb.h"
// @@protoc_insertion_point(includes)

namespace Diadoc {
namespace Api {
namespace Proto {
namespace Invoicing {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_Invoicing_2fInvoiceInfo_2eproto();
void protobuf_AssignDesc_Invoicing_2fInvoiceInfo_2eproto();
void protobuf_ShutdownFile_Invoicing_2fInvoiceInfo_2eproto();

class InvoiceInfo;
class AdditionalInfo;
class InvoiceItem;
class CustomsDeclaration;
class PaymentDocumentInfo;
class ShipperOrConsignee;
class InvoiceCorrectionInfo;
class InvoiceTotalsDiff;
class InvoiceCorrectionItem;
class CorrectableInvoiceItemFields;
class InvoiceItemAmountsDiff;

enum InvoiceFormatVersion {
  DefaultInvoiceFormatVersion = 0,
  v5_01 = 1,
  v5_02 = 2
};
bool InvoiceFormatVersion_IsValid(int value);
const InvoiceFormatVersion InvoiceFormatVersion_MIN = DefaultInvoiceFormatVersion;
const InvoiceFormatVersion InvoiceFormatVersion_MAX = v5_02;
const int InvoiceFormatVersion_ARRAYSIZE = InvoiceFormatVersion_MAX + 1;

const ::google::protobuf::EnumDescriptor* InvoiceFormatVersion_descriptor();
inline const ::std::string& InvoiceFormatVersion_Name(InvoiceFormatVersion value) {
  return ::google::protobuf::internal::NameOfEnum(
    InvoiceFormatVersion_descriptor(), value);
}
inline bool InvoiceFormatVersion_Parse(
    const ::std::string& name, InvoiceFormatVersion* value) {
  return ::google::protobuf::internal::ParseNamedEnum<InvoiceFormatVersion>(
    InvoiceFormatVersion_descriptor(), name, value);
}
enum TaxRate {
  NoVat = 0,
  Percent_0 = 1,
  Percent_10 = 2,
  Percent_18 = 3,
  Percent_20 = 4,
  Fraction_10_110 = 5,
  Fraction_18_118 = 6,
  TaxedByAgent = 7,
  Fraction_20_120 = 8
};
bool TaxRate_IsValid(int value);
const TaxRate TaxRate_MIN = NoVat;
const TaxRate TaxRate_MAX = Fraction_20_120;
const int TaxRate_ARRAYSIZE = TaxRate_MAX + 1;

const ::google::protobuf::EnumDescriptor* TaxRate_descriptor();
inline const ::std::string& TaxRate_Name(TaxRate value) {
  return ::google::protobuf::internal::NameOfEnum(
    TaxRate_descriptor(), value);
}
inline bool TaxRate_Parse(
    const ::std::string& name, TaxRate* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TaxRate>(
    TaxRate_descriptor(), name, value);
}
// ===================================================================

class InvoiceInfo : public ::google::protobuf::Message {
 public:
  InvoiceInfo();
  virtual ~InvoiceInfo();

  InvoiceInfo(const InvoiceInfo& from);

  inline InvoiceInfo& operator=(const InvoiceInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InvoiceInfo& default_instance();

  void Swap(InvoiceInfo* other);

  // implements Message ----------------------------------------------

  InvoiceInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InvoiceInfo& from);
  void MergeFrom(const InvoiceInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string InvoiceDate = 1;
  inline bool has_invoicedate() const;
  inline void clear_invoicedate();
  static const int kInvoiceDateFieldNumber = 1;
  inline const ::std::string& invoicedate() const;
  inline void set_invoicedate(const ::std::string& value);
  inline void set_invoicedate(const char* value);
  inline void set_invoicedate(const char* value, size_t size);
  inline ::std::string* mutable_invoicedate();
  inline ::std::string* release_invoicedate();
  inline void set_allocated_invoicedate(::std::string* invoicedate);

  // required string InvoiceNumber = 2;
  inline bool has_invoicenumber() const;
  inline void clear_invoicenumber();
  static const int kInvoiceNumberFieldNumber = 2;
  inline const ::std::string& invoicenumber() const;
  inline void set_invoicenumber(const ::std::string& value);
  inline void set_invoicenumber(const char* value);
  inline void set_invoicenumber(const char* value, size_t size);
  inline ::std::string* mutable_invoicenumber();
  inline ::std::string* release_invoicenumber();
  inline void set_allocated_invoicenumber(::std::string* invoicenumber);

  // required .Diadoc.Api.Proto.Invoicing.DiadocOrganizationInfo Seller = 3;
  inline bool has_seller() const;
  inline void clear_seller();
  static const int kSellerFieldNumber = 3;
  inline const ::Diadoc::Api::Proto::Invoicing::DiadocOrganizationInfo& seller() const;
  inline ::Diadoc::Api::Proto::Invoicing::DiadocOrganizationInfo* mutable_seller();
  inline ::Diadoc::Api::Proto::Invoicing::DiadocOrganizationInfo* release_seller();
  inline void set_allocated_seller(::Diadoc::Api::Proto::Invoicing::DiadocOrganizationInfo* seller);

  // required .Diadoc.Api.Proto.Invoicing.DiadocOrganizationInfo Buyer = 4;
  inline bool has_buyer() const;
  inline void clear_buyer();
  static const int kBuyerFieldNumber = 4;
  inline const ::Diadoc::Api::Proto::Invoicing::DiadocOrganizationInfo& buyer() const;
  inline ::Diadoc::Api::Proto::Invoicing::DiadocOrganizationInfo* mutable_buyer();
  inline ::Diadoc::Api::Proto::Invoicing::DiadocOrganizationInfo* release_buyer();
  inline void set_allocated_buyer(::Diadoc::Api::Proto::Invoicing::DiadocOrganizationInfo* buyer);

  // optional .Diadoc.Api.Proto.Invoicing.ShipperOrConsignee Shipper = 5;
  inline bool has_shipper() const;
  inline void clear_shipper();
  static const int kShipperFieldNumber = 5;
  inline const ::Diadoc::Api::Proto::Invoicing::ShipperOrConsignee& shipper() const;
  inline ::Diadoc::Api::Proto::Invoicing::ShipperOrConsignee* mutable_shipper();
  inline ::Diadoc::Api::Proto::Invoicing::ShipperOrConsignee* release_shipper();
  inline void set_allocated_shipper(::Diadoc::Api::Proto::Invoicing::ShipperOrConsignee* shipper);

  // optional .Diadoc.Api.Proto.Invoicing.ShipperOrConsignee Consignee = 6;
  inline bool has_consignee() const;
  inline void clear_consignee();
  static const int kConsigneeFieldNumber = 6;
  inline const ::Diadoc::Api::Proto::Invoicing::ShipperOrConsignee& consignee() const;
  inline ::Diadoc::Api::Proto::Invoicing::ShipperOrConsignee* mutable_consignee();
  inline ::Diadoc::Api::Proto::Invoicing::ShipperOrConsignee* release_consignee();
  inline void set_allocated_consignee(::Diadoc::Api::Proto::Invoicing::ShipperOrConsignee* consignee);

  // required .Diadoc.Api.Proto.Invoicing.Signer Signer = 7;
  inline bool has_signer() const;
  inline void clear_signer();
  static const int kSignerFieldNumber = 7;
  inline const ::Diadoc::Api::Proto::Invoicing::Signer& signer() const;
  inline ::Diadoc::Api::Proto::Invoicing::Signer* mutable_signer();
  inline ::Diadoc::Api::Proto::Invoicing::Signer* release_signer();
  inline void set_allocated_signer(::Diadoc::Api::Proto::Invoicing::Signer* signer);

  // repeated .Diadoc.Api.Proto.Invoicing.PaymentDocumentInfo PaymentDocuments = 8;
  inline int paymentdocuments_size() const;
  inline void clear_paymentdocuments();
  static const int kPaymentDocumentsFieldNumber = 8;
  inline const ::Diadoc::Api::Proto::Invoicing::PaymentDocumentInfo& paymentdocuments(int index) const;
  inline ::Diadoc::Api::Proto::Invoicing::PaymentDocumentInfo* mutable_paymentdocuments(int index);
  inline ::Diadoc::Api::Proto::Invoicing::PaymentDocumentInfo* add_paymentdocuments();
  inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::PaymentDocumentInfo >&
      paymentdocuments() const;
  inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::PaymentDocumentInfo >*
      mutable_paymentdocuments();

  // repeated .Diadoc.Api.Proto.Invoicing.InvoiceItem Items = 9;
  inline int items_size() const;
  inline void clear_items();
  static const int kItemsFieldNumber = 9;
  inline const ::Diadoc::Api::Proto::Invoicing::InvoiceItem& items(int index) const;
  inline ::Diadoc::Api::Proto::Invoicing::InvoiceItem* mutable_items(int index);
  inline ::Diadoc::Api::Proto::Invoicing::InvoiceItem* add_items();
  inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::InvoiceItem >&
      items() const;
  inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::InvoiceItem >*
      mutable_items();

  // optional string Currency = 10;
  inline bool has_currency() const;
  inline void clear_currency();
  static const int kCurrencyFieldNumber = 10;
  inline const ::std::string& currency() const;
  inline void set_currency(const ::std::string& value);
  inline void set_currency(const char* value);
  inline void set_currency(const char* value, size_t size);
  inline ::std::string* mutable_currency();
  inline ::std::string* release_currency();
  inline void set_allocated_currency(::std::string* currency);

  // optional string TotalWithVatExcluded = 11;
  inline bool has_totalwithvatexcluded() const;
  inline void clear_totalwithvatexcluded();
  static const int kTotalWithVatExcludedFieldNumber = 11;
  inline const ::std::string& totalwithvatexcluded() const;
  inline void set_totalwithvatexcluded(const ::std::string& value);
  inline void set_totalwithvatexcluded(const char* value);
  inline void set_totalwithvatexcluded(const char* value, size_t size);
  inline ::std::string* mutable_totalwithvatexcluded();
  inline ::std::string* release_totalwithvatexcluded();
  inline void set_allocated_totalwithvatexcluded(::std::string* totalwithvatexcluded);

  // optional string Vat = 12;
  inline bool has_vat() const;
  inline void clear_vat();
  static const int kVatFieldNumber = 12;
  inline const ::std::string& vat() const;
  inline void set_vat(const ::std::string& value);
  inline void set_vat(const char* value);
  inline void set_vat(const char* value, size_t size);
  inline ::std::string* mutable_vat();
  inline ::std::string* release_vat();
  inline void set_allocated_vat(::std::string* vat);

  // required string Total = 13;
  inline bool has_total() const;
  inline void clear_total();
  static const int kTotalFieldNumber = 13;
  inline const ::std::string& total() const;
  inline void set_total(const ::std::string& value);
  inline void set_total(const char* value);
  inline void set_total(const char* value, size_t size);
  inline ::std::string* mutable_total();
  inline ::std::string* release_total();
  inline void set_allocated_total(::std::string* total);

  // optional string AdditionalInfo = 14;
  inline bool has_additionalinfo() const;
  inline void clear_additionalinfo();
  static const int kAdditionalInfoFieldNumber = 14;
  inline const ::std::string& additionalinfo() const;
  inline void set_additionalinfo(const ::std::string& value);
  inline void set_additionalinfo(const char* value);
  inline void set_additionalinfo(const char* value, size_t size);
  inline ::std::string* mutable_additionalinfo();
  inline ::std::string* release_additionalinfo();
  inline void set_allocated_additionalinfo(::std::string* additionalinfo);

  // optional string InvoiceRevisionDate = 15;
  inline bool has_invoicerevisiondate() const;
  inline void clear_invoicerevisiondate();
  static const int kInvoiceRevisionDateFieldNumber = 15;
  inline const ::std::string& invoicerevisiondate() const;
  inline void set_invoicerevisiondate(const ::std::string& value);
  inline void set_invoicerevisiondate(const char* value);
  inline void set_invoicerevisiondate(const char* value, size_t size);
  inline ::std::string* mutable_invoicerevisiondate();
  inline ::std::string* release_invoicerevisiondate();
  inline void set_allocated_invoicerevisiondate(::std::string* invoicerevisiondate);

  // optional string InvoiceRevisionNumber = 16;
  inline bool has_invoicerevisionnumber() const;
  inline void clear_invoicerevisionnumber();
  static const int kInvoiceRevisionNumberFieldNumber = 16;
  inline const ::std::string& invoicerevisionnumber() const;
  inline void set_invoicerevisionnumber(const ::std::string& value);
  inline void set_invoicerevisionnumber(const char* value);
  inline void set_invoicerevisionnumber(const char* value, size_t size);
  inline ::std::string* mutable_invoicerevisionnumber();
  inline ::std::string* release_invoicerevisionnumber();
  inline void set_allocated_invoicerevisionnumber(::std::string* invoicerevisionnumber);

  // repeated .Diadoc.Api.Proto.Invoicing.AdditionalInfo AdditionalInfos = 17;
  inline int additionalinfos_size() const;
  inline void clear_additionalinfos();
  static const int kAdditionalInfosFieldNumber = 17;
  inline const ::Diadoc::Api::Proto::Invoicing::AdditionalInfo& additionalinfos(int index) const;
  inline ::Diadoc::Api::Proto::Invoicing::AdditionalInfo* mutable_additionalinfos(int index);
  inline ::Diadoc::Api::Proto::Invoicing::AdditionalInfo* add_additionalinfos();
  inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::AdditionalInfo >&
      additionalinfos() const;
  inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::AdditionalInfo >*
      mutable_additionalinfos();

  // optional .Diadoc.Api.Proto.Invoicing.InvoiceFormatVersion Version = 18 [default = DefaultInvoiceFormatVersion];
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 18;
  inline ::Diadoc::Api::Proto::Invoicing::InvoiceFormatVersion version() const;
  inline void set_version(::Diadoc::Api::Proto::Invoicing::InvoiceFormatVersion value);

  // @@protoc_insertion_point(class_scope:Diadoc.Api.Proto.Invoicing.InvoiceInfo)
 private:
  inline void set_has_invoicedate();
  inline void clear_has_invoicedate();
  inline void set_has_invoicenumber();
  inline void clear_has_invoicenumber();
  inline void set_has_seller();
  inline void clear_has_seller();
  inline void set_has_buyer();
  inline void clear_has_buyer();
  inline void set_has_shipper();
  inline void clear_has_shipper();
  inline void set_has_consignee();
  inline void clear_has_consignee();
  inline void set_has_signer();
  inline void clear_has_signer();
  inline void set_has_currency();
  inline void clear_has_currency();
  inline void set_has_totalwithvatexcluded();
  inline void clear_has_totalwithvatexcluded();
  inline void set_has_vat();
  inline void clear_has_vat();
  inline void set_has_total();
  inline void clear_has_total();
  inline void set_has_additionalinfo();
  inline void clear_has_additionalinfo();
  inline void set_has_invoicerevisiondate();
  inline void clear_has_invoicerevisiondate();
  inline void set_has_invoicerevisionnumber();
  inline void clear_has_invoicerevisionnumber();
  inline void set_has_version();
  inline void clear_has_version();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* invoicedate_;
  ::std::string* invoicenumber_;
  ::Diadoc::Api::Proto::Invoicing::DiadocOrganizationInfo* seller_;
  ::Diadoc::Api::Proto::Invoicing::DiadocOrganizationInfo* buyer_;
  ::Diadoc::Api::Proto::Invoicing::ShipperOrConsignee* shipper_;
  ::Diadoc::Api::Proto::Invoicing::ShipperOrConsignee* consignee_;
  ::Diadoc::Api::Proto::Invoicing::Signer* signer_;
  ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::PaymentDocumentInfo > paymentdocuments_;
  ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::InvoiceItem > items_;
  ::std::string* currency_;
  ::std::string* totalwithvatexcluded_;
  ::std::string* vat_;
  ::std::string* total_;
  ::std::string* additionalinfo_;
  ::std::string* invoicerevisiondate_;
  ::std::string* invoicerevisionnumber_;
  ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::AdditionalInfo > additionalinfos_;
  int version_;
  friend void  protobuf_AddDesc_Invoicing_2fInvoiceInfo_2eproto();
  friend void protobuf_AssignDesc_Invoicing_2fInvoiceInfo_2eproto();
  friend void protobuf_ShutdownFile_Invoicing_2fInvoiceInfo_2eproto();

  void InitAsDefaultInstance();
  static InvoiceInfo* default_instance_;
};
// -------------------------------------------------------------------

class AdditionalInfo : public ::google::protobuf::Message {
 public:
  AdditionalInfo();
  virtual ~AdditionalInfo();

  AdditionalInfo(const AdditionalInfo& from);

  inline AdditionalInfo& operator=(const AdditionalInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AdditionalInfo& default_instance();

  void Swap(AdditionalInfo* other);

  // implements Message ----------------------------------------------

  AdditionalInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AdditionalInfo& from);
  void MergeFrom(const AdditionalInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string Id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // required string Value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:Diadoc.Api.Proto.Invoicing.AdditionalInfo)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* id_;
  ::std::string* value_;
  friend void  protobuf_AddDesc_Invoicing_2fInvoiceInfo_2eproto();
  friend void protobuf_AssignDesc_Invoicing_2fInvoiceInfo_2eproto();
  friend void protobuf_ShutdownFile_Invoicing_2fInvoiceInfo_2eproto();

  void InitAsDefaultInstance();
  static AdditionalInfo* default_instance_;
};
// -------------------------------------------------------------------

class InvoiceItem : public ::google::protobuf::Message {
 public:
  InvoiceItem();
  virtual ~InvoiceItem();

  InvoiceItem(const InvoiceItem& from);

  inline InvoiceItem& operator=(const InvoiceItem& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InvoiceItem& default_instance();

  void Swap(InvoiceItem* other);

  // implements Message ----------------------------------------------

  InvoiceItem* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InvoiceItem& from);
  void MergeFrom(const InvoiceItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string Product = 1;
  inline bool has_product() const;
  inline void clear_product();
  static const int kProductFieldNumber = 1;
  inline const ::std::string& product() const;
  inline void set_product(const ::std::string& value);
  inline void set_product(const char* value);
  inline void set_product(const char* value, size_t size);
  inline ::std::string* mutable_product();
  inline ::std::string* release_product();
  inline void set_allocated_product(::std::string* product);

  // optional string Unit = 2;
  inline bool has_unit() const;
  inline void clear_unit();
  static const int kUnitFieldNumber = 2;
  inline const ::std::string& unit() const;
  inline void set_unit(const ::std::string& value);
  inline void set_unit(const char* value);
  inline void set_unit(const char* value, size_t size);
  inline ::std::string* mutable_unit();
  inline ::std::string* release_unit();
  inline void set_allocated_unit(::std::string* unit);

  // optional string Quantity = 3;
  inline bool has_quantity() const;
  inline void clear_quantity();
  static const int kQuantityFieldNumber = 3;
  inline const ::std::string& quantity() const;
  inline void set_quantity(const ::std::string& value);
  inline void set_quantity(const char* value);
  inline void set_quantity(const char* value, size_t size);
  inline ::std::string* mutable_quantity();
  inline ::std::string* release_quantity();
  inline void set_allocated_quantity(::std::string* quantity);

  // optional string Price = 4;
  inline bool has_price() const;
  inline void clear_price();
  static const int kPriceFieldNumber = 4;
  inline const ::std::string& price() const;
  inline void set_price(const ::std::string& value);
  inline void set_price(const char* value);
  inline void set_price(const char* value, size_t size);
  inline ::std::string* mutable_price();
  inline ::std::string* release_price();
  inline void set_allocated_price(::std::string* price);

  // repeated string CountriesOfOrigin = 5;
  inline int countriesoforigin_size() const;
  inline void clear_countriesoforigin();
  static const int kCountriesOfOriginFieldNumber = 5;
  inline const ::std::string& countriesoforigin(int index) const;
  inline ::std::string* mutable_countriesoforigin(int index);
  inline void set_countriesoforigin(int index, const ::std::string& value);
  inline void set_countriesoforigin(int index, const char* value);
  inline void set_countriesoforigin(int index, const char* value, size_t size);
  inline ::std::string* add_countriesoforigin();
  inline void add_countriesoforigin(const ::std::string& value);
  inline void add_countriesoforigin(const char* value);
  inline void add_countriesoforigin(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& countriesoforigin() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_countriesoforigin();

  // repeated string CustomsDeclarationNumbers = 6;
  inline int customsdeclarationnumbers_size() const;
  inline void clear_customsdeclarationnumbers();
  static const int kCustomsDeclarationNumbersFieldNumber = 6;
  inline const ::std::string& customsdeclarationnumbers(int index) const;
  inline ::std::string* mutable_customsdeclarationnumbers(int index);
  inline void set_customsdeclarationnumbers(int index, const ::std::string& value);
  inline void set_customsdeclarationnumbers(int index, const char* value);
  inline void set_customsdeclarationnumbers(int index, const char* value, size_t size);
  inline ::std::string* add_customsdeclarationnumbers();
  inline void add_customsdeclarationnumbers(const ::std::string& value);
  inline void add_customsdeclarationnumbers(const char* value);
  inline void add_customsdeclarationnumbers(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& customsdeclarationnumbers() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_customsdeclarationnumbers();

  // optional string Excise = 7;
  inline bool has_excise() const;
  inline void clear_excise();
  static const int kExciseFieldNumber = 7;
  inline const ::std::string& excise() const;
  inline void set_excise(const ::std::string& value);
  inline void set_excise(const char* value);
  inline void set_excise(const char* value, size_t size);
  inline ::std::string* mutable_excise();
  inline ::std::string* release_excise();
  inline void set_allocated_excise(::std::string* excise);

  // required .Diadoc.Api.Proto.Invoicing.TaxRate TaxRate = 8;
  inline bool has_taxrate() const;
  inline void clear_taxrate();
  static const int kTaxRateFieldNumber = 8;
  inline ::Diadoc::Api::Proto::Invoicing::TaxRate taxrate() const;
  inline void set_taxrate(::Diadoc::Api::Proto::Invoicing::TaxRate value);

  // optional string SubtotalWithVatExcluded = 9;
  inline bool has_subtotalwithvatexcluded() const;
  inline void clear_subtotalwithvatexcluded();
  static const int kSubtotalWithVatExcludedFieldNumber = 9;
  inline const ::std::string& subtotalwithvatexcluded() const;
  inline void set_subtotalwithvatexcluded(const ::std::string& value);
  inline void set_subtotalwithvatexcluded(const char* value);
  inline void set_subtotalwithvatexcluded(const char* value, size_t size);
  inline ::std::string* mutable_subtotalwithvatexcluded();
  inline ::std::string* release_subtotalwithvatexcluded();
  inline void set_allocated_subtotalwithvatexcluded(::std::string* subtotalwithvatexcluded);

  // optional string Vat = 10;
  inline bool has_vat() const;
  inline void clear_vat();
  static const int kVatFieldNumber = 10;
  inline const ::std::string& vat() const;
  inline void set_vat(const ::std::string& value);
  inline void set_vat(const char* value);
  inline void set_vat(const char* value, size_t size);
  inline ::std::string* mutable_vat();
  inline ::std::string* release_vat();
  inline void set_allocated_vat(::std::string* vat);

  // required string Subtotal = 11;
  inline bool has_subtotal() const;
  inline void clear_subtotal();
  static const int kSubtotalFieldNumber = 11;
  inline const ::std::string& subtotal() const;
  inline void set_subtotal(const ::std::string& value);
  inline void set_subtotal(const char* value);
  inline void set_subtotal(const char* value, size_t size);
  inline ::std::string* mutable_subtotal();
  inline ::std::string* release_subtotal();
  inline void set_allocated_subtotal(::std::string* subtotal);

  // optional string AdditionalInfo = 12;
  inline bool has_additionalinfo() const;
  inline void clear_additionalinfo();
  static const int kAdditionalInfoFieldNumber = 12;
  inline const ::std::string& additionalinfo() const;
  inline void set_additionalinfo(const ::std::string& value);
  inline void set_additionalinfo(const char* value);
  inline void set_additionalinfo(const char* value, size_t size);
  inline ::std::string* mutable_additionalinfo();
  inline ::std::string* release_additionalinfo();
  inline void set_allocated_additionalinfo(::std::string* additionalinfo);

  // repeated .Diadoc.Api.Proto.Invoicing.CustomsDeclaration CustomsDeclarations = 13;
  inline int customsdeclarations_size() const;
  inline void clear_customsdeclarations();
  static const int kCustomsDeclarationsFieldNumber = 13;
  inline const ::Diadoc::Api::Proto::Invoicing::CustomsDeclaration& customsdeclarations(int index) const;
  inline ::Diadoc::Api::Proto::Invoicing::CustomsDeclaration* mutable_customsdeclarations(int index);
  inline ::Diadoc::Api::Proto::Invoicing::CustomsDeclaration* add_customsdeclarations();
  inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::CustomsDeclaration >&
      customsdeclarations() const;
  inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::CustomsDeclaration >*
      mutable_customsdeclarations();

  // repeated .Diadoc.Api.Proto.Invoicing.AdditionalInfo AdditionalInfos = 14;
  inline int additionalinfos_size() const;
  inline void clear_additionalinfos();
  static const int kAdditionalInfosFieldNumber = 14;
  inline const ::Diadoc::Api::Proto::Invoicing::AdditionalInfo& additionalinfos(int index) const;
  inline ::Diadoc::Api::Proto::Invoicing::AdditionalInfo* mutable_additionalinfos(int index);
  inline ::Diadoc::Api::Proto::Invoicing::AdditionalInfo* add_additionalinfos();
  inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::AdditionalInfo >&
      additionalinfos() const;
  inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::AdditionalInfo >*
      mutable_additionalinfos();

  // @@protoc_insertion_point(class_scope:Diadoc.Api.Proto.Invoicing.InvoiceItem)
 private:
  inline void set_has_product();
  inline void clear_has_product();
  inline void set_has_unit();
  inline void clear_has_unit();
  inline void set_has_quantity();
  inline void clear_has_quantity();
  inline void set_has_price();
  inline void clear_has_price();
  inline void set_has_excise();
  inline void clear_has_excise();
  inline void set_has_taxrate();
  inline void clear_has_taxrate();
  inline void set_has_subtotalwithvatexcluded();
  inline void clear_has_subtotalwithvatexcluded();
  inline void set_has_vat();
  inline void clear_has_vat();
  inline void set_has_subtotal();
  inline void clear_has_subtotal();
  inline void set_has_additionalinfo();
  inline void clear_has_additionalinfo();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* product_;
  ::std::string* unit_;
  ::std::string* quantity_;
  ::std::string* price_;
  ::google::protobuf::RepeatedPtrField< ::std::string> countriesoforigin_;
  ::google::protobuf::RepeatedPtrField< ::std::string> customsdeclarationnumbers_;
  ::std::string* excise_;
  ::std::string* subtotalwithvatexcluded_;
  ::std::string* vat_;
  ::std::string* subtotal_;
  ::std::string* additionalinfo_;
  ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::CustomsDeclaration > customsdeclarations_;
  ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::AdditionalInfo > additionalinfos_;
  int taxrate_;
  friend void  protobuf_AddDesc_Invoicing_2fInvoiceInfo_2eproto();
  friend void protobuf_AssignDesc_Invoicing_2fInvoiceInfo_2eproto();
  friend void protobuf_ShutdownFile_Invoicing_2fInvoiceInfo_2eproto();

  void InitAsDefaultInstance();
  static InvoiceItem* default_instance_;
};
// -------------------------------------------------------------------

class CustomsDeclaration : public ::google::protobuf::Message {
 public:
  CustomsDeclaration();
  virtual ~CustomsDeclaration();

  CustomsDeclaration(const CustomsDeclaration& from);

  inline CustomsDeclaration& operator=(const CustomsDeclaration& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CustomsDeclaration& default_instance();

  void Swap(CustomsDeclaration* other);

  // implements Message ----------------------------------------------

  CustomsDeclaration* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CustomsDeclaration& from);
  void MergeFrom(const CustomsDeclaration& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string CountryCode = 1;
  inline bool has_countrycode() const;
  inline void clear_countrycode();
  static const int kCountryCodeFieldNumber = 1;
  inline const ::std::string& countrycode() const;
  inline void set_countrycode(const ::std::string& value);
  inline void set_countrycode(const char* value);
  inline void set_countrycode(const char* value, size_t size);
  inline ::std::string* mutable_countrycode();
  inline ::std::string* release_countrycode();
  inline void set_allocated_countrycode(::std::string* countrycode);

  // required string DeclarationNumber = 2;
  inline bool has_declarationnumber() const;
  inline void clear_declarationnumber();
  static const int kDeclarationNumberFieldNumber = 2;
  inline const ::std::string& declarationnumber() const;
  inline void set_declarationnumber(const ::std::string& value);
  inline void set_declarationnumber(const char* value);
  inline void set_declarationnumber(const char* value, size_t size);
  inline ::std::string* mutable_declarationnumber();
  inline ::std::string* release_declarationnumber();
  inline void set_allocated_declarationnumber(::std::string* declarationnumber);

  // @@protoc_insertion_point(class_scope:Diadoc.Api.Proto.Invoicing.CustomsDeclaration)
 private:
  inline void set_has_countrycode();
  inline void clear_has_countrycode();
  inline void set_has_declarationnumber();
  inline void clear_has_declarationnumber();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* countrycode_;
  ::std::string* declarationnumber_;
  friend void  protobuf_AddDesc_Invoicing_2fInvoiceInfo_2eproto();
  friend void protobuf_AssignDesc_Invoicing_2fInvoiceInfo_2eproto();
  friend void protobuf_ShutdownFile_Invoicing_2fInvoiceInfo_2eproto();

  void InitAsDefaultInstance();
  static CustomsDeclaration* default_instance_;
};
// -------------------------------------------------------------------

class PaymentDocumentInfo : public ::google::protobuf::Message {
 public:
  PaymentDocumentInfo();
  virtual ~PaymentDocumentInfo();

  PaymentDocumentInfo(const PaymentDocumentInfo& from);

  inline PaymentDocumentInfo& operator=(const PaymentDocumentInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PaymentDocumentInfo& default_instance();

  void Swap(PaymentDocumentInfo* other);

  // implements Message ----------------------------------------------

  PaymentDocumentInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PaymentDocumentInfo& from);
  void MergeFrom(const PaymentDocumentInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string DocumentDate = 1;
  inline bool has_documentdate() const;
  inline void clear_documentdate();
  static const int kDocumentDateFieldNumber = 1;
  inline const ::std::string& documentdate() const;
  inline void set_documentdate(const ::std::string& value);
  inline void set_documentdate(const char* value);
  inline void set_documentdate(const char* value, size_t size);
  inline ::std::string* mutable_documentdate();
  inline ::std::string* release_documentdate();
  inline void set_allocated_documentdate(::std::string* documentdate);

  // required string DocumentNumber = 2;
  inline bool has_documentnumber() const;
  inline void clear_documentnumber();
  static const int kDocumentNumberFieldNumber = 2;
  inline const ::std::string& documentnumber() const;
  inline void set_documentnumber(const ::std::string& value);
  inline void set_documentnumber(const char* value);
  inline void set_documentnumber(const char* value, size_t size);
  inline ::std::string* mutable_documentnumber();
  inline ::std::string* release_documentnumber();
  inline void set_allocated_documentnumber(::std::string* documentnumber);

  // @@protoc_insertion_point(class_scope:Diadoc.Api.Proto.Invoicing.PaymentDocumentInfo)
 private:
  inline void set_has_documentdate();
  inline void clear_has_documentdate();
  inline void set_has_documentnumber();
  inline void clear_has_documentnumber();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* documentdate_;
  ::std::string* documentnumber_;
  friend void  protobuf_AddDesc_Invoicing_2fInvoiceInfo_2eproto();
  friend void protobuf_AssignDesc_Invoicing_2fInvoiceInfo_2eproto();
  friend void protobuf_ShutdownFile_Invoicing_2fInvoiceInfo_2eproto();

  void InitAsDefaultInstance();
  static PaymentDocumentInfo* default_instance_;
};
// -------------------------------------------------------------------

class ShipperOrConsignee : public ::google::protobuf::Message {
 public:
  ShipperOrConsignee();
  virtual ~ShipperOrConsignee();

  ShipperOrConsignee(const ShipperOrConsignee& from);

  inline ShipperOrConsignee& operator=(const ShipperOrConsignee& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ShipperOrConsignee& default_instance();

  void Swap(ShipperOrConsignee* other);

  // implements Message ----------------------------------------------

  ShipperOrConsignee* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ShipperOrConsignee& from);
  void MergeFrom(const ShipperOrConsignee& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool SameAsSellerOrBuyer = 1;
  inline bool has_sameassellerorbuyer() const;
  inline void clear_sameassellerorbuyer();
  static const int kSameAsSellerOrBuyerFieldNumber = 1;
  inline bool sameassellerorbuyer() const;
  inline void set_sameassellerorbuyer(bool value);

  // optional .Diadoc.Api.Proto.Invoicing.OrganizationInfo OrgInfo = 2;
  inline bool has_orginfo() const;
  inline void clear_orginfo();
  static const int kOrgInfoFieldNumber = 2;
  inline const ::Diadoc::Api::Proto::Invoicing::OrganizationInfo& orginfo() const;
  inline ::Diadoc::Api::Proto::Invoicing::OrganizationInfo* mutable_orginfo();
  inline ::Diadoc::Api::Proto::Invoicing::OrganizationInfo* release_orginfo();
  inline void set_allocated_orginfo(::Diadoc::Api::Proto::Invoicing::OrganizationInfo* orginfo);

  // @@protoc_insertion_point(class_scope:Diadoc.Api.Proto.Invoicing.ShipperOrConsignee)
 private:
  inline void set_has_sameassellerorbuyer();
  inline void clear_has_sameassellerorbuyer();
  inline void set_has_orginfo();
  inline void clear_has_orginfo();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::Diadoc::Api::Proto::Invoicing::OrganizationInfo* orginfo_;
  bool sameassellerorbuyer_;
  friend void  protobuf_AddDesc_Invoicing_2fInvoiceInfo_2eproto();
  friend void protobuf_AssignDesc_Invoicing_2fInvoiceInfo_2eproto();
  friend void protobuf_ShutdownFile_Invoicing_2fInvoiceInfo_2eproto();

  void InitAsDefaultInstance();
  static ShipperOrConsignee* default_instance_;
};
// -------------------------------------------------------------------

class InvoiceCorrectionInfo : public ::google::protobuf::Message {
 public:
  InvoiceCorrectionInfo();
  virtual ~InvoiceCorrectionInfo();

  InvoiceCorrectionInfo(const InvoiceCorrectionInfo& from);

  inline InvoiceCorrectionInfo& operator=(const InvoiceCorrectionInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InvoiceCorrectionInfo& default_instance();

  void Swap(InvoiceCorrectionInfo* other);

  // implements Message ----------------------------------------------

  InvoiceCorrectionInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InvoiceCorrectionInfo& from);
  void MergeFrom(const InvoiceCorrectionInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string InvoiceDate = 1;
  inline bool has_invoicedate() const;
  inline void clear_invoicedate();
  static const int kInvoiceDateFieldNumber = 1;
  inline const ::std::string& invoicedate() const;
  inline void set_invoicedate(const ::std::string& value);
  inline void set_invoicedate(const char* value);
  inline void set_invoicedate(const char* value, size_t size);
  inline ::std::string* mutable_invoicedate();
  inline ::std::string* release_invoicedate();
  inline void set_allocated_invoicedate(::std::string* invoicedate);

  // required string InvoiceNumber = 2;
  inline bool has_invoicenumber() const;
  inline void clear_invoicenumber();
  static const int kInvoiceNumberFieldNumber = 2;
  inline const ::std::string& invoicenumber() const;
  inline void set_invoicenumber(const ::std::string& value);
  inline void set_invoicenumber(const char* value);
  inline void set_invoicenumber(const char* value, size_t size);
  inline ::std::string* mutable_invoicenumber();
  inline ::std::string* release_invoicenumber();
  inline void set_allocated_invoicenumber(::std::string* invoicenumber);

  // optional string InvoiceRevisionDate = 3;
  inline bool has_invoicerevisiondate() const;
  inline void clear_invoicerevisiondate();
  static const int kInvoiceRevisionDateFieldNumber = 3;
  inline const ::std::string& invoicerevisiondate() const;
  inline void set_invoicerevisiondate(const ::std::string& value);
  inline void set_invoicerevisiondate(const char* value);
  inline void set_invoicerevisiondate(const char* value, size_t size);
  inline ::std::string* mutable_invoicerevisiondate();
  inline ::std::string* release_invoicerevisiondate();
  inline void set_allocated_invoicerevisiondate(::std::string* invoicerevisiondate);

  // optional string InvoiceRevisionNumber = 4;
  inline bool has_invoicerevisionnumber() const;
  inline void clear_invoicerevisionnumber();
  static const int kInvoiceRevisionNumberFieldNumber = 4;
  inline const ::std::string& invoicerevisionnumber() const;
  inline void set_invoicerevisionnumber(const ::std::string& value);
  inline void set_invoicerevisionnumber(const char* value);
  inline void set_invoicerevisionnumber(const char* value, size_t size);
  inline ::std::string* mutable_invoicerevisionnumber();
  inline ::std::string* release_invoicerevisionnumber();
  inline void set_allocated_invoicerevisionnumber(::std::string* invoicerevisionnumber);

  // required string InvoiceCorrectionDate = 5;
  inline bool has_invoicecorrectiondate() const;
  inline void clear_invoicecorrectiondate();
  static const int kInvoiceCorrectionDateFieldNumber = 5;
  inline const ::std::string& invoicecorrectiondate() const;
  inline void set_invoicecorrectiondate(const ::std::string& value);
  inline void set_invoicecorrectiondate(const char* value);
  inline void set_invoicecorrectiondate(const char* value, size_t size);
  inline ::std::string* mutable_invoicecorrectiondate();
  inline ::std::string* release_invoicecorrectiondate();
  inline void set_allocated_invoicecorrectiondate(::std::string* invoicecorrectiondate);

  // required string InvoiceCorrectionNumber = 6;
  inline bool has_invoicecorrectionnumber() const;
  inline void clear_invoicecorrectionnumber();
  static const int kInvoiceCorrectionNumberFieldNumber = 6;
  inline const ::std::string& invoicecorrectionnumber() const;
  inline void set_invoicecorrectionnumber(const ::std::string& value);
  inline void set_invoicecorrectionnumber(const char* value);
  inline void set_invoicecorrectionnumber(const char* value, size_t size);
  inline ::std::string* mutable_invoicecorrectionnumber();
  inline ::std::string* release_invoicecorrectionnumber();
  inline void set_allocated_invoicecorrectionnumber(::std::string* invoicecorrectionnumber);

  // optional string InvoiceCorrectionRevisionDate = 7;
  inline bool has_invoicecorrectionrevisiondate() const;
  inline void clear_invoicecorrectionrevisiondate();
  static const int kInvoiceCorrectionRevisionDateFieldNumber = 7;
  inline const ::std::string& invoicecorrectionrevisiondate() const;
  inline void set_invoicecorrectionrevisiondate(const ::std::string& value);
  inline void set_invoicecorrectionrevisiondate(const char* value);
  inline void set_invoicecorrectionrevisiondate(const char* value, size_t size);
  inline ::std::string* mutable_invoicecorrectionrevisiondate();
  inline ::std::string* release_invoicecorrectionrevisiondate();
  inline void set_allocated_invoicecorrectionrevisiondate(::std::string* invoicecorrectionrevisiondate);

  // optional string InvoiceCorrectionRevisionNumber = 8;
  inline bool has_invoicecorrectionrevisionnumber() const;
  inline void clear_invoicecorrectionrevisionnumber();
  static const int kInvoiceCorrectionRevisionNumberFieldNumber = 8;
  inline const ::std::string& invoicecorrectionrevisionnumber() const;
  inline void set_invoicecorrectionrevisionnumber(const ::std::string& value);
  inline void set_invoicecorrectionrevisionnumber(const char* value);
  inline void set_invoicecorrectionrevisionnumber(const char* value, size_t size);
  inline ::std::string* mutable_invoicecorrectionrevisionnumber();
  inline ::std::string* release_invoicecorrectionrevisionnumber();
  inline void set_allocated_invoicecorrectionrevisionnumber(::std::string* invoicecorrectionrevisionnumber);

  // required .Diadoc.Api.Proto.Invoicing.DiadocOrganizationInfo Seller = 9;
  inline bool has_seller() const;
  inline void clear_seller();
  static const int kSellerFieldNumber = 9;
  inline const ::Diadoc::Api::Proto::Invoicing::DiadocOrganizationInfo& seller() const;
  inline ::Diadoc::Api::Proto::Invoicing::DiadocOrganizationInfo* mutable_seller();
  inline ::Diadoc::Api::Proto::Invoicing::DiadocOrganizationInfo* release_seller();
  inline void set_allocated_seller(::Diadoc::Api::Proto::Invoicing::DiadocOrganizationInfo* seller);

  // required .Diadoc.Api.Proto.Invoicing.DiadocOrganizationInfo Buyer = 10;
  inline bool has_buyer() const;
  inline void clear_buyer();
  static const int kBuyerFieldNumber = 10;
  inline const ::Diadoc::Api::Proto::Invoicing::DiadocOrganizationInfo& buyer() const;
  inline ::Diadoc::Api::Proto::Invoicing::DiadocOrganizationInfo* mutable_buyer();
  inline ::Diadoc::Api::Proto::Invoicing::DiadocOrganizationInfo* release_buyer();
  inline void set_allocated_buyer(::Diadoc::Api::Proto::Invoicing::DiadocOrganizationInfo* buyer);

  // required .Diadoc.Api.Proto.Invoicing.Signer Signer = 11;
  inline bool has_signer() const;
  inline void clear_signer();
  static const int kSignerFieldNumber = 11;
  inline const ::Diadoc::Api::Proto::Invoicing::Signer& signer() const;
  inline ::Diadoc::Api::Proto::Invoicing::Signer* mutable_signer();
  inline ::Diadoc::Api::Proto::Invoicing::Signer* release_signer();
  inline void set_allocated_signer(::Diadoc::Api::Proto::Invoicing::Signer* signer);

  // repeated .Diadoc.Api.Proto.Invoicing.InvoiceCorrectionItem Items = 12;
  inline int items_size() const;
  inline void clear_items();
  static const int kItemsFieldNumber = 12;
  inline const ::Diadoc::Api::Proto::Invoicing::InvoiceCorrectionItem& items(int index) const;
  inline ::Diadoc::Api::Proto::Invoicing::InvoiceCorrectionItem* mutable_items(int index);
  inline ::Diadoc::Api::Proto::Invoicing::InvoiceCorrectionItem* add_items();
  inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::InvoiceCorrectionItem >&
      items() const;
  inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::InvoiceCorrectionItem >*
      mutable_items();

  // optional string Currency = 13;
  inline bool has_currency() const;
  inline void clear_currency();
  static const int kCurrencyFieldNumber = 13;
  inline const ::std::string& currency() const;
  inline void set_currency(const ::std::string& value);
  inline void set_currency(const char* value);
  inline void set_currency(const char* value, size_t size);
  inline ::std::string* mutable_currency();
  inline ::std::string* release_currency();
  inline void set_allocated_currency(::std::string* currency);

  // optional .Diadoc.Api.Proto.Invoicing.InvoiceTotalsDiff TotalsInc = 14;
  inline bool has_totalsinc() const;
  inline void clear_totalsinc();
  static const int kTotalsIncFieldNumber = 14;
  inline const ::Diadoc::Api::Proto::Invoicing::InvoiceTotalsDiff& totalsinc() const;
  inline ::Diadoc::Api::Proto::Invoicing::InvoiceTotalsDiff* mutable_totalsinc();
  inline ::Diadoc::Api::Proto::Invoicing::InvoiceTotalsDiff* release_totalsinc();
  inline void set_allocated_totalsinc(::Diadoc::Api::Proto::Invoicing::InvoiceTotalsDiff* totalsinc);

  // optional .Diadoc.Api.Proto.Invoicing.InvoiceTotalsDiff TotalsDec = 15;
  inline bool has_totalsdec() const;
  inline void clear_totalsdec();
  static const int kTotalsDecFieldNumber = 15;
  inline const ::Diadoc::Api::Proto::Invoicing::InvoiceTotalsDiff& totalsdec() const;
  inline ::Diadoc::Api::Proto::Invoicing::InvoiceTotalsDiff* mutable_totalsdec();
  inline ::Diadoc::Api::Proto::Invoicing::InvoiceTotalsDiff* release_totalsdec();
  inline void set_allocated_totalsdec(::Diadoc::Api::Proto::Invoicing::InvoiceTotalsDiff* totalsdec);

  // optional string AdditionalInfo = 16;
  inline bool has_additionalinfo() const;
  inline void clear_additionalinfo();
  static const int kAdditionalInfoFieldNumber = 16;
  inline const ::std::string& additionalinfo() const;
  inline void set_additionalinfo(const ::std::string& value);
  inline void set_additionalinfo(const char* value);
  inline void set_additionalinfo(const char* value, size_t size);
  inline ::std::string* mutable_additionalinfo();
  inline ::std::string* release_additionalinfo();
  inline void set_allocated_additionalinfo(::std::string* additionalinfo);

  // repeated .Diadoc.Api.Proto.Invoicing.AdditionalInfo AdditionalInfos = 17;
  inline int additionalinfos_size() const;
  inline void clear_additionalinfos();
  static const int kAdditionalInfosFieldNumber = 17;
  inline const ::Diadoc::Api::Proto::Invoicing::AdditionalInfo& additionalinfos(int index) const;
  inline ::Diadoc::Api::Proto::Invoicing::AdditionalInfo* mutable_additionalinfos(int index);
  inline ::Diadoc::Api::Proto::Invoicing::AdditionalInfo* add_additionalinfos();
  inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::AdditionalInfo >&
      additionalinfos() const;
  inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::AdditionalInfo >*
      mutable_additionalinfos();

  // optional .Diadoc.Api.Proto.Invoicing.InvoiceFormatVersion Version = 18 [default = DefaultInvoiceFormatVersion];
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 18;
  inline ::Diadoc::Api::Proto::Invoicing::InvoiceFormatVersion version() const;
  inline void set_version(::Diadoc::Api::Proto::Invoicing::InvoiceFormatVersion value);

  // @@protoc_insertion_point(class_scope:Diadoc.Api.Proto.Invoicing.InvoiceCorrectionInfo)
 private:
  inline void set_has_invoicedate();
  inline void clear_has_invoicedate();
  inline void set_has_invoicenumber();
  inline void clear_has_invoicenumber();
  inline void set_has_invoicerevisiondate();
  inline void clear_has_invoicerevisiondate();
  inline void set_has_invoicerevisionnumber();
  inline void clear_has_invoicerevisionnumber();
  inline void set_has_invoicecorrectiondate();
  inline void clear_has_invoicecorrectiondate();
  inline void set_has_invoicecorrectionnumber();
  inline void clear_has_invoicecorrectionnumber();
  inline void set_has_invoicecorrectionrevisiondate();
  inline void clear_has_invoicecorrectionrevisiondate();
  inline void set_has_invoicecorrectionrevisionnumber();
  inline void clear_has_invoicecorrectionrevisionnumber();
  inline void set_has_seller();
  inline void clear_has_seller();
  inline void set_has_buyer();
  inline void clear_has_buyer();
  inline void set_has_signer();
  inline void clear_has_signer();
  inline void set_has_currency();
  inline void clear_has_currency();
  inline void set_has_totalsinc();
  inline void clear_has_totalsinc();
  inline void set_has_totalsdec();
  inline void clear_has_totalsdec();
  inline void set_has_additionalinfo();
  inline void clear_has_additionalinfo();
  inline void set_has_version();
  inline void clear_has_version();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* invoicedate_;
  ::std::string* invoicenumber_;
  ::std::string* invoicerevisiondate_;
  ::std::string* invoicerevisionnumber_;
  ::std::string* invoicecorrectiondate_;
  ::std::string* invoicecorrectionnumber_;
  ::std::string* invoicecorrectionrevisiondate_;
  ::std::string* invoicecorrectionrevisionnumber_;
  ::Diadoc::Api::Proto::Invoicing::DiadocOrganizationInfo* seller_;
  ::Diadoc::Api::Proto::Invoicing::DiadocOrganizationInfo* buyer_;
  ::Diadoc::Api::Proto::Invoicing::Signer* signer_;
  ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::InvoiceCorrectionItem > items_;
  ::std::string* currency_;
  ::Diadoc::Api::Proto::Invoicing::InvoiceTotalsDiff* totalsinc_;
  ::Diadoc::Api::Proto::Invoicing::InvoiceTotalsDiff* totalsdec_;
  ::std::string* additionalinfo_;
  ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::AdditionalInfo > additionalinfos_;
  int version_;
  friend void  protobuf_AddDesc_Invoicing_2fInvoiceInfo_2eproto();
  friend void protobuf_AssignDesc_Invoicing_2fInvoiceInfo_2eproto();
  friend void protobuf_ShutdownFile_Invoicing_2fInvoiceInfo_2eproto();

  void InitAsDefaultInstance();
  static InvoiceCorrectionInfo* default_instance_;
};
// -------------------------------------------------------------------

class InvoiceTotalsDiff : public ::google::protobuf::Message {
 public:
  InvoiceTotalsDiff();
  virtual ~InvoiceTotalsDiff();

  InvoiceTotalsDiff(const InvoiceTotalsDiff& from);

  inline InvoiceTotalsDiff& operator=(const InvoiceTotalsDiff& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InvoiceTotalsDiff& default_instance();

  void Swap(InvoiceTotalsDiff* other);

  // implements Message ----------------------------------------------

  InvoiceTotalsDiff* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InvoiceTotalsDiff& from);
  void MergeFrom(const InvoiceTotalsDiff& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string TotalWithVatExcluded = 1;
  inline bool has_totalwithvatexcluded() const;
  inline void clear_totalwithvatexcluded();
  static const int kTotalWithVatExcludedFieldNumber = 1;
  inline const ::std::string& totalwithvatexcluded() const;
  inline void set_totalwithvatexcluded(const ::std::string& value);
  inline void set_totalwithvatexcluded(const char* value);
  inline void set_totalwithvatexcluded(const char* value, size_t size);
  inline ::std::string* mutable_totalwithvatexcluded();
  inline ::std::string* release_totalwithvatexcluded();
  inline void set_allocated_totalwithvatexcluded(::std::string* totalwithvatexcluded);

  // optional string Vat = 2;
  inline bool has_vat() const;
  inline void clear_vat();
  static const int kVatFieldNumber = 2;
  inline const ::std::string& vat() const;
  inline void set_vat(const ::std::string& value);
  inline void set_vat(const char* value);
  inline void set_vat(const char* value, size_t size);
  inline ::std::string* mutable_vat();
  inline ::std::string* release_vat();
  inline void set_allocated_vat(::std::string* vat);

  // required string Total = 3;
  inline bool has_total() const;
  inline void clear_total();
  static const int kTotalFieldNumber = 3;
  inline const ::std::string& total() const;
  inline void set_total(const ::std::string& value);
  inline void set_total(const char* value);
  inline void set_total(const char* value, size_t size);
  inline ::std::string* mutable_total();
  inline ::std::string* release_total();
  inline void set_allocated_total(::std::string* total);

  // @@protoc_insertion_point(class_scope:Diadoc.Api.Proto.Invoicing.InvoiceTotalsDiff)
 private:
  inline void set_has_totalwithvatexcluded();
  inline void clear_has_totalwithvatexcluded();
  inline void set_has_vat();
  inline void clear_has_vat();
  inline void set_has_total();
  inline void clear_has_total();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* totalwithvatexcluded_;
  ::std::string* vat_;
  ::std::string* total_;
  friend void  protobuf_AddDesc_Invoicing_2fInvoiceInfo_2eproto();
  friend void protobuf_AssignDesc_Invoicing_2fInvoiceInfo_2eproto();
  friend void protobuf_ShutdownFile_Invoicing_2fInvoiceInfo_2eproto();

  void InitAsDefaultInstance();
  static InvoiceTotalsDiff* default_instance_;
};
// -------------------------------------------------------------------

class InvoiceCorrectionItem : public ::google::protobuf::Message {
 public:
  InvoiceCorrectionItem();
  virtual ~InvoiceCorrectionItem();

  InvoiceCorrectionItem(const InvoiceCorrectionItem& from);

  inline InvoiceCorrectionItem& operator=(const InvoiceCorrectionItem& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InvoiceCorrectionItem& default_instance();

  void Swap(InvoiceCorrectionItem* other);

  // implements Message ----------------------------------------------

  InvoiceCorrectionItem* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InvoiceCorrectionItem& from);
  void MergeFrom(const InvoiceCorrectionItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string Product = 1;
  inline bool has_product() const;
  inline void clear_product();
  static const int kProductFieldNumber = 1;
  inline const ::std::string& product() const;
  inline void set_product(const ::std::string& value);
  inline void set_product(const char* value);
  inline void set_product(const char* value, size_t size);
  inline ::std::string* mutable_product();
  inline ::std::string* release_product();
  inline void set_allocated_product(::std::string* product);

  // required .Diadoc.Api.Proto.Invoicing.CorrectableInvoiceItemFields OriginalValues = 2;
  inline bool has_originalvalues() const;
  inline void clear_originalvalues();
  static const int kOriginalValuesFieldNumber = 2;
  inline const ::Diadoc::Api::Proto::Invoicing::CorrectableInvoiceItemFields& originalvalues() const;
  inline ::Diadoc::Api::Proto::Invoicing::CorrectableInvoiceItemFields* mutable_originalvalues();
  inline ::Diadoc::Api::Proto::Invoicing::CorrectableInvoiceItemFields* release_originalvalues();
  inline void set_allocated_originalvalues(::Diadoc::Api::Proto::Invoicing::CorrectableInvoiceItemFields* originalvalues);

  // required .Diadoc.Api.Proto.Invoicing.CorrectableInvoiceItemFields CorrectedValues = 3;
  inline bool has_correctedvalues() const;
  inline void clear_correctedvalues();
  static const int kCorrectedValuesFieldNumber = 3;
  inline const ::Diadoc::Api::Proto::Invoicing::CorrectableInvoiceItemFields& correctedvalues() const;
  inline ::Diadoc::Api::Proto::Invoicing::CorrectableInvoiceItemFields* mutable_correctedvalues();
  inline ::Diadoc::Api::Proto::Invoicing::CorrectableInvoiceItemFields* release_correctedvalues();
  inline void set_allocated_correctedvalues(::Diadoc::Api::Proto::Invoicing::CorrectableInvoiceItemFields* correctedvalues);

  // optional .Diadoc.Api.Proto.Invoicing.InvoiceItemAmountsDiff AmountsInc = 4;
  inline bool has_amountsinc() const;
  inline void clear_amountsinc();
  static const int kAmountsIncFieldNumber = 4;
  inline const ::Diadoc::Api::Proto::Invoicing::InvoiceItemAmountsDiff& amountsinc() const;
  inline ::Diadoc::Api::Proto::Invoicing::InvoiceItemAmountsDiff* mutable_amountsinc();
  inline ::Diadoc::Api::Proto::Invoicing::InvoiceItemAmountsDiff* release_amountsinc();
  inline void set_allocated_amountsinc(::Diadoc::Api::Proto::Invoicing::InvoiceItemAmountsDiff* amountsinc);

  // optional .Diadoc.Api.Proto.Invoicing.InvoiceItemAmountsDiff AmountsDec = 5;
  inline bool has_amountsdec() const;
  inline void clear_amountsdec();
  static const int kAmountsDecFieldNumber = 5;
  inline const ::Diadoc::Api::Proto::Invoicing::InvoiceItemAmountsDiff& amountsdec() const;
  inline ::Diadoc::Api::Proto::Invoicing::InvoiceItemAmountsDiff* mutable_amountsdec();
  inline ::Diadoc::Api::Proto::Invoicing::InvoiceItemAmountsDiff* release_amountsdec();
  inline void set_allocated_amountsdec(::Diadoc::Api::Proto::Invoicing::InvoiceItemAmountsDiff* amountsdec);

  // optional string AdditionalInfo = 6;
  inline bool has_additionalinfo() const;
  inline void clear_additionalinfo();
  static const int kAdditionalInfoFieldNumber = 6;
  inline const ::std::string& additionalinfo() const;
  inline void set_additionalinfo(const ::std::string& value);
  inline void set_additionalinfo(const char* value);
  inline void set_additionalinfo(const char* value, size_t size);
  inline ::std::string* mutable_additionalinfo();
  inline ::std::string* release_additionalinfo();
  inline void set_allocated_additionalinfo(::std::string* additionalinfo);

  // repeated .Diadoc.Api.Proto.Invoicing.AdditionalInfo AdditionalInfos = 7;
  inline int additionalinfos_size() const;
  inline void clear_additionalinfos();
  static const int kAdditionalInfosFieldNumber = 7;
  inline const ::Diadoc::Api::Proto::Invoicing::AdditionalInfo& additionalinfos(int index) const;
  inline ::Diadoc::Api::Proto::Invoicing::AdditionalInfo* mutable_additionalinfos(int index);
  inline ::Diadoc::Api::Proto::Invoicing::AdditionalInfo* add_additionalinfos();
  inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::AdditionalInfo >&
      additionalinfos() const;
  inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::AdditionalInfo >*
      mutable_additionalinfos();

  // @@protoc_insertion_point(class_scope:Diadoc.Api.Proto.Invoicing.InvoiceCorrectionItem)
 private:
  inline void set_has_product();
  inline void clear_has_product();
  inline void set_has_originalvalues();
  inline void clear_has_originalvalues();
  inline void set_has_correctedvalues();
  inline void clear_has_correctedvalues();
  inline void set_has_amountsinc();
  inline void clear_has_amountsinc();
  inline void set_has_amountsdec();
  inline void clear_has_amountsdec();
  inline void set_has_additionalinfo();
  inline void clear_has_additionalinfo();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* product_;
  ::Diadoc::Api::Proto::Invoicing::CorrectableInvoiceItemFields* originalvalues_;
  ::Diadoc::Api::Proto::Invoicing::CorrectableInvoiceItemFields* correctedvalues_;
  ::Diadoc::Api::Proto::Invoicing::InvoiceItemAmountsDiff* amountsinc_;
  ::Diadoc::Api::Proto::Invoicing::InvoiceItemAmountsDiff* amountsdec_;
  ::std::string* additionalinfo_;
  ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::AdditionalInfo > additionalinfos_;
  friend void  protobuf_AddDesc_Invoicing_2fInvoiceInfo_2eproto();
  friend void protobuf_AssignDesc_Invoicing_2fInvoiceInfo_2eproto();
  friend void protobuf_ShutdownFile_Invoicing_2fInvoiceInfo_2eproto();

  void InitAsDefaultInstance();
  static InvoiceCorrectionItem* default_instance_;
};
// -------------------------------------------------------------------

class CorrectableInvoiceItemFields : public ::google::protobuf::Message {
 public:
  CorrectableInvoiceItemFields();
  virtual ~CorrectableInvoiceItemFields();

  CorrectableInvoiceItemFields(const CorrectableInvoiceItemFields& from);

  inline CorrectableInvoiceItemFields& operator=(const CorrectableInvoiceItemFields& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CorrectableInvoiceItemFields& default_instance();

  void Swap(CorrectableInvoiceItemFields* other);

  // implements Message ----------------------------------------------

  CorrectableInvoiceItemFields* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CorrectableInvoiceItemFields& from);
  void MergeFrom(const CorrectableInvoiceItemFields& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string Unit = 1;
  inline bool has_unit() const;
  inline void clear_unit();
  static const int kUnitFieldNumber = 1;
  inline const ::std::string& unit() const;
  inline void set_unit(const ::std::string& value);
  inline void set_unit(const char* value);
  inline void set_unit(const char* value, size_t size);
  inline ::std::string* mutable_unit();
  inline ::std::string* release_unit();
  inline void set_allocated_unit(::std::string* unit);

  // optional string Quantity = 2;
  inline bool has_quantity() const;
  inline void clear_quantity();
  static const int kQuantityFieldNumber = 2;
  inline const ::std::string& quantity() const;
  inline void set_quantity(const ::std::string& value);
  inline void set_quantity(const char* value);
  inline void set_quantity(const char* value, size_t size);
  inline ::std::string* mutable_quantity();
  inline ::std::string* release_quantity();
  inline void set_allocated_quantity(::std::string* quantity);

  // optional string Price = 3;
  inline bool has_price() const;
  inline void clear_price();
  static const int kPriceFieldNumber = 3;
  inline const ::std::string& price() const;
  inline void set_price(const ::std::string& value);
  inline void set_price(const char* value);
  inline void set_price(const char* value, size_t size);
  inline ::std::string* mutable_price();
  inline ::std::string* release_price();
  inline void set_allocated_price(::std::string* price);

  // optional string Excise = 4;
  inline bool has_excise() const;
  inline void clear_excise();
  static const int kExciseFieldNumber = 4;
  inline const ::std::string& excise() const;
  inline void set_excise(const ::std::string& value);
  inline void set_excise(const char* value);
  inline void set_excise(const char* value, size_t size);
  inline ::std::string* mutable_excise();
  inline ::std::string* release_excise();
  inline void set_allocated_excise(::std::string* excise);

  // required .Diadoc.Api.Proto.Invoicing.TaxRate TaxRate = 5;
  inline bool has_taxrate() const;
  inline void clear_taxrate();
  static const int kTaxRateFieldNumber = 5;
  inline ::Diadoc::Api::Proto::Invoicing::TaxRate taxrate() const;
  inline void set_taxrate(::Diadoc::Api::Proto::Invoicing::TaxRate value);

  // optional string SubtotalWithVatExcluded = 6;
  inline bool has_subtotalwithvatexcluded() const;
  inline void clear_subtotalwithvatexcluded();
  static const int kSubtotalWithVatExcludedFieldNumber = 6;
  inline const ::std::string& subtotalwithvatexcluded() const;
  inline void set_subtotalwithvatexcluded(const ::std::string& value);
  inline void set_subtotalwithvatexcluded(const char* value);
  inline void set_subtotalwithvatexcluded(const char* value, size_t size);
  inline ::std::string* mutable_subtotalwithvatexcluded();
  inline ::std::string* release_subtotalwithvatexcluded();
  inline void set_allocated_subtotalwithvatexcluded(::std::string* subtotalwithvatexcluded);

  // optional string Vat = 7;
  inline bool has_vat() const;
  inline void clear_vat();
  static const int kVatFieldNumber = 7;
  inline const ::std::string& vat() const;
  inline void set_vat(const ::std::string& value);
  inline void set_vat(const char* value);
  inline void set_vat(const char* value, size_t size);
  inline ::std::string* mutable_vat();
  inline ::std::string* release_vat();
  inline void set_allocated_vat(::std::string* vat);

  // required string Subtotal = 8;
  inline bool has_subtotal() const;
  inline void clear_subtotal();
  static const int kSubtotalFieldNumber = 8;
  inline const ::std::string& subtotal() const;
  inline void set_subtotal(const ::std::string& value);
  inline void set_subtotal(const char* value);
  inline void set_subtotal(const char* value, size_t size);
  inline ::std::string* mutable_subtotal();
  inline ::std::string* release_subtotal();
  inline void set_allocated_subtotal(::std::string* subtotal);

  // @@protoc_insertion_point(class_scope:Diadoc.Api.Proto.Invoicing.CorrectableInvoiceItemFields)
 private:
  inline void set_has_unit();
  inline void clear_has_unit();
  inline void set_has_quantity();
  inline void clear_has_quantity();
  inline void set_has_price();
  inline void clear_has_price();
  inline void set_has_excise();
  inline void clear_has_excise();
  inline void set_has_taxrate();
  inline void clear_has_taxrate();
  inline void set_has_subtotalwithvatexcluded();
  inline void clear_has_subtotalwithvatexcluded();
  inline void set_has_vat();
  inline void clear_has_vat();
  inline void set_has_subtotal();
  inline void clear_has_subtotal();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* unit_;
  ::std::string* quantity_;
  ::std::string* price_;
  ::std::string* excise_;
  ::std::string* subtotalwithvatexcluded_;
  ::std::string* vat_;
  ::std::string* subtotal_;
  int taxrate_;
  friend void  protobuf_AddDesc_Invoicing_2fInvoiceInfo_2eproto();
  friend void protobuf_AssignDesc_Invoicing_2fInvoiceInfo_2eproto();
  friend void protobuf_ShutdownFile_Invoicing_2fInvoiceInfo_2eproto();

  void InitAsDefaultInstance();
  static CorrectableInvoiceItemFields* default_instance_;
};
// -------------------------------------------------------------------

class InvoiceItemAmountsDiff : public ::google::protobuf::Message {
 public:
  InvoiceItemAmountsDiff();
  virtual ~InvoiceItemAmountsDiff();

  InvoiceItemAmountsDiff(const InvoiceItemAmountsDiff& from);

  inline InvoiceItemAmountsDiff& operator=(const InvoiceItemAmountsDiff& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InvoiceItemAmountsDiff& default_instance();

  void Swap(InvoiceItemAmountsDiff* other);

  // implements Message ----------------------------------------------

  InvoiceItemAmountsDiff* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InvoiceItemAmountsDiff& from);
  void MergeFrom(const InvoiceItemAmountsDiff& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string Excise = 1;
  inline bool has_excise() const;
  inline void clear_excise();
  static const int kExciseFieldNumber = 1;
  inline const ::std::string& excise() const;
  inline void set_excise(const ::std::string& value);
  inline void set_excise(const char* value);
  inline void set_excise(const char* value, size_t size);
  inline ::std::string* mutable_excise();
  inline ::std::string* release_excise();
  inline void set_allocated_excise(::std::string* excise);

  // optional string SubtotalWithVatExcluded = 2;
  inline bool has_subtotalwithvatexcluded() const;
  inline void clear_subtotalwithvatexcluded();
  static const int kSubtotalWithVatExcludedFieldNumber = 2;
  inline const ::std::string& subtotalwithvatexcluded() const;
  inline void set_subtotalwithvatexcluded(const ::std::string& value);
  inline void set_subtotalwithvatexcluded(const char* value);
  inline void set_subtotalwithvatexcluded(const char* value, size_t size);
  inline ::std::string* mutable_subtotalwithvatexcluded();
  inline ::std::string* release_subtotalwithvatexcluded();
  inline void set_allocated_subtotalwithvatexcluded(::std::string* subtotalwithvatexcluded);

  // optional string Vat = 3;
  inline bool has_vat() const;
  inline void clear_vat();
  static const int kVatFieldNumber = 3;
  inline const ::std::string& vat() const;
  inline void set_vat(const ::std::string& value);
  inline void set_vat(const char* value);
  inline void set_vat(const char* value, size_t size);
  inline ::std::string* mutable_vat();
  inline ::std::string* release_vat();
  inline void set_allocated_vat(::std::string* vat);

  // optional string Subtotal = 4;
  inline bool has_subtotal() const;
  inline void clear_subtotal();
  static const int kSubtotalFieldNumber = 4;
  inline const ::std::string& subtotal() const;
  inline void set_subtotal(const ::std::string& value);
  inline void set_subtotal(const char* value);
  inline void set_subtotal(const char* value, size_t size);
  inline ::std::string* mutable_subtotal();
  inline ::std::string* release_subtotal();
  inline void set_allocated_subtotal(::std::string* subtotal);

  // @@protoc_insertion_point(class_scope:Diadoc.Api.Proto.Invoicing.InvoiceItemAmountsDiff)
 private:
  inline void set_has_excise();
  inline void clear_has_excise();
  inline void set_has_subtotalwithvatexcluded();
  inline void clear_has_subtotalwithvatexcluded();
  inline void set_has_vat();
  inline void clear_has_vat();
  inline void set_has_subtotal();
  inline void clear_has_subtotal();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* excise_;
  ::std::string* subtotalwithvatexcluded_;
  ::std::string* vat_;
  ::std::string* subtotal_;
  friend void  protobuf_AddDesc_Invoicing_2fInvoiceInfo_2eproto();
  friend void protobuf_AssignDesc_Invoicing_2fInvoiceInfo_2eproto();
  friend void protobuf_ShutdownFile_Invoicing_2fInvoiceInfo_2eproto();

  void InitAsDefaultInstance();
  static InvoiceItemAmountsDiff* default_instance_;
};
// ===================================================================


// ===================================================================

// InvoiceInfo

// required string InvoiceDate = 1;
inline bool InvoiceInfo::has_invoicedate() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InvoiceInfo::set_has_invoicedate() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InvoiceInfo::clear_has_invoicedate() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InvoiceInfo::clear_invoicedate() {
  if (invoicedate_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    invoicedate_->clear();
  }
  clear_has_invoicedate();
}
inline const ::std::string& InvoiceInfo::invoicedate() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.InvoiceInfo.InvoiceDate)
  return *invoicedate_;
}
inline void InvoiceInfo::set_invoicedate(const ::std::string& value) {
  set_has_invoicedate();
  if (invoicedate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    invoicedate_ = new ::std::string;
  }
  invoicedate_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.InvoiceInfo.InvoiceDate)
}
inline void InvoiceInfo::set_invoicedate(const char* value) {
  set_has_invoicedate();
  if (invoicedate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    invoicedate_ = new ::std::string;
  }
  invoicedate_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.InvoiceInfo.InvoiceDate)
}
inline void InvoiceInfo::set_invoicedate(const char* value, size_t size) {
  set_has_invoicedate();
  if (invoicedate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    invoicedate_ = new ::std::string;
  }
  invoicedate_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.InvoiceInfo.InvoiceDate)
}
inline ::std::string* InvoiceInfo::mutable_invoicedate() {
  set_has_invoicedate();
  if (invoicedate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    invoicedate_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.InvoiceInfo.InvoiceDate)
  return invoicedate_;
}
inline ::std::string* InvoiceInfo::release_invoicedate() {
  clear_has_invoicedate();
  if (invoicedate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = invoicedate_;
    invoicedate_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void InvoiceInfo::set_allocated_invoicedate(::std::string* invoicedate) {
  if (invoicedate_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete invoicedate_;
  }
  if (invoicedate) {
    set_has_invoicedate();
    invoicedate_ = invoicedate;
  } else {
    clear_has_invoicedate();
    invoicedate_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.InvoiceInfo.InvoiceDate)
}

// required string InvoiceNumber = 2;
inline bool InvoiceInfo::has_invoicenumber() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InvoiceInfo::set_has_invoicenumber() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InvoiceInfo::clear_has_invoicenumber() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InvoiceInfo::clear_invoicenumber() {
  if (invoicenumber_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    invoicenumber_->clear();
  }
  clear_has_invoicenumber();
}
inline const ::std::string& InvoiceInfo::invoicenumber() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.InvoiceInfo.InvoiceNumber)
  return *invoicenumber_;
}
inline void InvoiceInfo::set_invoicenumber(const ::std::string& value) {
  set_has_invoicenumber();
  if (invoicenumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    invoicenumber_ = new ::std::string;
  }
  invoicenumber_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.InvoiceInfo.InvoiceNumber)
}
inline void InvoiceInfo::set_invoicenumber(const char* value) {
  set_has_invoicenumber();
  if (invoicenumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    invoicenumber_ = new ::std::string;
  }
  invoicenumber_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.InvoiceInfo.InvoiceNumber)
}
inline void InvoiceInfo::set_invoicenumber(const char* value, size_t size) {
  set_has_invoicenumber();
  if (invoicenumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    invoicenumber_ = new ::std::string;
  }
  invoicenumber_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.InvoiceInfo.InvoiceNumber)
}
inline ::std::string* InvoiceInfo::mutable_invoicenumber() {
  set_has_invoicenumber();
  if (invoicenumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    invoicenumber_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.InvoiceInfo.InvoiceNumber)
  return invoicenumber_;
}
inline ::std::string* InvoiceInfo::release_invoicenumber() {
  clear_has_invoicenumber();
  if (invoicenumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = invoicenumber_;
    invoicenumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void InvoiceInfo::set_allocated_invoicenumber(::std::string* invoicenumber) {
  if (invoicenumber_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete invoicenumber_;
  }
  if (invoicenumber) {
    set_has_invoicenumber();
    invoicenumber_ = invoicenumber;
  } else {
    clear_has_invoicenumber();
    invoicenumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.InvoiceInfo.InvoiceNumber)
}

// required .Diadoc.Api.Proto.Invoicing.DiadocOrganizationInfo Seller = 3;
inline bool InvoiceInfo::has_seller() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InvoiceInfo::set_has_seller() {
  _has_bits_[0] |= 0x00000004u;
}
inline void InvoiceInfo::clear_has_seller() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void InvoiceInfo::clear_seller() {
  if (seller_ != NULL) seller_->::Diadoc::Api::Proto::Invoicing::DiadocOrganizationInfo::Clear();
  clear_has_seller();
}
inline const ::Diadoc::Api::Proto::Invoicing::DiadocOrganizationInfo& InvoiceInfo::seller() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.InvoiceInfo.Seller)
  return seller_ != NULL ? *seller_ : *default_instance_->seller_;
}
inline ::Diadoc::Api::Proto::Invoicing::DiadocOrganizationInfo* InvoiceInfo::mutable_seller() {
  set_has_seller();
  if (seller_ == NULL) seller_ = new ::Diadoc::Api::Proto::Invoicing::DiadocOrganizationInfo;
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.InvoiceInfo.Seller)
  return seller_;
}
inline ::Diadoc::Api::Proto::Invoicing::DiadocOrganizationInfo* InvoiceInfo::release_seller() {
  clear_has_seller();
  ::Diadoc::Api::Proto::Invoicing::DiadocOrganizationInfo* temp = seller_;
  seller_ = NULL;
  return temp;
}
inline void InvoiceInfo::set_allocated_seller(::Diadoc::Api::Proto::Invoicing::DiadocOrganizationInfo* seller) {
  delete seller_;
  seller_ = seller;
  if (seller) {
    set_has_seller();
  } else {
    clear_has_seller();
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.InvoiceInfo.Seller)
}

// required .Diadoc.Api.Proto.Invoicing.DiadocOrganizationInfo Buyer = 4;
inline bool InvoiceInfo::has_buyer() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void InvoiceInfo::set_has_buyer() {
  _has_bits_[0] |= 0x00000008u;
}
inline void InvoiceInfo::clear_has_buyer() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void InvoiceInfo::clear_buyer() {
  if (buyer_ != NULL) buyer_->::Diadoc::Api::Proto::Invoicing::DiadocOrganizationInfo::Clear();
  clear_has_buyer();
}
inline const ::Diadoc::Api::Proto::Invoicing::DiadocOrganizationInfo& InvoiceInfo::buyer() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.InvoiceInfo.Buyer)
  return buyer_ != NULL ? *buyer_ : *default_instance_->buyer_;
}
inline ::Diadoc::Api::Proto::Invoicing::DiadocOrganizationInfo* InvoiceInfo::mutable_buyer() {
  set_has_buyer();
  if (buyer_ == NULL) buyer_ = new ::Diadoc::Api::Proto::Invoicing::DiadocOrganizationInfo;
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.InvoiceInfo.Buyer)
  return buyer_;
}
inline ::Diadoc::Api::Proto::Invoicing::DiadocOrganizationInfo* InvoiceInfo::release_buyer() {
  clear_has_buyer();
  ::Diadoc::Api::Proto::Invoicing::DiadocOrganizationInfo* temp = buyer_;
  buyer_ = NULL;
  return temp;
}
inline void InvoiceInfo::set_allocated_buyer(::Diadoc::Api::Proto::Invoicing::DiadocOrganizationInfo* buyer) {
  delete buyer_;
  buyer_ = buyer;
  if (buyer) {
    set_has_buyer();
  } else {
    clear_has_buyer();
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.InvoiceInfo.Buyer)
}

// optional .Diadoc.Api.Proto.Invoicing.ShipperOrConsignee Shipper = 5;
inline bool InvoiceInfo::has_shipper() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void InvoiceInfo::set_has_shipper() {
  _has_bits_[0] |= 0x00000010u;
}
inline void InvoiceInfo::clear_has_shipper() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void InvoiceInfo::clear_shipper() {
  if (shipper_ != NULL) shipper_->::Diadoc::Api::Proto::Invoicing::ShipperOrConsignee::Clear();
  clear_has_shipper();
}
inline const ::Diadoc::Api::Proto::Invoicing::ShipperOrConsignee& InvoiceInfo::shipper() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.InvoiceInfo.Shipper)
  return shipper_ != NULL ? *shipper_ : *default_instance_->shipper_;
}
inline ::Diadoc::Api::Proto::Invoicing::ShipperOrConsignee* InvoiceInfo::mutable_shipper() {
  set_has_shipper();
  if (shipper_ == NULL) shipper_ = new ::Diadoc::Api::Proto::Invoicing::ShipperOrConsignee;
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.InvoiceInfo.Shipper)
  return shipper_;
}
inline ::Diadoc::Api::Proto::Invoicing::ShipperOrConsignee* InvoiceInfo::release_shipper() {
  clear_has_shipper();
  ::Diadoc::Api::Proto::Invoicing::ShipperOrConsignee* temp = shipper_;
  shipper_ = NULL;
  return temp;
}
inline void InvoiceInfo::set_allocated_shipper(::Diadoc::Api::Proto::Invoicing::ShipperOrConsignee* shipper) {
  delete shipper_;
  shipper_ = shipper;
  if (shipper) {
    set_has_shipper();
  } else {
    clear_has_shipper();
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.InvoiceInfo.Shipper)
}

// optional .Diadoc.Api.Proto.Invoicing.ShipperOrConsignee Consignee = 6;
inline bool InvoiceInfo::has_consignee() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void InvoiceInfo::set_has_consignee() {
  _has_bits_[0] |= 0x00000020u;
}
inline void InvoiceInfo::clear_has_consignee() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void InvoiceInfo::clear_consignee() {
  if (consignee_ != NULL) consignee_->::Diadoc::Api::Proto::Invoicing::ShipperOrConsignee::Clear();
  clear_has_consignee();
}
inline const ::Diadoc::Api::Proto::Invoicing::ShipperOrConsignee& InvoiceInfo::consignee() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.InvoiceInfo.Consignee)
  return consignee_ != NULL ? *consignee_ : *default_instance_->consignee_;
}
inline ::Diadoc::Api::Proto::Invoicing::ShipperOrConsignee* InvoiceInfo::mutable_consignee() {
  set_has_consignee();
  if (consignee_ == NULL) consignee_ = new ::Diadoc::Api::Proto::Invoicing::ShipperOrConsignee;
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.InvoiceInfo.Consignee)
  return consignee_;
}
inline ::Diadoc::Api::Proto::Invoicing::ShipperOrConsignee* InvoiceInfo::release_consignee() {
  clear_has_consignee();
  ::Diadoc::Api::Proto::Invoicing::ShipperOrConsignee* temp = consignee_;
  consignee_ = NULL;
  return temp;
}
inline void InvoiceInfo::set_allocated_consignee(::Diadoc::Api::Proto::Invoicing::ShipperOrConsignee* consignee) {
  delete consignee_;
  consignee_ = consignee;
  if (consignee) {
    set_has_consignee();
  } else {
    clear_has_consignee();
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.InvoiceInfo.Consignee)
}

// required .Diadoc.Api.Proto.Invoicing.Signer Signer = 7;
inline bool InvoiceInfo::has_signer() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void InvoiceInfo::set_has_signer() {
  _has_bits_[0] |= 0x00000040u;
}
inline void InvoiceInfo::clear_has_signer() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void InvoiceInfo::clear_signer() {
  if (signer_ != NULL) signer_->::Diadoc::Api::Proto::Invoicing::Signer::Clear();
  clear_has_signer();
}
inline const ::Diadoc::Api::Proto::Invoicing::Signer& InvoiceInfo::signer() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.InvoiceInfo.Signer)
  return signer_ != NULL ? *signer_ : *default_instance_->signer_;
}
inline ::Diadoc::Api::Proto::Invoicing::Signer* InvoiceInfo::mutable_signer() {
  set_has_signer();
  if (signer_ == NULL) signer_ = new ::Diadoc::Api::Proto::Invoicing::Signer;
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.InvoiceInfo.Signer)
  return signer_;
}
inline ::Diadoc::Api::Proto::Invoicing::Signer* InvoiceInfo::release_signer() {
  clear_has_signer();
  ::Diadoc::Api::Proto::Invoicing::Signer* temp = signer_;
  signer_ = NULL;
  return temp;
}
inline void InvoiceInfo::set_allocated_signer(::Diadoc::Api::Proto::Invoicing::Signer* signer) {
  delete signer_;
  signer_ = signer;
  if (signer) {
    set_has_signer();
  } else {
    clear_has_signer();
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.InvoiceInfo.Signer)
}

// repeated .Diadoc.Api.Proto.Invoicing.PaymentDocumentInfo PaymentDocuments = 8;
inline int InvoiceInfo::paymentdocuments_size() const {
  return paymentdocuments_.size();
}
inline void InvoiceInfo::clear_paymentdocuments() {
  paymentdocuments_.Clear();
}
inline const ::Diadoc::Api::Proto::Invoicing::PaymentDocumentInfo& InvoiceInfo::paymentdocuments(int index) const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.InvoiceInfo.PaymentDocuments)
  return paymentdocuments_.Get(index);
}
inline ::Diadoc::Api::Proto::Invoicing::PaymentDocumentInfo* InvoiceInfo::mutable_paymentdocuments(int index) {
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.InvoiceInfo.PaymentDocuments)
  return paymentdocuments_.Mutable(index);
}
inline ::Diadoc::Api::Proto::Invoicing::PaymentDocumentInfo* InvoiceInfo::add_paymentdocuments() {
  // @@protoc_insertion_point(field_add:Diadoc.Api.Proto.Invoicing.InvoiceInfo.PaymentDocuments)
  return paymentdocuments_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::PaymentDocumentInfo >&
InvoiceInfo::paymentdocuments() const {
  // @@protoc_insertion_point(field_list:Diadoc.Api.Proto.Invoicing.InvoiceInfo.PaymentDocuments)
  return paymentdocuments_;
}
inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::PaymentDocumentInfo >*
InvoiceInfo::mutable_paymentdocuments() {
  // @@protoc_insertion_point(field_mutable_list:Diadoc.Api.Proto.Invoicing.InvoiceInfo.PaymentDocuments)
  return &paymentdocuments_;
}

// repeated .Diadoc.Api.Proto.Invoicing.InvoiceItem Items = 9;
inline int InvoiceInfo::items_size() const {
  return items_.size();
}
inline void InvoiceInfo::clear_items() {
  items_.Clear();
}
inline const ::Diadoc::Api::Proto::Invoicing::InvoiceItem& InvoiceInfo::items(int index) const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.InvoiceInfo.Items)
  return items_.Get(index);
}
inline ::Diadoc::Api::Proto::Invoicing::InvoiceItem* InvoiceInfo::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.InvoiceInfo.Items)
  return items_.Mutable(index);
}
inline ::Diadoc::Api::Proto::Invoicing::InvoiceItem* InvoiceInfo::add_items() {
  // @@protoc_insertion_point(field_add:Diadoc.Api.Proto.Invoicing.InvoiceInfo.Items)
  return items_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::InvoiceItem >&
InvoiceInfo::items() const {
  // @@protoc_insertion_point(field_list:Diadoc.Api.Proto.Invoicing.InvoiceInfo.Items)
  return items_;
}
inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::InvoiceItem >*
InvoiceInfo::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:Diadoc.Api.Proto.Invoicing.InvoiceInfo.Items)
  return &items_;
}

// optional string Currency = 10;
inline bool InvoiceInfo::has_currency() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void InvoiceInfo::set_has_currency() {
  _has_bits_[0] |= 0x00000200u;
}
inline void InvoiceInfo::clear_has_currency() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void InvoiceInfo::clear_currency() {
  if (currency_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    currency_->clear();
  }
  clear_has_currency();
}
inline const ::std::string& InvoiceInfo::currency() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.InvoiceInfo.Currency)
  return *currency_;
}
inline void InvoiceInfo::set_currency(const ::std::string& value) {
  set_has_currency();
  if (currency_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    currency_ = new ::std::string;
  }
  currency_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.InvoiceInfo.Currency)
}
inline void InvoiceInfo::set_currency(const char* value) {
  set_has_currency();
  if (currency_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    currency_ = new ::std::string;
  }
  currency_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.InvoiceInfo.Currency)
}
inline void InvoiceInfo::set_currency(const char* value, size_t size) {
  set_has_currency();
  if (currency_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    currency_ = new ::std::string;
  }
  currency_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.InvoiceInfo.Currency)
}
inline ::std::string* InvoiceInfo::mutable_currency() {
  set_has_currency();
  if (currency_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    currency_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.InvoiceInfo.Currency)
  return currency_;
}
inline ::std::string* InvoiceInfo::release_currency() {
  clear_has_currency();
  if (currency_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = currency_;
    currency_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void InvoiceInfo::set_allocated_currency(::std::string* currency) {
  if (currency_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete currency_;
  }
  if (currency) {
    set_has_currency();
    currency_ = currency;
  } else {
    clear_has_currency();
    currency_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.InvoiceInfo.Currency)
}

// optional string TotalWithVatExcluded = 11;
inline bool InvoiceInfo::has_totalwithvatexcluded() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void InvoiceInfo::set_has_totalwithvatexcluded() {
  _has_bits_[0] |= 0x00000400u;
}
inline void InvoiceInfo::clear_has_totalwithvatexcluded() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void InvoiceInfo::clear_totalwithvatexcluded() {
  if (totalwithvatexcluded_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    totalwithvatexcluded_->clear();
  }
  clear_has_totalwithvatexcluded();
}
inline const ::std::string& InvoiceInfo::totalwithvatexcluded() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.InvoiceInfo.TotalWithVatExcluded)
  return *totalwithvatexcluded_;
}
inline void InvoiceInfo::set_totalwithvatexcluded(const ::std::string& value) {
  set_has_totalwithvatexcluded();
  if (totalwithvatexcluded_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    totalwithvatexcluded_ = new ::std::string;
  }
  totalwithvatexcluded_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.InvoiceInfo.TotalWithVatExcluded)
}
inline void InvoiceInfo::set_totalwithvatexcluded(const char* value) {
  set_has_totalwithvatexcluded();
  if (totalwithvatexcluded_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    totalwithvatexcluded_ = new ::std::string;
  }
  totalwithvatexcluded_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.InvoiceInfo.TotalWithVatExcluded)
}
inline void InvoiceInfo::set_totalwithvatexcluded(const char* value, size_t size) {
  set_has_totalwithvatexcluded();
  if (totalwithvatexcluded_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    totalwithvatexcluded_ = new ::std::string;
  }
  totalwithvatexcluded_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.InvoiceInfo.TotalWithVatExcluded)
}
inline ::std::string* InvoiceInfo::mutable_totalwithvatexcluded() {
  set_has_totalwithvatexcluded();
  if (totalwithvatexcluded_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    totalwithvatexcluded_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.InvoiceInfo.TotalWithVatExcluded)
  return totalwithvatexcluded_;
}
inline ::std::string* InvoiceInfo::release_totalwithvatexcluded() {
  clear_has_totalwithvatexcluded();
  if (totalwithvatexcluded_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = totalwithvatexcluded_;
    totalwithvatexcluded_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void InvoiceInfo::set_allocated_totalwithvatexcluded(::std::string* totalwithvatexcluded) {
  if (totalwithvatexcluded_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete totalwithvatexcluded_;
  }
  if (totalwithvatexcluded) {
    set_has_totalwithvatexcluded();
    totalwithvatexcluded_ = totalwithvatexcluded;
  } else {
    clear_has_totalwithvatexcluded();
    totalwithvatexcluded_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.InvoiceInfo.TotalWithVatExcluded)
}

// optional string Vat = 12;
inline bool InvoiceInfo::has_vat() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void InvoiceInfo::set_has_vat() {
  _has_bits_[0] |= 0x00000800u;
}
inline void InvoiceInfo::clear_has_vat() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void InvoiceInfo::clear_vat() {
  if (vat_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vat_->clear();
  }
  clear_has_vat();
}
inline const ::std::string& InvoiceInfo::vat() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.InvoiceInfo.Vat)
  return *vat_;
}
inline void InvoiceInfo::set_vat(const ::std::string& value) {
  set_has_vat();
  if (vat_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vat_ = new ::std::string;
  }
  vat_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.InvoiceInfo.Vat)
}
inline void InvoiceInfo::set_vat(const char* value) {
  set_has_vat();
  if (vat_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vat_ = new ::std::string;
  }
  vat_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.InvoiceInfo.Vat)
}
inline void InvoiceInfo::set_vat(const char* value, size_t size) {
  set_has_vat();
  if (vat_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vat_ = new ::std::string;
  }
  vat_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.InvoiceInfo.Vat)
}
inline ::std::string* InvoiceInfo::mutable_vat() {
  set_has_vat();
  if (vat_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vat_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.InvoiceInfo.Vat)
  return vat_;
}
inline ::std::string* InvoiceInfo::release_vat() {
  clear_has_vat();
  if (vat_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = vat_;
    vat_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void InvoiceInfo::set_allocated_vat(::std::string* vat) {
  if (vat_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete vat_;
  }
  if (vat) {
    set_has_vat();
    vat_ = vat;
  } else {
    clear_has_vat();
    vat_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.InvoiceInfo.Vat)
}

// required string Total = 13;
inline bool InvoiceInfo::has_total() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void InvoiceInfo::set_has_total() {
  _has_bits_[0] |= 0x00001000u;
}
inline void InvoiceInfo::clear_has_total() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void InvoiceInfo::clear_total() {
  if (total_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    total_->clear();
  }
  clear_has_total();
}
inline const ::std::string& InvoiceInfo::total() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.InvoiceInfo.Total)
  return *total_;
}
inline void InvoiceInfo::set_total(const ::std::string& value) {
  set_has_total();
  if (total_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    total_ = new ::std::string;
  }
  total_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.InvoiceInfo.Total)
}
inline void InvoiceInfo::set_total(const char* value) {
  set_has_total();
  if (total_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    total_ = new ::std::string;
  }
  total_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.InvoiceInfo.Total)
}
inline void InvoiceInfo::set_total(const char* value, size_t size) {
  set_has_total();
  if (total_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    total_ = new ::std::string;
  }
  total_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.InvoiceInfo.Total)
}
inline ::std::string* InvoiceInfo::mutable_total() {
  set_has_total();
  if (total_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    total_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.InvoiceInfo.Total)
  return total_;
}
inline ::std::string* InvoiceInfo::release_total() {
  clear_has_total();
  if (total_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = total_;
    total_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void InvoiceInfo::set_allocated_total(::std::string* total) {
  if (total_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete total_;
  }
  if (total) {
    set_has_total();
    total_ = total;
  } else {
    clear_has_total();
    total_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.InvoiceInfo.Total)
}

// optional string AdditionalInfo = 14;
inline bool InvoiceInfo::has_additionalinfo() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void InvoiceInfo::set_has_additionalinfo() {
  _has_bits_[0] |= 0x00002000u;
}
inline void InvoiceInfo::clear_has_additionalinfo() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void InvoiceInfo::clear_additionalinfo() {
  if (additionalinfo_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    additionalinfo_->clear();
  }
  clear_has_additionalinfo();
}
inline const ::std::string& InvoiceInfo::additionalinfo() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.InvoiceInfo.AdditionalInfo)
  return *additionalinfo_;
}
inline void InvoiceInfo::set_additionalinfo(const ::std::string& value) {
  set_has_additionalinfo();
  if (additionalinfo_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    additionalinfo_ = new ::std::string;
  }
  additionalinfo_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.InvoiceInfo.AdditionalInfo)
}
inline void InvoiceInfo::set_additionalinfo(const char* value) {
  set_has_additionalinfo();
  if (additionalinfo_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    additionalinfo_ = new ::std::string;
  }
  additionalinfo_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.InvoiceInfo.AdditionalInfo)
}
inline void InvoiceInfo::set_additionalinfo(const char* value, size_t size) {
  set_has_additionalinfo();
  if (additionalinfo_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    additionalinfo_ = new ::std::string;
  }
  additionalinfo_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.InvoiceInfo.AdditionalInfo)
}
inline ::std::string* InvoiceInfo::mutable_additionalinfo() {
  set_has_additionalinfo();
  if (additionalinfo_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    additionalinfo_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.InvoiceInfo.AdditionalInfo)
  return additionalinfo_;
}
inline ::std::string* InvoiceInfo::release_additionalinfo() {
  clear_has_additionalinfo();
  if (additionalinfo_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = additionalinfo_;
    additionalinfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void InvoiceInfo::set_allocated_additionalinfo(::std::string* additionalinfo) {
  if (additionalinfo_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete additionalinfo_;
  }
  if (additionalinfo) {
    set_has_additionalinfo();
    additionalinfo_ = additionalinfo;
  } else {
    clear_has_additionalinfo();
    additionalinfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.InvoiceInfo.AdditionalInfo)
}

// optional string InvoiceRevisionDate = 15;
inline bool InvoiceInfo::has_invoicerevisiondate() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void InvoiceInfo::set_has_invoicerevisiondate() {
  _has_bits_[0] |= 0x00004000u;
}
inline void InvoiceInfo::clear_has_invoicerevisiondate() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void InvoiceInfo::clear_invoicerevisiondate() {
  if (invoicerevisiondate_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    invoicerevisiondate_->clear();
  }
  clear_has_invoicerevisiondate();
}
inline const ::std::string& InvoiceInfo::invoicerevisiondate() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.InvoiceInfo.InvoiceRevisionDate)
  return *invoicerevisiondate_;
}
inline void InvoiceInfo::set_invoicerevisiondate(const ::std::string& value) {
  set_has_invoicerevisiondate();
  if (invoicerevisiondate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    invoicerevisiondate_ = new ::std::string;
  }
  invoicerevisiondate_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.InvoiceInfo.InvoiceRevisionDate)
}
inline void InvoiceInfo::set_invoicerevisiondate(const char* value) {
  set_has_invoicerevisiondate();
  if (invoicerevisiondate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    invoicerevisiondate_ = new ::std::string;
  }
  invoicerevisiondate_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.InvoiceInfo.InvoiceRevisionDate)
}
inline void InvoiceInfo::set_invoicerevisiondate(const char* value, size_t size) {
  set_has_invoicerevisiondate();
  if (invoicerevisiondate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    invoicerevisiondate_ = new ::std::string;
  }
  invoicerevisiondate_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.InvoiceInfo.InvoiceRevisionDate)
}
inline ::std::string* InvoiceInfo::mutable_invoicerevisiondate() {
  set_has_invoicerevisiondate();
  if (invoicerevisiondate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    invoicerevisiondate_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.InvoiceInfo.InvoiceRevisionDate)
  return invoicerevisiondate_;
}
inline ::std::string* InvoiceInfo::release_invoicerevisiondate() {
  clear_has_invoicerevisiondate();
  if (invoicerevisiondate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = invoicerevisiondate_;
    invoicerevisiondate_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void InvoiceInfo::set_allocated_invoicerevisiondate(::std::string* invoicerevisiondate) {
  if (invoicerevisiondate_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete invoicerevisiondate_;
  }
  if (invoicerevisiondate) {
    set_has_invoicerevisiondate();
    invoicerevisiondate_ = invoicerevisiondate;
  } else {
    clear_has_invoicerevisiondate();
    invoicerevisiondate_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.InvoiceInfo.InvoiceRevisionDate)
}

// optional string InvoiceRevisionNumber = 16;
inline bool InvoiceInfo::has_invoicerevisionnumber() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void InvoiceInfo::set_has_invoicerevisionnumber() {
  _has_bits_[0] |= 0x00008000u;
}
inline void InvoiceInfo::clear_has_invoicerevisionnumber() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void InvoiceInfo::clear_invoicerevisionnumber() {
  if (invoicerevisionnumber_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    invoicerevisionnumber_->clear();
  }
  clear_has_invoicerevisionnumber();
}
inline const ::std::string& InvoiceInfo::invoicerevisionnumber() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.InvoiceInfo.InvoiceRevisionNumber)
  return *invoicerevisionnumber_;
}
inline void InvoiceInfo::set_invoicerevisionnumber(const ::std::string& value) {
  set_has_invoicerevisionnumber();
  if (invoicerevisionnumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    invoicerevisionnumber_ = new ::std::string;
  }
  invoicerevisionnumber_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.InvoiceInfo.InvoiceRevisionNumber)
}
inline void InvoiceInfo::set_invoicerevisionnumber(const char* value) {
  set_has_invoicerevisionnumber();
  if (invoicerevisionnumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    invoicerevisionnumber_ = new ::std::string;
  }
  invoicerevisionnumber_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.InvoiceInfo.InvoiceRevisionNumber)
}
inline void InvoiceInfo::set_invoicerevisionnumber(const char* value, size_t size) {
  set_has_invoicerevisionnumber();
  if (invoicerevisionnumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    invoicerevisionnumber_ = new ::std::string;
  }
  invoicerevisionnumber_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.InvoiceInfo.InvoiceRevisionNumber)
}
inline ::std::string* InvoiceInfo::mutable_invoicerevisionnumber() {
  set_has_invoicerevisionnumber();
  if (invoicerevisionnumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    invoicerevisionnumber_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.InvoiceInfo.InvoiceRevisionNumber)
  return invoicerevisionnumber_;
}
inline ::std::string* InvoiceInfo::release_invoicerevisionnumber() {
  clear_has_invoicerevisionnumber();
  if (invoicerevisionnumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = invoicerevisionnumber_;
    invoicerevisionnumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void InvoiceInfo::set_allocated_invoicerevisionnumber(::std::string* invoicerevisionnumber) {
  if (invoicerevisionnumber_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete invoicerevisionnumber_;
  }
  if (invoicerevisionnumber) {
    set_has_invoicerevisionnumber();
    invoicerevisionnumber_ = invoicerevisionnumber;
  } else {
    clear_has_invoicerevisionnumber();
    invoicerevisionnumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.InvoiceInfo.InvoiceRevisionNumber)
}

// repeated .Diadoc.Api.Proto.Invoicing.AdditionalInfo AdditionalInfos = 17;
inline int InvoiceInfo::additionalinfos_size() const {
  return additionalinfos_.size();
}
inline void InvoiceInfo::clear_additionalinfos() {
  additionalinfos_.Clear();
}
inline const ::Diadoc::Api::Proto::Invoicing::AdditionalInfo& InvoiceInfo::additionalinfos(int index) const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.InvoiceInfo.AdditionalInfos)
  return additionalinfos_.Get(index);
}
inline ::Diadoc::Api::Proto::Invoicing::AdditionalInfo* InvoiceInfo::mutable_additionalinfos(int index) {
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.InvoiceInfo.AdditionalInfos)
  return additionalinfos_.Mutable(index);
}
inline ::Diadoc::Api::Proto::Invoicing::AdditionalInfo* InvoiceInfo::add_additionalinfos() {
  // @@protoc_insertion_point(field_add:Diadoc.Api.Proto.Invoicing.InvoiceInfo.AdditionalInfos)
  return additionalinfos_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::AdditionalInfo >&
InvoiceInfo::additionalinfos() const {
  // @@protoc_insertion_point(field_list:Diadoc.Api.Proto.Invoicing.InvoiceInfo.AdditionalInfos)
  return additionalinfos_;
}
inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::AdditionalInfo >*
InvoiceInfo::mutable_additionalinfos() {
  // @@protoc_insertion_point(field_mutable_list:Diadoc.Api.Proto.Invoicing.InvoiceInfo.AdditionalInfos)
  return &additionalinfos_;
}

// optional .Diadoc.Api.Proto.Invoicing.InvoiceFormatVersion Version = 18 [default = DefaultInvoiceFormatVersion];
inline bool InvoiceInfo::has_version() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void InvoiceInfo::set_has_version() {
  _has_bits_[0] |= 0x00020000u;
}
inline void InvoiceInfo::clear_has_version() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void InvoiceInfo::clear_version() {
  version_ = 0;
  clear_has_version();
}
inline ::Diadoc::Api::Proto::Invoicing::InvoiceFormatVersion InvoiceInfo::version() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.InvoiceInfo.Version)
  return static_cast< ::Diadoc::Api::Proto::Invoicing::InvoiceFormatVersion >(version_);
}
inline void InvoiceInfo::set_version(::Diadoc::Api::Proto::Invoicing::InvoiceFormatVersion value) {
  assert(::Diadoc::Api::Proto::Invoicing::InvoiceFormatVersion_IsValid(value));
  set_has_version();
  version_ = value;
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.InvoiceInfo.Version)
}

// -------------------------------------------------------------------

// AdditionalInfo

// required string Id = 1;
inline bool AdditionalInfo::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AdditionalInfo::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AdditionalInfo::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AdditionalInfo::clear_id() {
  if (id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& AdditionalInfo::id() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.AdditionalInfo.Id)
  return *id_;
}
inline void AdditionalInfo::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  id_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.AdditionalInfo.Id)
}
inline void AdditionalInfo::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  id_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.AdditionalInfo.Id)
}
inline void AdditionalInfo::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.AdditionalInfo.Id)
}
inline ::std::string* AdditionalInfo::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.AdditionalInfo.Id)
  return id_;
}
inline ::std::string* AdditionalInfo::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AdditionalInfo::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.AdditionalInfo.Id)
}

// required string Value = 2;
inline bool AdditionalInfo::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AdditionalInfo::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AdditionalInfo::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AdditionalInfo::clear_value() {
  if (value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& AdditionalInfo::value() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.AdditionalInfo.Value)
  return *value_;
}
inline void AdditionalInfo::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.AdditionalInfo.Value)
}
inline void AdditionalInfo::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.AdditionalInfo.Value)
}
inline void AdditionalInfo::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.AdditionalInfo.Value)
}
inline ::std::string* AdditionalInfo::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.AdditionalInfo.Value)
  return value_;
}
inline ::std::string* AdditionalInfo::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AdditionalInfo::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.AdditionalInfo.Value)
}

// -------------------------------------------------------------------

// InvoiceItem

// required string Product = 1;
inline bool InvoiceItem::has_product() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InvoiceItem::set_has_product() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InvoiceItem::clear_has_product() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InvoiceItem::clear_product() {
  if (product_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    product_->clear();
  }
  clear_has_product();
}
inline const ::std::string& InvoiceItem::product() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.InvoiceItem.Product)
  return *product_;
}
inline void InvoiceItem::set_product(const ::std::string& value) {
  set_has_product();
  if (product_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    product_ = new ::std::string;
  }
  product_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.InvoiceItem.Product)
}
inline void InvoiceItem::set_product(const char* value) {
  set_has_product();
  if (product_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    product_ = new ::std::string;
  }
  product_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.InvoiceItem.Product)
}
inline void InvoiceItem::set_product(const char* value, size_t size) {
  set_has_product();
  if (product_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    product_ = new ::std::string;
  }
  product_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.InvoiceItem.Product)
}
inline ::std::string* InvoiceItem::mutable_product() {
  set_has_product();
  if (product_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    product_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.InvoiceItem.Product)
  return product_;
}
inline ::std::string* InvoiceItem::release_product() {
  clear_has_product();
  if (product_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = product_;
    product_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void InvoiceItem::set_allocated_product(::std::string* product) {
  if (product_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete product_;
  }
  if (product) {
    set_has_product();
    product_ = product;
  } else {
    clear_has_product();
    product_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.InvoiceItem.Product)
}

// optional string Unit = 2;
inline bool InvoiceItem::has_unit() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InvoiceItem::set_has_unit() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InvoiceItem::clear_has_unit() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InvoiceItem::clear_unit() {
  if (unit_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    unit_->clear();
  }
  clear_has_unit();
}
inline const ::std::string& InvoiceItem::unit() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.InvoiceItem.Unit)
  return *unit_;
}
inline void InvoiceItem::set_unit(const ::std::string& value) {
  set_has_unit();
  if (unit_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    unit_ = new ::std::string;
  }
  unit_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.InvoiceItem.Unit)
}
inline void InvoiceItem::set_unit(const char* value) {
  set_has_unit();
  if (unit_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    unit_ = new ::std::string;
  }
  unit_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.InvoiceItem.Unit)
}
inline void InvoiceItem::set_unit(const char* value, size_t size) {
  set_has_unit();
  if (unit_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    unit_ = new ::std::string;
  }
  unit_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.InvoiceItem.Unit)
}
inline ::std::string* InvoiceItem::mutable_unit() {
  set_has_unit();
  if (unit_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    unit_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.InvoiceItem.Unit)
  return unit_;
}
inline ::std::string* InvoiceItem::release_unit() {
  clear_has_unit();
  if (unit_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = unit_;
    unit_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void InvoiceItem::set_allocated_unit(::std::string* unit) {
  if (unit_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete unit_;
  }
  if (unit) {
    set_has_unit();
    unit_ = unit;
  } else {
    clear_has_unit();
    unit_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.InvoiceItem.Unit)
}

// optional string Quantity = 3;
inline bool InvoiceItem::has_quantity() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InvoiceItem::set_has_quantity() {
  _has_bits_[0] |= 0x00000004u;
}
inline void InvoiceItem::clear_has_quantity() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void InvoiceItem::clear_quantity() {
  if (quantity_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    quantity_->clear();
  }
  clear_has_quantity();
}
inline const ::std::string& InvoiceItem::quantity() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.InvoiceItem.Quantity)
  return *quantity_;
}
inline void InvoiceItem::set_quantity(const ::std::string& value) {
  set_has_quantity();
  if (quantity_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    quantity_ = new ::std::string;
  }
  quantity_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.InvoiceItem.Quantity)
}
inline void InvoiceItem::set_quantity(const char* value) {
  set_has_quantity();
  if (quantity_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    quantity_ = new ::std::string;
  }
  quantity_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.InvoiceItem.Quantity)
}
inline void InvoiceItem::set_quantity(const char* value, size_t size) {
  set_has_quantity();
  if (quantity_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    quantity_ = new ::std::string;
  }
  quantity_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.InvoiceItem.Quantity)
}
inline ::std::string* InvoiceItem::mutable_quantity() {
  set_has_quantity();
  if (quantity_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    quantity_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.InvoiceItem.Quantity)
  return quantity_;
}
inline ::std::string* InvoiceItem::release_quantity() {
  clear_has_quantity();
  if (quantity_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = quantity_;
    quantity_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void InvoiceItem::set_allocated_quantity(::std::string* quantity) {
  if (quantity_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete quantity_;
  }
  if (quantity) {
    set_has_quantity();
    quantity_ = quantity;
  } else {
    clear_has_quantity();
    quantity_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.InvoiceItem.Quantity)
}

// optional string Price = 4;
inline bool InvoiceItem::has_price() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void InvoiceItem::set_has_price() {
  _has_bits_[0] |= 0x00000008u;
}
inline void InvoiceItem::clear_has_price() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void InvoiceItem::clear_price() {
  if (price_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    price_->clear();
  }
  clear_has_price();
}
inline const ::std::string& InvoiceItem::price() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.InvoiceItem.Price)
  return *price_;
}
inline void InvoiceItem::set_price(const ::std::string& value) {
  set_has_price();
  if (price_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    price_ = new ::std::string;
  }
  price_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.InvoiceItem.Price)
}
inline void InvoiceItem::set_price(const char* value) {
  set_has_price();
  if (price_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    price_ = new ::std::string;
  }
  price_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.InvoiceItem.Price)
}
inline void InvoiceItem::set_price(const char* value, size_t size) {
  set_has_price();
  if (price_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    price_ = new ::std::string;
  }
  price_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.InvoiceItem.Price)
}
inline ::std::string* InvoiceItem::mutable_price() {
  set_has_price();
  if (price_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    price_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.InvoiceItem.Price)
  return price_;
}
inline ::std::string* InvoiceItem::release_price() {
  clear_has_price();
  if (price_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = price_;
    price_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void InvoiceItem::set_allocated_price(::std::string* price) {
  if (price_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete price_;
  }
  if (price) {
    set_has_price();
    price_ = price;
  } else {
    clear_has_price();
    price_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.InvoiceItem.Price)
}

// repeated string CountriesOfOrigin = 5;
inline int InvoiceItem::countriesoforigin_size() const {
  return countriesoforigin_.size();
}
inline void InvoiceItem::clear_countriesoforigin() {
  countriesoforigin_.Clear();
}
inline const ::std::string& InvoiceItem::countriesoforigin(int index) const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.InvoiceItem.CountriesOfOrigin)
  return countriesoforigin_.Get(index);
}
inline ::std::string* InvoiceItem::mutable_countriesoforigin(int index) {
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.InvoiceItem.CountriesOfOrigin)
  return countriesoforigin_.Mutable(index);
}
inline void InvoiceItem::set_countriesoforigin(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.InvoiceItem.CountriesOfOrigin)
  countriesoforigin_.Mutable(index)->assign(value);
}
inline void InvoiceItem::set_countriesoforigin(int index, const char* value) {
  countriesoforigin_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.InvoiceItem.CountriesOfOrigin)
}
inline void InvoiceItem::set_countriesoforigin(int index, const char* value, size_t size) {
  countriesoforigin_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.InvoiceItem.CountriesOfOrigin)
}
inline ::std::string* InvoiceItem::add_countriesoforigin() {
  return countriesoforigin_.Add();
}
inline void InvoiceItem::add_countriesoforigin(const ::std::string& value) {
  countriesoforigin_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:Diadoc.Api.Proto.Invoicing.InvoiceItem.CountriesOfOrigin)
}
inline void InvoiceItem::add_countriesoforigin(const char* value) {
  countriesoforigin_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:Diadoc.Api.Proto.Invoicing.InvoiceItem.CountriesOfOrigin)
}
inline void InvoiceItem::add_countriesoforigin(const char* value, size_t size) {
  countriesoforigin_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:Diadoc.Api.Proto.Invoicing.InvoiceItem.CountriesOfOrigin)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
InvoiceItem::countriesoforigin() const {
  // @@protoc_insertion_point(field_list:Diadoc.Api.Proto.Invoicing.InvoiceItem.CountriesOfOrigin)
  return countriesoforigin_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
InvoiceItem::mutable_countriesoforigin() {
  // @@protoc_insertion_point(field_mutable_list:Diadoc.Api.Proto.Invoicing.InvoiceItem.CountriesOfOrigin)
  return &countriesoforigin_;
}

// repeated string CustomsDeclarationNumbers = 6;
inline int InvoiceItem::customsdeclarationnumbers_size() const {
  return customsdeclarationnumbers_.size();
}
inline void InvoiceItem::clear_customsdeclarationnumbers() {
  customsdeclarationnumbers_.Clear();
}
inline const ::std::string& InvoiceItem::customsdeclarationnumbers(int index) const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.InvoiceItem.CustomsDeclarationNumbers)
  return customsdeclarationnumbers_.Get(index);
}
inline ::std::string* InvoiceItem::mutable_customsdeclarationnumbers(int index) {
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.InvoiceItem.CustomsDeclarationNumbers)
  return customsdeclarationnumbers_.Mutable(index);
}
inline void InvoiceItem::set_customsdeclarationnumbers(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.InvoiceItem.CustomsDeclarationNumbers)
  customsdeclarationnumbers_.Mutable(index)->assign(value);
}
inline void InvoiceItem::set_customsdeclarationnumbers(int index, const char* value) {
  customsdeclarationnumbers_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.InvoiceItem.CustomsDeclarationNumbers)
}
inline void InvoiceItem::set_customsdeclarationnumbers(int index, const char* value, size_t size) {
  customsdeclarationnumbers_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.InvoiceItem.CustomsDeclarationNumbers)
}
inline ::std::string* InvoiceItem::add_customsdeclarationnumbers() {
  return customsdeclarationnumbers_.Add();
}
inline void InvoiceItem::add_customsdeclarationnumbers(const ::std::string& value) {
  customsdeclarationnumbers_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:Diadoc.Api.Proto.Invoicing.InvoiceItem.CustomsDeclarationNumbers)
}
inline void InvoiceItem::add_customsdeclarationnumbers(const char* value) {
  customsdeclarationnumbers_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:Diadoc.Api.Proto.Invoicing.InvoiceItem.CustomsDeclarationNumbers)
}
inline void InvoiceItem::add_customsdeclarationnumbers(const char* value, size_t size) {
  customsdeclarationnumbers_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:Diadoc.Api.Proto.Invoicing.InvoiceItem.CustomsDeclarationNumbers)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
InvoiceItem::customsdeclarationnumbers() const {
  // @@protoc_insertion_point(field_list:Diadoc.Api.Proto.Invoicing.InvoiceItem.CustomsDeclarationNumbers)
  return customsdeclarationnumbers_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
InvoiceItem::mutable_customsdeclarationnumbers() {
  // @@protoc_insertion_point(field_mutable_list:Diadoc.Api.Proto.Invoicing.InvoiceItem.CustomsDeclarationNumbers)
  return &customsdeclarationnumbers_;
}

// optional string Excise = 7;
inline bool InvoiceItem::has_excise() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void InvoiceItem::set_has_excise() {
  _has_bits_[0] |= 0x00000040u;
}
inline void InvoiceItem::clear_has_excise() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void InvoiceItem::clear_excise() {
  if (excise_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    excise_->clear();
  }
  clear_has_excise();
}
inline const ::std::string& InvoiceItem::excise() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.InvoiceItem.Excise)
  return *excise_;
}
inline void InvoiceItem::set_excise(const ::std::string& value) {
  set_has_excise();
  if (excise_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    excise_ = new ::std::string;
  }
  excise_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.InvoiceItem.Excise)
}
inline void InvoiceItem::set_excise(const char* value) {
  set_has_excise();
  if (excise_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    excise_ = new ::std::string;
  }
  excise_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.InvoiceItem.Excise)
}
inline void InvoiceItem::set_excise(const char* value, size_t size) {
  set_has_excise();
  if (excise_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    excise_ = new ::std::string;
  }
  excise_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.InvoiceItem.Excise)
}
inline ::std::string* InvoiceItem::mutable_excise() {
  set_has_excise();
  if (excise_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    excise_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.InvoiceItem.Excise)
  return excise_;
}
inline ::std::string* InvoiceItem::release_excise() {
  clear_has_excise();
  if (excise_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = excise_;
    excise_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void InvoiceItem::set_allocated_excise(::std::string* excise) {
  if (excise_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete excise_;
  }
  if (excise) {
    set_has_excise();
    excise_ = excise;
  } else {
    clear_has_excise();
    excise_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.InvoiceItem.Excise)
}

// required .Diadoc.Api.Proto.Invoicing.TaxRate TaxRate = 8;
inline bool InvoiceItem::has_taxrate() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void InvoiceItem::set_has_taxrate() {
  _has_bits_[0] |= 0x00000080u;
}
inline void InvoiceItem::clear_has_taxrate() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void InvoiceItem::clear_taxrate() {
  taxrate_ = 0;
  clear_has_taxrate();
}
inline ::Diadoc::Api::Proto::Invoicing::TaxRate InvoiceItem::taxrate() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.InvoiceItem.TaxRate)
  return static_cast< ::Diadoc::Api::Proto::Invoicing::TaxRate >(taxrate_);
}
inline void InvoiceItem::set_taxrate(::Diadoc::Api::Proto::Invoicing::TaxRate value) {
  assert(::Diadoc::Api::Proto::Invoicing::TaxRate_IsValid(value));
  set_has_taxrate();
  taxrate_ = value;
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.InvoiceItem.TaxRate)
}

// optional string SubtotalWithVatExcluded = 9;
inline bool InvoiceItem::has_subtotalwithvatexcluded() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void InvoiceItem::set_has_subtotalwithvatexcluded() {
  _has_bits_[0] |= 0x00000100u;
}
inline void InvoiceItem::clear_has_subtotalwithvatexcluded() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void InvoiceItem::clear_subtotalwithvatexcluded() {
  if (subtotalwithvatexcluded_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    subtotalwithvatexcluded_->clear();
  }
  clear_has_subtotalwithvatexcluded();
}
inline const ::std::string& InvoiceItem::subtotalwithvatexcluded() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.InvoiceItem.SubtotalWithVatExcluded)
  return *subtotalwithvatexcluded_;
}
inline void InvoiceItem::set_subtotalwithvatexcluded(const ::std::string& value) {
  set_has_subtotalwithvatexcluded();
  if (subtotalwithvatexcluded_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    subtotalwithvatexcluded_ = new ::std::string;
  }
  subtotalwithvatexcluded_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.InvoiceItem.SubtotalWithVatExcluded)
}
inline void InvoiceItem::set_subtotalwithvatexcluded(const char* value) {
  set_has_subtotalwithvatexcluded();
  if (subtotalwithvatexcluded_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    subtotalwithvatexcluded_ = new ::std::string;
  }
  subtotalwithvatexcluded_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.InvoiceItem.SubtotalWithVatExcluded)
}
inline void InvoiceItem::set_subtotalwithvatexcluded(const char* value, size_t size) {
  set_has_subtotalwithvatexcluded();
  if (subtotalwithvatexcluded_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    subtotalwithvatexcluded_ = new ::std::string;
  }
  subtotalwithvatexcluded_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.InvoiceItem.SubtotalWithVatExcluded)
}
inline ::std::string* InvoiceItem::mutable_subtotalwithvatexcluded() {
  set_has_subtotalwithvatexcluded();
  if (subtotalwithvatexcluded_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    subtotalwithvatexcluded_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.InvoiceItem.SubtotalWithVatExcluded)
  return subtotalwithvatexcluded_;
}
inline ::std::string* InvoiceItem::release_subtotalwithvatexcluded() {
  clear_has_subtotalwithvatexcluded();
  if (subtotalwithvatexcluded_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = subtotalwithvatexcluded_;
    subtotalwithvatexcluded_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void InvoiceItem::set_allocated_subtotalwithvatexcluded(::std::string* subtotalwithvatexcluded) {
  if (subtotalwithvatexcluded_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete subtotalwithvatexcluded_;
  }
  if (subtotalwithvatexcluded) {
    set_has_subtotalwithvatexcluded();
    subtotalwithvatexcluded_ = subtotalwithvatexcluded;
  } else {
    clear_has_subtotalwithvatexcluded();
    subtotalwithvatexcluded_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.InvoiceItem.SubtotalWithVatExcluded)
}

// optional string Vat = 10;
inline bool InvoiceItem::has_vat() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void InvoiceItem::set_has_vat() {
  _has_bits_[0] |= 0x00000200u;
}
inline void InvoiceItem::clear_has_vat() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void InvoiceItem::clear_vat() {
  if (vat_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vat_->clear();
  }
  clear_has_vat();
}
inline const ::std::string& InvoiceItem::vat() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.InvoiceItem.Vat)
  return *vat_;
}
inline void InvoiceItem::set_vat(const ::std::string& value) {
  set_has_vat();
  if (vat_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vat_ = new ::std::string;
  }
  vat_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.InvoiceItem.Vat)
}
inline void InvoiceItem::set_vat(const char* value) {
  set_has_vat();
  if (vat_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vat_ = new ::std::string;
  }
  vat_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.InvoiceItem.Vat)
}
inline void InvoiceItem::set_vat(const char* value, size_t size) {
  set_has_vat();
  if (vat_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vat_ = new ::std::string;
  }
  vat_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.InvoiceItem.Vat)
}
inline ::std::string* InvoiceItem::mutable_vat() {
  set_has_vat();
  if (vat_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vat_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.InvoiceItem.Vat)
  return vat_;
}
inline ::std::string* InvoiceItem::release_vat() {
  clear_has_vat();
  if (vat_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = vat_;
    vat_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void InvoiceItem::set_allocated_vat(::std::string* vat) {
  if (vat_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete vat_;
  }
  if (vat) {
    set_has_vat();
    vat_ = vat;
  } else {
    clear_has_vat();
    vat_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.InvoiceItem.Vat)
}

// required string Subtotal = 11;
inline bool InvoiceItem::has_subtotal() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void InvoiceItem::set_has_subtotal() {
  _has_bits_[0] |= 0x00000400u;
}
inline void InvoiceItem::clear_has_subtotal() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void InvoiceItem::clear_subtotal() {
  if (subtotal_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    subtotal_->clear();
  }
  clear_has_subtotal();
}
inline const ::std::string& InvoiceItem::subtotal() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.InvoiceItem.Subtotal)
  return *subtotal_;
}
inline void InvoiceItem::set_subtotal(const ::std::string& value) {
  set_has_subtotal();
  if (subtotal_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    subtotal_ = new ::std::string;
  }
  subtotal_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.InvoiceItem.Subtotal)
}
inline void InvoiceItem::set_subtotal(const char* value) {
  set_has_subtotal();
  if (subtotal_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    subtotal_ = new ::std::string;
  }
  subtotal_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.InvoiceItem.Subtotal)
}
inline void InvoiceItem::set_subtotal(const char* value, size_t size) {
  set_has_subtotal();
  if (subtotal_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    subtotal_ = new ::std::string;
  }
  subtotal_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.InvoiceItem.Subtotal)
}
inline ::std::string* InvoiceItem::mutable_subtotal() {
  set_has_subtotal();
  if (subtotal_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    subtotal_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.InvoiceItem.Subtotal)
  return subtotal_;
}
inline ::std::string* InvoiceItem::release_subtotal() {
  clear_has_subtotal();
  if (subtotal_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = subtotal_;
    subtotal_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void InvoiceItem::set_allocated_subtotal(::std::string* subtotal) {
  if (subtotal_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete subtotal_;
  }
  if (subtotal) {
    set_has_subtotal();
    subtotal_ = subtotal;
  } else {
    clear_has_subtotal();
    subtotal_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.InvoiceItem.Subtotal)
}

// optional string AdditionalInfo = 12;
inline bool InvoiceItem::has_additionalinfo() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void InvoiceItem::set_has_additionalinfo() {
  _has_bits_[0] |= 0x00000800u;
}
inline void InvoiceItem::clear_has_additionalinfo() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void InvoiceItem::clear_additionalinfo() {
  if (additionalinfo_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    additionalinfo_->clear();
  }
  clear_has_additionalinfo();
}
inline const ::std::string& InvoiceItem::additionalinfo() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.InvoiceItem.AdditionalInfo)
  return *additionalinfo_;
}
inline void InvoiceItem::set_additionalinfo(const ::std::string& value) {
  set_has_additionalinfo();
  if (additionalinfo_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    additionalinfo_ = new ::std::string;
  }
  additionalinfo_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.InvoiceItem.AdditionalInfo)
}
inline void InvoiceItem::set_additionalinfo(const char* value) {
  set_has_additionalinfo();
  if (additionalinfo_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    additionalinfo_ = new ::std::string;
  }
  additionalinfo_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.InvoiceItem.AdditionalInfo)
}
inline void InvoiceItem::set_additionalinfo(const char* value, size_t size) {
  set_has_additionalinfo();
  if (additionalinfo_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    additionalinfo_ = new ::std::string;
  }
  additionalinfo_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.InvoiceItem.AdditionalInfo)
}
inline ::std::string* InvoiceItem::mutable_additionalinfo() {
  set_has_additionalinfo();
  if (additionalinfo_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    additionalinfo_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.InvoiceItem.AdditionalInfo)
  return additionalinfo_;
}
inline ::std::string* InvoiceItem::release_additionalinfo() {
  clear_has_additionalinfo();
  if (additionalinfo_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = additionalinfo_;
    additionalinfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void InvoiceItem::set_allocated_additionalinfo(::std::string* additionalinfo) {
  if (additionalinfo_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete additionalinfo_;
  }
  if (additionalinfo) {
    set_has_additionalinfo();
    additionalinfo_ = additionalinfo;
  } else {
    clear_has_additionalinfo();
    additionalinfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.InvoiceItem.AdditionalInfo)
}

// repeated .Diadoc.Api.Proto.Invoicing.CustomsDeclaration CustomsDeclarations = 13;
inline int InvoiceItem::customsdeclarations_size() const {
  return customsdeclarations_.size();
}
inline void InvoiceItem::clear_customsdeclarations() {
  customsdeclarations_.Clear();
}
inline const ::Diadoc::Api::Proto::Invoicing::CustomsDeclaration& InvoiceItem::customsdeclarations(int index) const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.InvoiceItem.CustomsDeclarations)
  return customsdeclarations_.Get(index);
}
inline ::Diadoc::Api::Proto::Invoicing::CustomsDeclaration* InvoiceItem::mutable_customsdeclarations(int index) {
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.InvoiceItem.CustomsDeclarations)
  return customsdeclarations_.Mutable(index);
}
inline ::Diadoc::Api::Proto::Invoicing::CustomsDeclaration* InvoiceItem::add_customsdeclarations() {
  // @@protoc_insertion_point(field_add:Diadoc.Api.Proto.Invoicing.InvoiceItem.CustomsDeclarations)
  return customsdeclarations_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::CustomsDeclaration >&
InvoiceItem::customsdeclarations() const {
  // @@protoc_insertion_point(field_list:Diadoc.Api.Proto.Invoicing.InvoiceItem.CustomsDeclarations)
  return customsdeclarations_;
}
inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::CustomsDeclaration >*
InvoiceItem::mutable_customsdeclarations() {
  // @@protoc_insertion_point(field_mutable_list:Diadoc.Api.Proto.Invoicing.InvoiceItem.CustomsDeclarations)
  return &customsdeclarations_;
}

// repeated .Diadoc.Api.Proto.Invoicing.AdditionalInfo AdditionalInfos = 14;
inline int InvoiceItem::additionalinfos_size() const {
  return additionalinfos_.size();
}
inline void InvoiceItem::clear_additionalinfos() {
  additionalinfos_.Clear();
}
inline const ::Diadoc::Api::Proto::Invoicing::AdditionalInfo& InvoiceItem::additionalinfos(int index) const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.InvoiceItem.AdditionalInfos)
  return additionalinfos_.Get(index);
}
inline ::Diadoc::Api::Proto::Invoicing::AdditionalInfo* InvoiceItem::mutable_additionalinfos(int index) {
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.InvoiceItem.AdditionalInfos)
  return additionalinfos_.Mutable(index);
}
inline ::Diadoc::Api::Proto::Invoicing::AdditionalInfo* InvoiceItem::add_additionalinfos() {
  // @@protoc_insertion_point(field_add:Diadoc.Api.Proto.Invoicing.InvoiceItem.AdditionalInfos)
  return additionalinfos_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::AdditionalInfo >&
InvoiceItem::additionalinfos() const {
  // @@protoc_insertion_point(field_list:Diadoc.Api.Proto.Invoicing.InvoiceItem.AdditionalInfos)
  return additionalinfos_;
}
inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::AdditionalInfo >*
InvoiceItem::mutable_additionalinfos() {
  // @@protoc_insertion_point(field_mutable_list:Diadoc.Api.Proto.Invoicing.InvoiceItem.AdditionalInfos)
  return &additionalinfos_;
}

// -------------------------------------------------------------------

// CustomsDeclaration

// required string CountryCode = 1;
inline bool CustomsDeclaration::has_countrycode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CustomsDeclaration::set_has_countrycode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CustomsDeclaration::clear_has_countrycode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CustomsDeclaration::clear_countrycode() {
  if (countrycode_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    countrycode_->clear();
  }
  clear_has_countrycode();
}
inline const ::std::string& CustomsDeclaration::countrycode() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.CustomsDeclaration.CountryCode)
  return *countrycode_;
}
inline void CustomsDeclaration::set_countrycode(const ::std::string& value) {
  set_has_countrycode();
  if (countrycode_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    countrycode_ = new ::std::string;
  }
  countrycode_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.CustomsDeclaration.CountryCode)
}
inline void CustomsDeclaration::set_countrycode(const char* value) {
  set_has_countrycode();
  if (countrycode_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    countrycode_ = new ::std::string;
  }
  countrycode_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.CustomsDeclaration.CountryCode)
}
inline void CustomsDeclaration::set_countrycode(const char* value, size_t size) {
  set_has_countrycode();
  if (countrycode_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    countrycode_ = new ::std::string;
  }
  countrycode_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.CustomsDeclaration.CountryCode)
}
inline ::std::string* CustomsDeclaration::mutable_countrycode() {
  set_has_countrycode();
  if (countrycode_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    countrycode_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.CustomsDeclaration.CountryCode)
  return countrycode_;
}
inline ::std::string* CustomsDeclaration::release_countrycode() {
  clear_has_countrycode();
  if (countrycode_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = countrycode_;
    countrycode_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CustomsDeclaration::set_allocated_countrycode(::std::string* countrycode) {
  if (countrycode_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete countrycode_;
  }
  if (countrycode) {
    set_has_countrycode();
    countrycode_ = countrycode;
  } else {
    clear_has_countrycode();
    countrycode_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.CustomsDeclaration.CountryCode)
}

// required string DeclarationNumber = 2;
inline bool CustomsDeclaration::has_declarationnumber() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CustomsDeclaration::set_has_declarationnumber() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CustomsDeclaration::clear_has_declarationnumber() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CustomsDeclaration::clear_declarationnumber() {
  if (declarationnumber_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    declarationnumber_->clear();
  }
  clear_has_declarationnumber();
}
inline const ::std::string& CustomsDeclaration::declarationnumber() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.CustomsDeclaration.DeclarationNumber)
  return *declarationnumber_;
}
inline void CustomsDeclaration::set_declarationnumber(const ::std::string& value) {
  set_has_declarationnumber();
  if (declarationnumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    declarationnumber_ = new ::std::string;
  }
  declarationnumber_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.CustomsDeclaration.DeclarationNumber)
}
inline void CustomsDeclaration::set_declarationnumber(const char* value) {
  set_has_declarationnumber();
  if (declarationnumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    declarationnumber_ = new ::std::string;
  }
  declarationnumber_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.CustomsDeclaration.DeclarationNumber)
}
inline void CustomsDeclaration::set_declarationnumber(const char* value, size_t size) {
  set_has_declarationnumber();
  if (declarationnumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    declarationnumber_ = new ::std::string;
  }
  declarationnumber_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.CustomsDeclaration.DeclarationNumber)
}
inline ::std::string* CustomsDeclaration::mutable_declarationnumber() {
  set_has_declarationnumber();
  if (declarationnumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    declarationnumber_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.CustomsDeclaration.DeclarationNumber)
  return declarationnumber_;
}
inline ::std::string* CustomsDeclaration::release_declarationnumber() {
  clear_has_declarationnumber();
  if (declarationnumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = declarationnumber_;
    declarationnumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CustomsDeclaration::set_allocated_declarationnumber(::std::string* declarationnumber) {
  if (declarationnumber_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete declarationnumber_;
  }
  if (declarationnumber) {
    set_has_declarationnumber();
    declarationnumber_ = declarationnumber;
  } else {
    clear_has_declarationnumber();
    declarationnumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.CustomsDeclaration.DeclarationNumber)
}

// -------------------------------------------------------------------

// PaymentDocumentInfo

// required string DocumentDate = 1;
inline bool PaymentDocumentInfo::has_documentdate() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PaymentDocumentInfo::set_has_documentdate() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PaymentDocumentInfo::clear_has_documentdate() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PaymentDocumentInfo::clear_documentdate() {
  if (documentdate_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    documentdate_->clear();
  }
  clear_has_documentdate();
}
inline const ::std::string& PaymentDocumentInfo::documentdate() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.PaymentDocumentInfo.DocumentDate)
  return *documentdate_;
}
inline void PaymentDocumentInfo::set_documentdate(const ::std::string& value) {
  set_has_documentdate();
  if (documentdate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    documentdate_ = new ::std::string;
  }
  documentdate_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.PaymentDocumentInfo.DocumentDate)
}
inline void PaymentDocumentInfo::set_documentdate(const char* value) {
  set_has_documentdate();
  if (documentdate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    documentdate_ = new ::std::string;
  }
  documentdate_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.PaymentDocumentInfo.DocumentDate)
}
inline void PaymentDocumentInfo::set_documentdate(const char* value, size_t size) {
  set_has_documentdate();
  if (documentdate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    documentdate_ = new ::std::string;
  }
  documentdate_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.PaymentDocumentInfo.DocumentDate)
}
inline ::std::string* PaymentDocumentInfo::mutable_documentdate() {
  set_has_documentdate();
  if (documentdate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    documentdate_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.PaymentDocumentInfo.DocumentDate)
  return documentdate_;
}
inline ::std::string* PaymentDocumentInfo::release_documentdate() {
  clear_has_documentdate();
  if (documentdate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = documentdate_;
    documentdate_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PaymentDocumentInfo::set_allocated_documentdate(::std::string* documentdate) {
  if (documentdate_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete documentdate_;
  }
  if (documentdate) {
    set_has_documentdate();
    documentdate_ = documentdate;
  } else {
    clear_has_documentdate();
    documentdate_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.PaymentDocumentInfo.DocumentDate)
}

// required string DocumentNumber = 2;
inline bool PaymentDocumentInfo::has_documentnumber() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PaymentDocumentInfo::set_has_documentnumber() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PaymentDocumentInfo::clear_has_documentnumber() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PaymentDocumentInfo::clear_documentnumber() {
  if (documentnumber_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    documentnumber_->clear();
  }
  clear_has_documentnumber();
}
inline const ::std::string& PaymentDocumentInfo::documentnumber() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.PaymentDocumentInfo.DocumentNumber)
  return *documentnumber_;
}
inline void PaymentDocumentInfo::set_documentnumber(const ::std::string& value) {
  set_has_documentnumber();
  if (documentnumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    documentnumber_ = new ::std::string;
  }
  documentnumber_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.PaymentDocumentInfo.DocumentNumber)
}
inline void PaymentDocumentInfo::set_documentnumber(const char* value) {
  set_has_documentnumber();
  if (documentnumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    documentnumber_ = new ::std::string;
  }
  documentnumber_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.PaymentDocumentInfo.DocumentNumber)
}
inline void PaymentDocumentInfo::set_documentnumber(const char* value, size_t size) {
  set_has_documentnumber();
  if (documentnumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    documentnumber_ = new ::std::string;
  }
  documentnumber_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.PaymentDocumentInfo.DocumentNumber)
}
inline ::std::string* PaymentDocumentInfo::mutable_documentnumber() {
  set_has_documentnumber();
  if (documentnumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    documentnumber_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.PaymentDocumentInfo.DocumentNumber)
  return documentnumber_;
}
inline ::std::string* PaymentDocumentInfo::release_documentnumber() {
  clear_has_documentnumber();
  if (documentnumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = documentnumber_;
    documentnumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PaymentDocumentInfo::set_allocated_documentnumber(::std::string* documentnumber) {
  if (documentnumber_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete documentnumber_;
  }
  if (documentnumber) {
    set_has_documentnumber();
    documentnumber_ = documentnumber;
  } else {
    clear_has_documentnumber();
    documentnumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.PaymentDocumentInfo.DocumentNumber)
}

// -------------------------------------------------------------------

// ShipperOrConsignee

// optional bool SameAsSellerOrBuyer = 1;
inline bool ShipperOrConsignee::has_sameassellerorbuyer() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ShipperOrConsignee::set_has_sameassellerorbuyer() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ShipperOrConsignee::clear_has_sameassellerorbuyer() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ShipperOrConsignee::clear_sameassellerorbuyer() {
  sameassellerorbuyer_ = false;
  clear_has_sameassellerorbuyer();
}
inline bool ShipperOrConsignee::sameassellerorbuyer() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.ShipperOrConsignee.SameAsSellerOrBuyer)
  return sameassellerorbuyer_;
}
inline void ShipperOrConsignee::set_sameassellerorbuyer(bool value) {
  set_has_sameassellerorbuyer();
  sameassellerorbuyer_ = value;
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.ShipperOrConsignee.SameAsSellerOrBuyer)
}

// optional .Diadoc.Api.Proto.Invoicing.OrganizationInfo OrgInfo = 2;
inline bool ShipperOrConsignee::has_orginfo() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ShipperOrConsignee::set_has_orginfo() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ShipperOrConsignee::clear_has_orginfo() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ShipperOrConsignee::clear_orginfo() {
  if (orginfo_ != NULL) orginfo_->::Diadoc::Api::Proto::Invoicing::OrganizationInfo::Clear();
  clear_has_orginfo();
}
inline const ::Diadoc::Api::Proto::Invoicing::OrganizationInfo& ShipperOrConsignee::orginfo() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.ShipperOrConsignee.OrgInfo)
  return orginfo_ != NULL ? *orginfo_ : *default_instance_->orginfo_;
}
inline ::Diadoc::Api::Proto::Invoicing::OrganizationInfo* ShipperOrConsignee::mutable_orginfo() {
  set_has_orginfo();
  if (orginfo_ == NULL) orginfo_ = new ::Diadoc::Api::Proto::Invoicing::OrganizationInfo;
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.ShipperOrConsignee.OrgInfo)
  return orginfo_;
}
inline ::Diadoc::Api::Proto::Invoicing::OrganizationInfo* ShipperOrConsignee::release_orginfo() {
  clear_has_orginfo();
  ::Diadoc::Api::Proto::Invoicing::OrganizationInfo* temp = orginfo_;
  orginfo_ = NULL;
  return temp;
}
inline void ShipperOrConsignee::set_allocated_orginfo(::Diadoc::Api::Proto::Invoicing::OrganizationInfo* orginfo) {
  delete orginfo_;
  orginfo_ = orginfo;
  if (orginfo) {
    set_has_orginfo();
  } else {
    clear_has_orginfo();
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.ShipperOrConsignee.OrgInfo)
}

// -------------------------------------------------------------------

// InvoiceCorrectionInfo

// required string InvoiceDate = 1;
inline bool InvoiceCorrectionInfo::has_invoicedate() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InvoiceCorrectionInfo::set_has_invoicedate() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InvoiceCorrectionInfo::clear_has_invoicedate() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InvoiceCorrectionInfo::clear_invoicedate() {
  if (invoicedate_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    invoicedate_->clear();
  }
  clear_has_invoicedate();
}
inline const ::std::string& InvoiceCorrectionInfo::invoicedate() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.InvoiceCorrectionInfo.InvoiceDate)
  return *invoicedate_;
}
inline void InvoiceCorrectionInfo::set_invoicedate(const ::std::string& value) {
  set_has_invoicedate();
  if (invoicedate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    invoicedate_ = new ::std::string;
  }
  invoicedate_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.InvoiceCorrectionInfo.InvoiceDate)
}
inline void InvoiceCorrectionInfo::set_invoicedate(const char* value) {
  set_has_invoicedate();
  if (invoicedate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    invoicedate_ = new ::std::string;
  }
  invoicedate_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.InvoiceCorrectionInfo.InvoiceDate)
}
inline void InvoiceCorrectionInfo::set_invoicedate(const char* value, size_t size) {
  set_has_invoicedate();
  if (invoicedate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    invoicedate_ = new ::std::string;
  }
  invoicedate_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.InvoiceCorrectionInfo.InvoiceDate)
}
inline ::std::string* InvoiceCorrectionInfo::mutable_invoicedate() {
  set_has_invoicedate();
  if (invoicedate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    invoicedate_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.InvoiceCorrectionInfo.InvoiceDate)
  return invoicedate_;
}
inline ::std::string* InvoiceCorrectionInfo::release_invoicedate() {
  clear_has_invoicedate();
  if (invoicedate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = invoicedate_;
    invoicedate_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void InvoiceCorrectionInfo::set_allocated_invoicedate(::std::string* invoicedate) {
  if (invoicedate_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete invoicedate_;
  }
  if (invoicedate) {
    set_has_invoicedate();
    invoicedate_ = invoicedate;
  } else {
    clear_has_invoicedate();
    invoicedate_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.InvoiceCorrectionInfo.InvoiceDate)
}

// required string InvoiceNumber = 2;
inline bool InvoiceCorrectionInfo::has_invoicenumber() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InvoiceCorrectionInfo::set_has_invoicenumber() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InvoiceCorrectionInfo::clear_has_invoicenumber() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InvoiceCorrectionInfo::clear_invoicenumber() {
  if (invoicenumber_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    invoicenumber_->clear();
  }
  clear_has_invoicenumber();
}
inline const ::std::string& InvoiceCorrectionInfo::invoicenumber() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.InvoiceCorrectionInfo.InvoiceNumber)
  return *invoicenumber_;
}
inline void InvoiceCorrectionInfo::set_invoicenumber(const ::std::string& value) {
  set_has_invoicenumber();
  if (invoicenumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    invoicenumber_ = new ::std::string;
  }
  invoicenumber_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.InvoiceCorrectionInfo.InvoiceNumber)
}
inline void InvoiceCorrectionInfo::set_invoicenumber(const char* value) {
  set_has_invoicenumber();
  if (invoicenumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    invoicenumber_ = new ::std::string;
  }
  invoicenumber_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.InvoiceCorrectionInfo.InvoiceNumber)
}
inline void InvoiceCorrectionInfo::set_invoicenumber(const char* value, size_t size) {
  set_has_invoicenumber();
  if (invoicenumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    invoicenumber_ = new ::std::string;
  }
  invoicenumber_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.InvoiceCorrectionInfo.InvoiceNumber)
}
inline ::std::string* InvoiceCorrectionInfo::mutable_invoicenumber() {
  set_has_invoicenumber();
  if (invoicenumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    invoicenumber_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.InvoiceCorrectionInfo.InvoiceNumber)
  return invoicenumber_;
}
inline ::std::string* InvoiceCorrectionInfo::release_invoicenumber() {
  clear_has_invoicenumber();
  if (invoicenumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = invoicenumber_;
    invoicenumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void InvoiceCorrectionInfo::set_allocated_invoicenumber(::std::string* invoicenumber) {
  if (invoicenumber_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete invoicenumber_;
  }
  if (invoicenumber) {
    set_has_invoicenumber();
    invoicenumber_ = invoicenumber;
  } else {
    clear_has_invoicenumber();
    invoicenumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.InvoiceCorrectionInfo.InvoiceNumber)
}

// optional string InvoiceRevisionDate = 3;
inline bool InvoiceCorrectionInfo::has_invoicerevisiondate() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InvoiceCorrectionInfo::set_has_invoicerevisiondate() {
  _has_bits_[0] |= 0x00000004u;
}
inline void InvoiceCorrectionInfo::clear_has_invoicerevisiondate() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void InvoiceCorrectionInfo::clear_invoicerevisiondate() {
  if (invoicerevisiondate_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    invoicerevisiondate_->clear();
  }
  clear_has_invoicerevisiondate();
}
inline const ::std::string& InvoiceCorrectionInfo::invoicerevisiondate() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.InvoiceCorrectionInfo.InvoiceRevisionDate)
  return *invoicerevisiondate_;
}
inline void InvoiceCorrectionInfo::set_invoicerevisiondate(const ::std::string& value) {
  set_has_invoicerevisiondate();
  if (invoicerevisiondate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    invoicerevisiondate_ = new ::std::string;
  }
  invoicerevisiondate_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.InvoiceCorrectionInfo.InvoiceRevisionDate)
}
inline void InvoiceCorrectionInfo::set_invoicerevisiondate(const char* value) {
  set_has_invoicerevisiondate();
  if (invoicerevisiondate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    invoicerevisiondate_ = new ::std::string;
  }
  invoicerevisiondate_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.InvoiceCorrectionInfo.InvoiceRevisionDate)
}
inline void InvoiceCorrectionInfo::set_invoicerevisiondate(const char* value, size_t size) {
  set_has_invoicerevisiondate();
  if (invoicerevisiondate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    invoicerevisiondate_ = new ::std::string;
  }
  invoicerevisiondate_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.InvoiceCorrectionInfo.InvoiceRevisionDate)
}
inline ::std::string* InvoiceCorrectionInfo::mutable_invoicerevisiondate() {
  set_has_invoicerevisiondate();
  if (invoicerevisiondate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    invoicerevisiondate_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.InvoiceCorrectionInfo.InvoiceRevisionDate)
  return invoicerevisiondate_;
}
inline ::std::string* InvoiceCorrectionInfo::release_invoicerevisiondate() {
  clear_has_invoicerevisiondate();
  if (invoicerevisiondate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = invoicerevisiondate_;
    invoicerevisiondate_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void InvoiceCorrectionInfo::set_allocated_invoicerevisiondate(::std::string* invoicerevisiondate) {
  if (invoicerevisiondate_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete invoicerevisiondate_;
  }
  if (invoicerevisiondate) {
    set_has_invoicerevisiondate();
    invoicerevisiondate_ = invoicerevisiondate;
  } else {
    clear_has_invoicerevisiondate();
    invoicerevisiondate_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.InvoiceCorrectionInfo.InvoiceRevisionDate)
}

// optional string InvoiceRevisionNumber = 4;
inline bool InvoiceCorrectionInfo::has_invoicerevisionnumber() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void InvoiceCorrectionInfo::set_has_invoicerevisionnumber() {
  _has_bits_[0] |= 0x00000008u;
}
inline void InvoiceCorrectionInfo::clear_has_invoicerevisionnumber() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void InvoiceCorrectionInfo::clear_invoicerevisionnumber() {
  if (invoicerevisionnumber_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    invoicerevisionnumber_->clear();
  }
  clear_has_invoicerevisionnumber();
}
inline const ::std::string& InvoiceCorrectionInfo::invoicerevisionnumber() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.InvoiceCorrectionInfo.InvoiceRevisionNumber)
  return *invoicerevisionnumber_;
}
inline void InvoiceCorrectionInfo::set_invoicerevisionnumber(const ::std::string& value) {
  set_has_invoicerevisionnumber();
  if (invoicerevisionnumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    invoicerevisionnumber_ = new ::std::string;
  }
  invoicerevisionnumber_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.InvoiceCorrectionInfo.InvoiceRevisionNumber)
}
inline void InvoiceCorrectionInfo::set_invoicerevisionnumber(const char* value) {
  set_has_invoicerevisionnumber();
  if (invoicerevisionnumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    invoicerevisionnumber_ = new ::std::string;
  }
  invoicerevisionnumber_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.InvoiceCorrectionInfo.InvoiceRevisionNumber)
}
inline void InvoiceCorrectionInfo::set_invoicerevisionnumber(const char* value, size_t size) {
  set_has_invoicerevisionnumber();
  if (invoicerevisionnumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    invoicerevisionnumber_ = new ::std::string;
  }
  invoicerevisionnumber_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.InvoiceCorrectionInfo.InvoiceRevisionNumber)
}
inline ::std::string* InvoiceCorrectionInfo::mutable_invoicerevisionnumber() {
  set_has_invoicerevisionnumber();
  if (invoicerevisionnumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    invoicerevisionnumber_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.InvoiceCorrectionInfo.InvoiceRevisionNumber)
  return invoicerevisionnumber_;
}
inline ::std::string* InvoiceCorrectionInfo::release_invoicerevisionnumber() {
  clear_has_invoicerevisionnumber();
  if (invoicerevisionnumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = invoicerevisionnumber_;
    invoicerevisionnumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void InvoiceCorrectionInfo::set_allocated_invoicerevisionnumber(::std::string* invoicerevisionnumber) {
  if (invoicerevisionnumber_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete invoicerevisionnumber_;
  }
  if (invoicerevisionnumber) {
    set_has_invoicerevisionnumber();
    invoicerevisionnumber_ = invoicerevisionnumber;
  } else {
    clear_has_invoicerevisionnumber();
    invoicerevisionnumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.InvoiceCorrectionInfo.InvoiceRevisionNumber)
}

// required string InvoiceCorrectionDate = 5;
inline bool InvoiceCorrectionInfo::has_invoicecorrectiondate() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void InvoiceCorrectionInfo::set_has_invoicecorrectiondate() {
  _has_bits_[0] |= 0x00000010u;
}
inline void InvoiceCorrectionInfo::clear_has_invoicecorrectiondate() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void InvoiceCorrectionInfo::clear_invoicecorrectiondate() {
  if (invoicecorrectiondate_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    invoicecorrectiondate_->clear();
  }
  clear_has_invoicecorrectiondate();
}
inline const ::std::string& InvoiceCorrectionInfo::invoicecorrectiondate() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.InvoiceCorrectionInfo.InvoiceCorrectionDate)
  return *invoicecorrectiondate_;
}
inline void InvoiceCorrectionInfo::set_invoicecorrectiondate(const ::std::string& value) {
  set_has_invoicecorrectiondate();
  if (invoicecorrectiondate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    invoicecorrectiondate_ = new ::std::string;
  }
  invoicecorrectiondate_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.InvoiceCorrectionInfo.InvoiceCorrectionDate)
}
inline void InvoiceCorrectionInfo::set_invoicecorrectiondate(const char* value) {
  set_has_invoicecorrectiondate();
  if (invoicecorrectiondate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    invoicecorrectiondate_ = new ::std::string;
  }
  invoicecorrectiondate_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.InvoiceCorrectionInfo.InvoiceCorrectionDate)
}
inline void InvoiceCorrectionInfo::set_invoicecorrectiondate(const char* value, size_t size) {
  set_has_invoicecorrectiondate();
  if (invoicecorrectiondate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    invoicecorrectiondate_ = new ::std::string;
  }
  invoicecorrectiondate_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.InvoiceCorrectionInfo.InvoiceCorrectionDate)
}
inline ::std::string* InvoiceCorrectionInfo::mutable_invoicecorrectiondate() {
  set_has_invoicecorrectiondate();
  if (invoicecorrectiondate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    invoicecorrectiondate_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.InvoiceCorrectionInfo.InvoiceCorrectionDate)
  return invoicecorrectiondate_;
}
inline ::std::string* InvoiceCorrectionInfo::release_invoicecorrectiondate() {
  clear_has_invoicecorrectiondate();
  if (invoicecorrectiondate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = invoicecorrectiondate_;
    invoicecorrectiondate_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void InvoiceCorrectionInfo::set_allocated_invoicecorrectiondate(::std::string* invoicecorrectiondate) {
  if (invoicecorrectiondate_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete invoicecorrectiondate_;
  }
  if (invoicecorrectiondate) {
    set_has_invoicecorrectiondate();
    invoicecorrectiondate_ = invoicecorrectiondate;
  } else {
    clear_has_invoicecorrectiondate();
    invoicecorrectiondate_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.InvoiceCorrectionInfo.InvoiceCorrectionDate)
}

// required string InvoiceCorrectionNumber = 6;
inline bool InvoiceCorrectionInfo::has_invoicecorrectionnumber() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void InvoiceCorrectionInfo::set_has_invoicecorrectionnumber() {
  _has_bits_[0] |= 0x00000020u;
}
inline void InvoiceCorrectionInfo::clear_has_invoicecorrectionnumber() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void InvoiceCorrectionInfo::clear_invoicecorrectionnumber() {
  if (invoicecorrectionnumber_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    invoicecorrectionnumber_->clear();
  }
  clear_has_invoicecorrectionnumber();
}
inline const ::std::string& InvoiceCorrectionInfo::invoicecorrectionnumber() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.InvoiceCorrectionInfo.InvoiceCorrectionNumber)
  return *invoicecorrectionnumber_;
}
inline void InvoiceCorrectionInfo::set_invoicecorrectionnumber(const ::std::string& value) {
  set_has_invoicecorrectionnumber();
  if (invoicecorrectionnumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    invoicecorrectionnumber_ = new ::std::string;
  }
  invoicecorrectionnumber_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.InvoiceCorrectionInfo.InvoiceCorrectionNumber)
}
inline void InvoiceCorrectionInfo::set_invoicecorrectionnumber(const char* value) {
  set_has_invoicecorrectionnumber();
  if (invoicecorrectionnumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    invoicecorrectionnumber_ = new ::std::string;
  }
  invoicecorrectionnumber_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.InvoiceCorrectionInfo.InvoiceCorrectionNumber)
}
inline void InvoiceCorrectionInfo::set_invoicecorrectionnumber(const char* value, size_t size) {
  set_has_invoicecorrectionnumber();
  if (invoicecorrectionnumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    invoicecorrectionnumber_ = new ::std::string;
  }
  invoicecorrectionnumber_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.InvoiceCorrectionInfo.InvoiceCorrectionNumber)
}
inline ::std::string* InvoiceCorrectionInfo::mutable_invoicecorrectionnumber() {
  set_has_invoicecorrectionnumber();
  if (invoicecorrectionnumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    invoicecorrectionnumber_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.InvoiceCorrectionInfo.InvoiceCorrectionNumber)
  return invoicecorrectionnumber_;
}
inline ::std::string* InvoiceCorrectionInfo::release_invoicecorrectionnumber() {
  clear_has_invoicecorrectionnumber();
  if (invoicecorrectionnumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = invoicecorrectionnumber_;
    invoicecorrectionnumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void InvoiceCorrectionInfo::set_allocated_invoicecorrectionnumber(::std::string* invoicecorrectionnumber) {
  if (invoicecorrectionnumber_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete invoicecorrectionnumber_;
  }
  if (invoicecorrectionnumber) {
    set_has_invoicecorrectionnumber();
    invoicecorrectionnumber_ = invoicecorrectionnumber;
  } else {
    clear_has_invoicecorrectionnumber();
    invoicecorrectionnumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.InvoiceCorrectionInfo.InvoiceCorrectionNumber)
}

// optional string InvoiceCorrectionRevisionDate = 7;
inline bool InvoiceCorrectionInfo::has_invoicecorrectionrevisiondate() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void InvoiceCorrectionInfo::set_has_invoicecorrectionrevisiondate() {
  _has_bits_[0] |= 0x00000040u;
}
inline void InvoiceCorrectionInfo::clear_has_invoicecorrectionrevisiondate() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void InvoiceCorrectionInfo::clear_invoicecorrectionrevisiondate() {
  if (invoicecorrectionrevisiondate_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    invoicecorrectionrevisiondate_->clear();
  }
  clear_has_invoicecorrectionrevisiondate();
}
inline const ::std::string& InvoiceCorrectionInfo::invoicecorrectionrevisiondate() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.InvoiceCorrectionInfo.InvoiceCorrectionRevisionDate)
  return *invoicecorrectionrevisiondate_;
}
inline void InvoiceCorrectionInfo::set_invoicecorrectionrevisiondate(const ::std::string& value) {
  set_has_invoicecorrectionrevisiondate();
  if (invoicecorrectionrevisiondate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    invoicecorrectionrevisiondate_ = new ::std::string;
  }
  invoicecorrectionrevisiondate_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.InvoiceCorrectionInfo.InvoiceCorrectionRevisionDate)
}
inline void InvoiceCorrectionInfo::set_invoicecorrectionrevisiondate(const char* value) {
  set_has_invoicecorrectionrevisiondate();
  if (invoicecorrectionrevisiondate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    invoicecorrectionrevisiondate_ = new ::std::string;
  }
  invoicecorrectionrevisiondate_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.InvoiceCorrectionInfo.InvoiceCorrectionRevisionDate)
}
inline void InvoiceCorrectionInfo::set_invoicecorrectionrevisiondate(const char* value, size_t size) {
  set_has_invoicecorrectionrevisiondate();
  if (invoicecorrectionrevisiondate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    invoicecorrectionrevisiondate_ = new ::std::string;
  }
  invoicecorrectionrevisiondate_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.InvoiceCorrectionInfo.InvoiceCorrectionRevisionDate)
}
inline ::std::string* InvoiceCorrectionInfo::mutable_invoicecorrectionrevisiondate() {
  set_has_invoicecorrectionrevisiondate();
  if (invoicecorrectionrevisiondate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    invoicecorrectionrevisiondate_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.InvoiceCorrectionInfo.InvoiceCorrectionRevisionDate)
  return invoicecorrectionrevisiondate_;
}
inline ::std::string* InvoiceCorrectionInfo::release_invoicecorrectionrevisiondate() {
  clear_has_invoicecorrectionrevisiondate();
  if (invoicecorrectionrevisiondate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = invoicecorrectionrevisiondate_;
    invoicecorrectionrevisiondate_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void InvoiceCorrectionInfo::set_allocated_invoicecorrectionrevisiondate(::std::string* invoicecorrectionrevisiondate) {
  if (invoicecorrectionrevisiondate_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete invoicecorrectionrevisiondate_;
  }
  if (invoicecorrectionrevisiondate) {
    set_has_invoicecorrectionrevisiondate();
    invoicecorrectionrevisiondate_ = invoicecorrectionrevisiondate;
  } else {
    clear_has_invoicecorrectionrevisiondate();
    invoicecorrectionrevisiondate_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.InvoiceCorrectionInfo.InvoiceCorrectionRevisionDate)
}

// optional string InvoiceCorrectionRevisionNumber = 8;
inline bool InvoiceCorrectionInfo::has_invoicecorrectionrevisionnumber() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void InvoiceCorrectionInfo::set_has_invoicecorrectionrevisionnumber() {
  _has_bits_[0] |= 0x00000080u;
}
inline void InvoiceCorrectionInfo::clear_has_invoicecorrectionrevisionnumber() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void InvoiceCorrectionInfo::clear_invoicecorrectionrevisionnumber() {
  if (invoicecorrectionrevisionnumber_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    invoicecorrectionrevisionnumber_->clear();
  }
  clear_has_invoicecorrectionrevisionnumber();
}
inline const ::std::string& InvoiceCorrectionInfo::invoicecorrectionrevisionnumber() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.InvoiceCorrectionInfo.InvoiceCorrectionRevisionNumber)
  return *invoicecorrectionrevisionnumber_;
}
inline void InvoiceCorrectionInfo::set_invoicecorrectionrevisionnumber(const ::std::string& value) {
  set_has_invoicecorrectionrevisionnumber();
  if (invoicecorrectionrevisionnumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    invoicecorrectionrevisionnumber_ = new ::std::string;
  }
  invoicecorrectionrevisionnumber_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.InvoiceCorrectionInfo.InvoiceCorrectionRevisionNumber)
}
inline void InvoiceCorrectionInfo::set_invoicecorrectionrevisionnumber(const char* value) {
  set_has_invoicecorrectionrevisionnumber();
  if (invoicecorrectionrevisionnumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    invoicecorrectionrevisionnumber_ = new ::std::string;
  }
  invoicecorrectionrevisionnumber_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.InvoiceCorrectionInfo.InvoiceCorrectionRevisionNumber)
}
inline void InvoiceCorrectionInfo::set_invoicecorrectionrevisionnumber(const char* value, size_t size) {
  set_has_invoicecorrectionrevisionnumber();
  if (invoicecorrectionrevisionnumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    invoicecorrectionrevisionnumber_ = new ::std::string;
  }
  invoicecorrectionrevisionnumber_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.InvoiceCorrectionInfo.InvoiceCorrectionRevisionNumber)
}
inline ::std::string* InvoiceCorrectionInfo::mutable_invoicecorrectionrevisionnumber() {
  set_has_invoicecorrectionrevisionnumber();
  if (invoicecorrectionrevisionnumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    invoicecorrectionrevisionnumber_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.InvoiceCorrectionInfo.InvoiceCorrectionRevisionNumber)
  return invoicecorrectionrevisionnumber_;
}
inline ::std::string* InvoiceCorrectionInfo::release_invoicecorrectionrevisionnumber() {
  clear_has_invoicecorrectionrevisionnumber();
  if (invoicecorrectionrevisionnumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = invoicecorrectionrevisionnumber_;
    invoicecorrectionrevisionnumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void InvoiceCorrectionInfo::set_allocated_invoicecorrectionrevisionnumber(::std::string* invoicecorrectionrevisionnumber) {
  if (invoicecorrectionrevisionnumber_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete invoicecorrectionrevisionnumber_;
  }
  if (invoicecorrectionrevisionnumber) {
    set_has_invoicecorrectionrevisionnumber();
    invoicecorrectionrevisionnumber_ = invoicecorrectionrevisionnumber;
  } else {
    clear_has_invoicecorrectionrevisionnumber();
    invoicecorrectionrevisionnumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.InvoiceCorrectionInfo.InvoiceCorrectionRevisionNumber)
}

// required .Diadoc.Api.Proto.Invoicing.DiadocOrganizationInfo Seller = 9;
inline bool InvoiceCorrectionInfo::has_seller() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void InvoiceCorrectionInfo::set_has_seller() {
  _has_bits_[0] |= 0x00000100u;
}
inline void InvoiceCorrectionInfo::clear_has_seller() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void InvoiceCorrectionInfo::clear_seller() {
  if (seller_ != NULL) seller_->::Diadoc::Api::Proto::Invoicing::DiadocOrganizationInfo::Clear();
  clear_has_seller();
}
inline const ::Diadoc::Api::Proto::Invoicing::DiadocOrganizationInfo& InvoiceCorrectionInfo::seller() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.InvoiceCorrectionInfo.Seller)
  return seller_ != NULL ? *seller_ : *default_instance_->seller_;
}
inline ::Diadoc::Api::Proto::Invoicing::DiadocOrganizationInfo* InvoiceCorrectionInfo::mutable_seller() {
  set_has_seller();
  if (seller_ == NULL) seller_ = new ::Diadoc::Api::Proto::Invoicing::DiadocOrganizationInfo;
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.InvoiceCorrectionInfo.Seller)
  return seller_;
}
inline ::Diadoc::Api::Proto::Invoicing::DiadocOrganizationInfo* InvoiceCorrectionInfo::release_seller() {
  clear_has_seller();
  ::Diadoc::Api::Proto::Invoicing::DiadocOrganizationInfo* temp = seller_;
  seller_ = NULL;
  return temp;
}
inline void InvoiceCorrectionInfo::set_allocated_seller(::Diadoc::Api::Proto::Invoicing::DiadocOrganizationInfo* seller) {
  delete seller_;
  seller_ = seller;
  if (seller) {
    set_has_seller();
  } else {
    clear_has_seller();
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.InvoiceCorrectionInfo.Seller)
}

// required .Diadoc.Api.Proto.Invoicing.DiadocOrganizationInfo Buyer = 10;
inline bool InvoiceCorrectionInfo::has_buyer() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void InvoiceCorrectionInfo::set_has_buyer() {
  _has_bits_[0] |= 0x00000200u;
}
inline void InvoiceCorrectionInfo::clear_has_buyer() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void InvoiceCorrectionInfo::clear_buyer() {
  if (buyer_ != NULL) buyer_->::Diadoc::Api::Proto::Invoicing::DiadocOrganizationInfo::Clear();
  clear_has_buyer();
}
inline const ::Diadoc::Api::Proto::Invoicing::DiadocOrganizationInfo& InvoiceCorrectionInfo::buyer() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.InvoiceCorrectionInfo.Buyer)
  return buyer_ != NULL ? *buyer_ : *default_instance_->buyer_;
}
inline ::Diadoc::Api::Proto::Invoicing::DiadocOrganizationInfo* InvoiceCorrectionInfo::mutable_buyer() {
  set_has_buyer();
  if (buyer_ == NULL) buyer_ = new ::Diadoc::Api::Proto::Invoicing::DiadocOrganizationInfo;
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.InvoiceCorrectionInfo.Buyer)
  return buyer_;
}
inline ::Diadoc::Api::Proto::Invoicing::DiadocOrganizationInfo* InvoiceCorrectionInfo::release_buyer() {
  clear_has_buyer();
  ::Diadoc::Api::Proto::Invoicing::DiadocOrganizationInfo* temp = buyer_;
  buyer_ = NULL;
  return temp;
}
inline void InvoiceCorrectionInfo::set_allocated_buyer(::Diadoc::Api::Proto::Invoicing::DiadocOrganizationInfo* buyer) {
  delete buyer_;
  buyer_ = buyer;
  if (buyer) {
    set_has_buyer();
  } else {
    clear_has_buyer();
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.InvoiceCorrectionInfo.Buyer)
}

// required .Diadoc.Api.Proto.Invoicing.Signer Signer = 11;
inline bool InvoiceCorrectionInfo::has_signer() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void InvoiceCorrectionInfo::set_has_signer() {
  _has_bits_[0] |= 0x00000400u;
}
inline void InvoiceCorrectionInfo::clear_has_signer() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void InvoiceCorrectionInfo::clear_signer() {
  if (signer_ != NULL) signer_->::Diadoc::Api::Proto::Invoicing::Signer::Clear();
  clear_has_signer();
}
inline const ::Diadoc::Api::Proto::Invoicing::Signer& InvoiceCorrectionInfo::signer() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.InvoiceCorrectionInfo.Signer)
  return signer_ != NULL ? *signer_ : *default_instance_->signer_;
}
inline ::Diadoc::Api::Proto::Invoicing::Signer* InvoiceCorrectionInfo::mutable_signer() {
  set_has_signer();
  if (signer_ == NULL) signer_ = new ::Diadoc::Api::Proto::Invoicing::Signer;
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.InvoiceCorrectionInfo.Signer)
  return signer_;
}
inline ::Diadoc::Api::Proto::Invoicing::Signer* InvoiceCorrectionInfo::release_signer() {
  clear_has_signer();
  ::Diadoc::Api::Proto::Invoicing::Signer* temp = signer_;
  signer_ = NULL;
  return temp;
}
inline void InvoiceCorrectionInfo::set_allocated_signer(::Diadoc::Api::Proto::Invoicing::Signer* signer) {
  delete signer_;
  signer_ = signer;
  if (signer) {
    set_has_signer();
  } else {
    clear_has_signer();
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.InvoiceCorrectionInfo.Signer)
}

// repeated .Diadoc.Api.Proto.Invoicing.InvoiceCorrectionItem Items = 12;
inline int InvoiceCorrectionInfo::items_size() const {
  return items_.size();
}
inline void InvoiceCorrectionInfo::clear_items() {
  items_.Clear();
}
inline const ::Diadoc::Api::Proto::Invoicing::InvoiceCorrectionItem& InvoiceCorrectionInfo::items(int index) const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.InvoiceCorrectionInfo.Items)
  return items_.Get(index);
}
inline ::Diadoc::Api::Proto::Invoicing::InvoiceCorrectionItem* InvoiceCorrectionInfo::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.InvoiceCorrectionInfo.Items)
  return items_.Mutable(index);
}
inline ::Diadoc::Api::Proto::Invoicing::InvoiceCorrectionItem* InvoiceCorrectionInfo::add_items() {
  // @@protoc_insertion_point(field_add:Diadoc.Api.Proto.Invoicing.InvoiceCorrectionInfo.Items)
  return items_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::InvoiceCorrectionItem >&
InvoiceCorrectionInfo::items() const {
  // @@protoc_insertion_point(field_list:Diadoc.Api.Proto.Invoicing.InvoiceCorrectionInfo.Items)
  return items_;
}
inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::InvoiceCorrectionItem >*
InvoiceCorrectionInfo::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:Diadoc.Api.Proto.Invoicing.InvoiceCorrectionInfo.Items)
  return &items_;
}

// optional string Currency = 13;
inline bool InvoiceCorrectionInfo::has_currency() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void InvoiceCorrectionInfo::set_has_currency() {
  _has_bits_[0] |= 0x00001000u;
}
inline void InvoiceCorrectionInfo::clear_has_currency() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void InvoiceCorrectionInfo::clear_currency() {
  if (currency_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    currency_->clear();
  }
  clear_has_currency();
}
inline const ::std::string& InvoiceCorrectionInfo::currency() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.InvoiceCorrectionInfo.Currency)
  return *currency_;
}
inline void InvoiceCorrectionInfo::set_currency(const ::std::string& value) {
  set_has_currency();
  if (currency_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    currency_ = new ::std::string;
  }
  currency_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.InvoiceCorrectionInfo.Currency)
}
inline void InvoiceCorrectionInfo::set_currency(const char* value) {
  set_has_currency();
  if (currency_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    currency_ = new ::std::string;
  }
  currency_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.InvoiceCorrectionInfo.Currency)
}
inline void InvoiceCorrectionInfo::set_currency(const char* value, size_t size) {
  set_has_currency();
  if (currency_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    currency_ = new ::std::string;
  }
  currency_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.InvoiceCorrectionInfo.Currency)
}
inline ::std::string* InvoiceCorrectionInfo::mutable_currency() {
  set_has_currency();
  if (currency_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    currency_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.InvoiceCorrectionInfo.Currency)
  return currency_;
}
inline ::std::string* InvoiceCorrectionInfo::release_currency() {
  clear_has_currency();
  if (currency_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = currency_;
    currency_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void InvoiceCorrectionInfo::set_allocated_currency(::std::string* currency) {
  if (currency_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete currency_;
  }
  if (currency) {
    set_has_currency();
    currency_ = currency;
  } else {
    clear_has_currency();
    currency_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.InvoiceCorrectionInfo.Currency)
}

// optional .Diadoc.Api.Proto.Invoicing.InvoiceTotalsDiff TotalsInc = 14;
inline bool InvoiceCorrectionInfo::has_totalsinc() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void InvoiceCorrectionInfo::set_has_totalsinc() {
  _has_bits_[0] |= 0x00002000u;
}
inline void InvoiceCorrectionInfo::clear_has_totalsinc() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void InvoiceCorrectionInfo::clear_totalsinc() {
  if (totalsinc_ != NULL) totalsinc_->::Diadoc::Api::Proto::Invoicing::InvoiceTotalsDiff::Clear();
  clear_has_totalsinc();
}
inline const ::Diadoc::Api::Proto::Invoicing::InvoiceTotalsDiff& InvoiceCorrectionInfo::totalsinc() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.InvoiceCorrectionInfo.TotalsInc)
  return totalsinc_ != NULL ? *totalsinc_ : *default_instance_->totalsinc_;
}
inline ::Diadoc::Api::Proto::Invoicing::InvoiceTotalsDiff* InvoiceCorrectionInfo::mutable_totalsinc() {
  set_has_totalsinc();
  if (totalsinc_ == NULL) totalsinc_ = new ::Diadoc::Api::Proto::Invoicing::InvoiceTotalsDiff;
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.InvoiceCorrectionInfo.TotalsInc)
  return totalsinc_;
}
inline ::Diadoc::Api::Proto::Invoicing::InvoiceTotalsDiff* InvoiceCorrectionInfo::release_totalsinc() {
  clear_has_totalsinc();
  ::Diadoc::Api::Proto::Invoicing::InvoiceTotalsDiff* temp = totalsinc_;
  totalsinc_ = NULL;
  return temp;
}
inline void InvoiceCorrectionInfo::set_allocated_totalsinc(::Diadoc::Api::Proto::Invoicing::InvoiceTotalsDiff* totalsinc) {
  delete totalsinc_;
  totalsinc_ = totalsinc;
  if (totalsinc) {
    set_has_totalsinc();
  } else {
    clear_has_totalsinc();
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.InvoiceCorrectionInfo.TotalsInc)
}

// optional .Diadoc.Api.Proto.Invoicing.InvoiceTotalsDiff TotalsDec = 15;
inline bool InvoiceCorrectionInfo::has_totalsdec() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void InvoiceCorrectionInfo::set_has_totalsdec() {
  _has_bits_[0] |= 0x00004000u;
}
inline void InvoiceCorrectionInfo::clear_has_totalsdec() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void InvoiceCorrectionInfo::clear_totalsdec() {
  if (totalsdec_ != NULL) totalsdec_->::Diadoc::Api::Proto::Invoicing::InvoiceTotalsDiff::Clear();
  clear_has_totalsdec();
}
inline const ::Diadoc::Api::Proto::Invoicing::InvoiceTotalsDiff& InvoiceCorrectionInfo::totalsdec() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.InvoiceCorrectionInfo.TotalsDec)
  return totalsdec_ != NULL ? *totalsdec_ : *default_instance_->totalsdec_;
}
inline ::Diadoc::Api::Proto::Invoicing::InvoiceTotalsDiff* InvoiceCorrectionInfo::mutable_totalsdec() {
  set_has_totalsdec();
  if (totalsdec_ == NULL) totalsdec_ = new ::Diadoc::Api::Proto::Invoicing::InvoiceTotalsDiff;
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.InvoiceCorrectionInfo.TotalsDec)
  return totalsdec_;
}
inline ::Diadoc::Api::Proto::Invoicing::InvoiceTotalsDiff* InvoiceCorrectionInfo::release_totalsdec() {
  clear_has_totalsdec();
  ::Diadoc::Api::Proto::Invoicing::InvoiceTotalsDiff* temp = totalsdec_;
  totalsdec_ = NULL;
  return temp;
}
inline void InvoiceCorrectionInfo::set_allocated_totalsdec(::Diadoc::Api::Proto::Invoicing::InvoiceTotalsDiff* totalsdec) {
  delete totalsdec_;
  totalsdec_ = totalsdec;
  if (totalsdec) {
    set_has_totalsdec();
  } else {
    clear_has_totalsdec();
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.InvoiceCorrectionInfo.TotalsDec)
}

// optional string AdditionalInfo = 16;
inline bool InvoiceCorrectionInfo::has_additionalinfo() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void InvoiceCorrectionInfo::set_has_additionalinfo() {
  _has_bits_[0] |= 0x00008000u;
}
inline void InvoiceCorrectionInfo::clear_has_additionalinfo() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void InvoiceCorrectionInfo::clear_additionalinfo() {
  if (additionalinfo_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    additionalinfo_->clear();
  }
  clear_has_additionalinfo();
}
inline const ::std::string& InvoiceCorrectionInfo::additionalinfo() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.InvoiceCorrectionInfo.AdditionalInfo)
  return *additionalinfo_;
}
inline void InvoiceCorrectionInfo::set_additionalinfo(const ::std::string& value) {
  set_has_additionalinfo();
  if (additionalinfo_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    additionalinfo_ = new ::std::string;
  }
  additionalinfo_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.InvoiceCorrectionInfo.AdditionalInfo)
}
inline void InvoiceCorrectionInfo::set_additionalinfo(const char* value) {
  set_has_additionalinfo();
  if (additionalinfo_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    additionalinfo_ = new ::std::string;
  }
  additionalinfo_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.InvoiceCorrectionInfo.AdditionalInfo)
}
inline void InvoiceCorrectionInfo::set_additionalinfo(const char* value, size_t size) {
  set_has_additionalinfo();
  if (additionalinfo_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    additionalinfo_ = new ::std::string;
  }
  additionalinfo_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.InvoiceCorrectionInfo.AdditionalInfo)
}
inline ::std::string* InvoiceCorrectionInfo::mutable_additionalinfo() {
  set_has_additionalinfo();
  if (additionalinfo_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    additionalinfo_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.InvoiceCorrectionInfo.AdditionalInfo)
  return additionalinfo_;
}
inline ::std::string* InvoiceCorrectionInfo::release_additionalinfo() {
  clear_has_additionalinfo();
  if (additionalinfo_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = additionalinfo_;
    additionalinfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void InvoiceCorrectionInfo::set_allocated_additionalinfo(::std::string* additionalinfo) {
  if (additionalinfo_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete additionalinfo_;
  }
  if (additionalinfo) {
    set_has_additionalinfo();
    additionalinfo_ = additionalinfo;
  } else {
    clear_has_additionalinfo();
    additionalinfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.InvoiceCorrectionInfo.AdditionalInfo)
}

// repeated .Diadoc.Api.Proto.Invoicing.AdditionalInfo AdditionalInfos = 17;
inline int InvoiceCorrectionInfo::additionalinfos_size() const {
  return additionalinfos_.size();
}
inline void InvoiceCorrectionInfo::clear_additionalinfos() {
  additionalinfos_.Clear();
}
inline const ::Diadoc::Api::Proto::Invoicing::AdditionalInfo& InvoiceCorrectionInfo::additionalinfos(int index) const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.InvoiceCorrectionInfo.AdditionalInfos)
  return additionalinfos_.Get(index);
}
inline ::Diadoc::Api::Proto::Invoicing::AdditionalInfo* InvoiceCorrectionInfo::mutable_additionalinfos(int index) {
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.InvoiceCorrectionInfo.AdditionalInfos)
  return additionalinfos_.Mutable(index);
}
inline ::Diadoc::Api::Proto::Invoicing::AdditionalInfo* InvoiceCorrectionInfo::add_additionalinfos() {
  // @@protoc_insertion_point(field_add:Diadoc.Api.Proto.Invoicing.InvoiceCorrectionInfo.AdditionalInfos)
  return additionalinfos_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::AdditionalInfo >&
InvoiceCorrectionInfo::additionalinfos() const {
  // @@protoc_insertion_point(field_list:Diadoc.Api.Proto.Invoicing.InvoiceCorrectionInfo.AdditionalInfos)
  return additionalinfos_;
}
inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::AdditionalInfo >*
InvoiceCorrectionInfo::mutable_additionalinfos() {
  // @@protoc_insertion_point(field_mutable_list:Diadoc.Api.Proto.Invoicing.InvoiceCorrectionInfo.AdditionalInfos)
  return &additionalinfos_;
}

// optional .Diadoc.Api.Proto.Invoicing.InvoiceFormatVersion Version = 18 [default = DefaultInvoiceFormatVersion];
inline bool InvoiceCorrectionInfo::has_version() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void InvoiceCorrectionInfo::set_has_version() {
  _has_bits_[0] |= 0x00020000u;
}
inline void InvoiceCorrectionInfo::clear_has_version() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void InvoiceCorrectionInfo::clear_version() {
  version_ = 0;
  clear_has_version();
}
inline ::Diadoc::Api::Proto::Invoicing::InvoiceFormatVersion InvoiceCorrectionInfo::version() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.InvoiceCorrectionInfo.Version)
  return static_cast< ::Diadoc::Api::Proto::Invoicing::InvoiceFormatVersion >(version_);
}
inline void InvoiceCorrectionInfo::set_version(::Diadoc::Api::Proto::Invoicing::InvoiceFormatVersion value) {
  assert(::Diadoc::Api::Proto::Invoicing::InvoiceFormatVersion_IsValid(value));
  set_has_version();
  version_ = value;
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.InvoiceCorrectionInfo.Version)
}

// -------------------------------------------------------------------

// InvoiceTotalsDiff

// optional string TotalWithVatExcluded = 1;
inline bool InvoiceTotalsDiff::has_totalwithvatexcluded() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InvoiceTotalsDiff::set_has_totalwithvatexcluded() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InvoiceTotalsDiff::clear_has_totalwithvatexcluded() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InvoiceTotalsDiff::clear_totalwithvatexcluded() {
  if (totalwithvatexcluded_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    totalwithvatexcluded_->clear();
  }
  clear_has_totalwithvatexcluded();
}
inline const ::std::string& InvoiceTotalsDiff::totalwithvatexcluded() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.InvoiceTotalsDiff.TotalWithVatExcluded)
  return *totalwithvatexcluded_;
}
inline void InvoiceTotalsDiff::set_totalwithvatexcluded(const ::std::string& value) {
  set_has_totalwithvatexcluded();
  if (totalwithvatexcluded_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    totalwithvatexcluded_ = new ::std::string;
  }
  totalwithvatexcluded_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.InvoiceTotalsDiff.TotalWithVatExcluded)
}
inline void InvoiceTotalsDiff::set_totalwithvatexcluded(const char* value) {
  set_has_totalwithvatexcluded();
  if (totalwithvatexcluded_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    totalwithvatexcluded_ = new ::std::string;
  }
  totalwithvatexcluded_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.InvoiceTotalsDiff.TotalWithVatExcluded)
}
inline void InvoiceTotalsDiff::set_totalwithvatexcluded(const char* value, size_t size) {
  set_has_totalwithvatexcluded();
  if (totalwithvatexcluded_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    totalwithvatexcluded_ = new ::std::string;
  }
  totalwithvatexcluded_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.InvoiceTotalsDiff.TotalWithVatExcluded)
}
inline ::std::string* InvoiceTotalsDiff::mutable_totalwithvatexcluded() {
  set_has_totalwithvatexcluded();
  if (totalwithvatexcluded_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    totalwithvatexcluded_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.InvoiceTotalsDiff.TotalWithVatExcluded)
  return totalwithvatexcluded_;
}
inline ::std::string* InvoiceTotalsDiff::release_totalwithvatexcluded() {
  clear_has_totalwithvatexcluded();
  if (totalwithvatexcluded_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = totalwithvatexcluded_;
    totalwithvatexcluded_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void InvoiceTotalsDiff::set_allocated_totalwithvatexcluded(::std::string* totalwithvatexcluded) {
  if (totalwithvatexcluded_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete totalwithvatexcluded_;
  }
  if (totalwithvatexcluded) {
    set_has_totalwithvatexcluded();
    totalwithvatexcluded_ = totalwithvatexcluded;
  } else {
    clear_has_totalwithvatexcluded();
    totalwithvatexcluded_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.InvoiceTotalsDiff.TotalWithVatExcluded)
}

// optional string Vat = 2;
inline bool InvoiceTotalsDiff::has_vat() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InvoiceTotalsDiff::set_has_vat() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InvoiceTotalsDiff::clear_has_vat() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InvoiceTotalsDiff::clear_vat() {
  if (vat_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vat_->clear();
  }
  clear_has_vat();
}
inline const ::std::string& InvoiceTotalsDiff::vat() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.InvoiceTotalsDiff.Vat)
  return *vat_;
}
inline void InvoiceTotalsDiff::set_vat(const ::std::string& value) {
  set_has_vat();
  if (vat_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vat_ = new ::std::string;
  }
  vat_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.InvoiceTotalsDiff.Vat)
}
inline void InvoiceTotalsDiff::set_vat(const char* value) {
  set_has_vat();
  if (vat_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vat_ = new ::std::string;
  }
  vat_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.InvoiceTotalsDiff.Vat)
}
inline void InvoiceTotalsDiff::set_vat(const char* value, size_t size) {
  set_has_vat();
  if (vat_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vat_ = new ::std::string;
  }
  vat_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.InvoiceTotalsDiff.Vat)
}
inline ::std::string* InvoiceTotalsDiff::mutable_vat() {
  set_has_vat();
  if (vat_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vat_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.InvoiceTotalsDiff.Vat)
  return vat_;
}
inline ::std::string* InvoiceTotalsDiff::release_vat() {
  clear_has_vat();
  if (vat_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = vat_;
    vat_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void InvoiceTotalsDiff::set_allocated_vat(::std::string* vat) {
  if (vat_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete vat_;
  }
  if (vat) {
    set_has_vat();
    vat_ = vat;
  } else {
    clear_has_vat();
    vat_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.InvoiceTotalsDiff.Vat)
}

// required string Total = 3;
inline bool InvoiceTotalsDiff::has_total() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InvoiceTotalsDiff::set_has_total() {
  _has_bits_[0] |= 0x00000004u;
}
inline void InvoiceTotalsDiff::clear_has_total() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void InvoiceTotalsDiff::clear_total() {
  if (total_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    total_->clear();
  }
  clear_has_total();
}
inline const ::std::string& InvoiceTotalsDiff::total() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.InvoiceTotalsDiff.Total)
  return *total_;
}
inline void InvoiceTotalsDiff::set_total(const ::std::string& value) {
  set_has_total();
  if (total_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    total_ = new ::std::string;
  }
  total_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.InvoiceTotalsDiff.Total)
}
inline void InvoiceTotalsDiff::set_total(const char* value) {
  set_has_total();
  if (total_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    total_ = new ::std::string;
  }
  total_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.InvoiceTotalsDiff.Total)
}
inline void InvoiceTotalsDiff::set_total(const char* value, size_t size) {
  set_has_total();
  if (total_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    total_ = new ::std::string;
  }
  total_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.InvoiceTotalsDiff.Total)
}
inline ::std::string* InvoiceTotalsDiff::mutable_total() {
  set_has_total();
  if (total_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    total_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.InvoiceTotalsDiff.Total)
  return total_;
}
inline ::std::string* InvoiceTotalsDiff::release_total() {
  clear_has_total();
  if (total_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = total_;
    total_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void InvoiceTotalsDiff::set_allocated_total(::std::string* total) {
  if (total_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete total_;
  }
  if (total) {
    set_has_total();
    total_ = total;
  } else {
    clear_has_total();
    total_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.InvoiceTotalsDiff.Total)
}

// -------------------------------------------------------------------

// InvoiceCorrectionItem

// required string Product = 1;
inline bool InvoiceCorrectionItem::has_product() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InvoiceCorrectionItem::set_has_product() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InvoiceCorrectionItem::clear_has_product() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InvoiceCorrectionItem::clear_product() {
  if (product_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    product_->clear();
  }
  clear_has_product();
}
inline const ::std::string& InvoiceCorrectionItem::product() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.InvoiceCorrectionItem.Product)
  return *product_;
}
inline void InvoiceCorrectionItem::set_product(const ::std::string& value) {
  set_has_product();
  if (product_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    product_ = new ::std::string;
  }
  product_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.InvoiceCorrectionItem.Product)
}
inline void InvoiceCorrectionItem::set_product(const char* value) {
  set_has_product();
  if (product_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    product_ = new ::std::string;
  }
  product_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.InvoiceCorrectionItem.Product)
}
inline void InvoiceCorrectionItem::set_product(const char* value, size_t size) {
  set_has_product();
  if (product_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    product_ = new ::std::string;
  }
  product_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.InvoiceCorrectionItem.Product)
}
inline ::std::string* InvoiceCorrectionItem::mutable_product() {
  set_has_product();
  if (product_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    product_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.InvoiceCorrectionItem.Product)
  return product_;
}
inline ::std::string* InvoiceCorrectionItem::release_product() {
  clear_has_product();
  if (product_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = product_;
    product_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void InvoiceCorrectionItem::set_allocated_product(::std::string* product) {
  if (product_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete product_;
  }
  if (product) {
    set_has_product();
    product_ = product;
  } else {
    clear_has_product();
    product_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.InvoiceCorrectionItem.Product)
}

// required .Diadoc.Api.Proto.Invoicing.CorrectableInvoiceItemFields OriginalValues = 2;
inline bool InvoiceCorrectionItem::has_originalvalues() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InvoiceCorrectionItem::set_has_originalvalues() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InvoiceCorrectionItem::clear_has_originalvalues() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InvoiceCorrectionItem::clear_originalvalues() {
  if (originalvalues_ != NULL) originalvalues_->::Diadoc::Api::Proto::Invoicing::CorrectableInvoiceItemFields::Clear();
  clear_has_originalvalues();
}
inline const ::Diadoc::Api::Proto::Invoicing::CorrectableInvoiceItemFields& InvoiceCorrectionItem::originalvalues() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.InvoiceCorrectionItem.OriginalValues)
  return originalvalues_ != NULL ? *originalvalues_ : *default_instance_->originalvalues_;
}
inline ::Diadoc::Api::Proto::Invoicing::CorrectableInvoiceItemFields* InvoiceCorrectionItem::mutable_originalvalues() {
  set_has_originalvalues();
  if (originalvalues_ == NULL) originalvalues_ = new ::Diadoc::Api::Proto::Invoicing::CorrectableInvoiceItemFields;
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.InvoiceCorrectionItem.OriginalValues)
  return originalvalues_;
}
inline ::Diadoc::Api::Proto::Invoicing::CorrectableInvoiceItemFields* InvoiceCorrectionItem::release_originalvalues() {
  clear_has_originalvalues();
  ::Diadoc::Api::Proto::Invoicing::CorrectableInvoiceItemFields* temp = originalvalues_;
  originalvalues_ = NULL;
  return temp;
}
inline void InvoiceCorrectionItem::set_allocated_originalvalues(::Diadoc::Api::Proto::Invoicing::CorrectableInvoiceItemFields* originalvalues) {
  delete originalvalues_;
  originalvalues_ = originalvalues;
  if (originalvalues) {
    set_has_originalvalues();
  } else {
    clear_has_originalvalues();
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.InvoiceCorrectionItem.OriginalValues)
}

// required .Diadoc.Api.Proto.Invoicing.CorrectableInvoiceItemFields CorrectedValues = 3;
inline bool InvoiceCorrectionItem::has_correctedvalues() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InvoiceCorrectionItem::set_has_correctedvalues() {
  _has_bits_[0] |= 0x00000004u;
}
inline void InvoiceCorrectionItem::clear_has_correctedvalues() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void InvoiceCorrectionItem::clear_correctedvalues() {
  if (correctedvalues_ != NULL) correctedvalues_->::Diadoc::Api::Proto::Invoicing::CorrectableInvoiceItemFields::Clear();
  clear_has_correctedvalues();
}
inline const ::Diadoc::Api::Proto::Invoicing::CorrectableInvoiceItemFields& InvoiceCorrectionItem::correctedvalues() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.InvoiceCorrectionItem.CorrectedValues)
  return correctedvalues_ != NULL ? *correctedvalues_ : *default_instance_->correctedvalues_;
}
inline ::Diadoc::Api::Proto::Invoicing::CorrectableInvoiceItemFields* InvoiceCorrectionItem::mutable_correctedvalues() {
  set_has_correctedvalues();
  if (correctedvalues_ == NULL) correctedvalues_ = new ::Diadoc::Api::Proto::Invoicing::CorrectableInvoiceItemFields;
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.InvoiceCorrectionItem.CorrectedValues)
  return correctedvalues_;
}
inline ::Diadoc::Api::Proto::Invoicing::CorrectableInvoiceItemFields* InvoiceCorrectionItem::release_correctedvalues() {
  clear_has_correctedvalues();
  ::Diadoc::Api::Proto::Invoicing::CorrectableInvoiceItemFields* temp = correctedvalues_;
  correctedvalues_ = NULL;
  return temp;
}
inline void InvoiceCorrectionItem::set_allocated_correctedvalues(::Diadoc::Api::Proto::Invoicing::CorrectableInvoiceItemFields* correctedvalues) {
  delete correctedvalues_;
  correctedvalues_ = correctedvalues;
  if (correctedvalues) {
    set_has_correctedvalues();
  } else {
    clear_has_correctedvalues();
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.InvoiceCorrectionItem.CorrectedValues)
}

// optional .Diadoc.Api.Proto.Invoicing.InvoiceItemAmountsDiff AmountsInc = 4;
inline bool InvoiceCorrectionItem::has_amountsinc() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void InvoiceCorrectionItem::set_has_amountsinc() {
  _has_bits_[0] |= 0x00000008u;
}
inline void InvoiceCorrectionItem::clear_has_amountsinc() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void InvoiceCorrectionItem::clear_amountsinc() {
  if (amountsinc_ != NULL) amountsinc_->::Diadoc::Api::Proto::Invoicing::InvoiceItemAmountsDiff::Clear();
  clear_has_amountsinc();
}
inline const ::Diadoc::Api::Proto::Invoicing::InvoiceItemAmountsDiff& InvoiceCorrectionItem::amountsinc() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.InvoiceCorrectionItem.AmountsInc)
  return amountsinc_ != NULL ? *amountsinc_ : *default_instance_->amountsinc_;
}
inline ::Diadoc::Api::Proto::Invoicing::InvoiceItemAmountsDiff* InvoiceCorrectionItem::mutable_amountsinc() {
  set_has_amountsinc();
  if (amountsinc_ == NULL) amountsinc_ = new ::Diadoc::Api::Proto::Invoicing::InvoiceItemAmountsDiff;
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.InvoiceCorrectionItem.AmountsInc)
  return amountsinc_;
}
inline ::Diadoc::Api::Proto::Invoicing::InvoiceItemAmountsDiff* InvoiceCorrectionItem::release_amountsinc() {
  clear_has_amountsinc();
  ::Diadoc::Api::Proto::Invoicing::InvoiceItemAmountsDiff* temp = amountsinc_;
  amountsinc_ = NULL;
  return temp;
}
inline void InvoiceCorrectionItem::set_allocated_amountsinc(::Diadoc::Api::Proto::Invoicing::InvoiceItemAmountsDiff* amountsinc) {
  delete amountsinc_;
  amountsinc_ = amountsinc;
  if (amountsinc) {
    set_has_amountsinc();
  } else {
    clear_has_amountsinc();
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.InvoiceCorrectionItem.AmountsInc)
}

// optional .Diadoc.Api.Proto.Invoicing.InvoiceItemAmountsDiff AmountsDec = 5;
inline bool InvoiceCorrectionItem::has_amountsdec() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void InvoiceCorrectionItem::set_has_amountsdec() {
  _has_bits_[0] |= 0x00000010u;
}
inline void InvoiceCorrectionItem::clear_has_amountsdec() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void InvoiceCorrectionItem::clear_amountsdec() {
  if (amountsdec_ != NULL) amountsdec_->::Diadoc::Api::Proto::Invoicing::InvoiceItemAmountsDiff::Clear();
  clear_has_amountsdec();
}
inline const ::Diadoc::Api::Proto::Invoicing::InvoiceItemAmountsDiff& InvoiceCorrectionItem::amountsdec() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.InvoiceCorrectionItem.AmountsDec)
  return amountsdec_ != NULL ? *amountsdec_ : *default_instance_->amountsdec_;
}
inline ::Diadoc::Api::Proto::Invoicing::InvoiceItemAmountsDiff* InvoiceCorrectionItem::mutable_amountsdec() {
  set_has_amountsdec();
  if (amountsdec_ == NULL) amountsdec_ = new ::Diadoc::Api::Proto::Invoicing::InvoiceItemAmountsDiff;
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.InvoiceCorrectionItem.AmountsDec)
  return amountsdec_;
}
inline ::Diadoc::Api::Proto::Invoicing::InvoiceItemAmountsDiff* InvoiceCorrectionItem::release_amountsdec() {
  clear_has_amountsdec();
  ::Diadoc::Api::Proto::Invoicing::InvoiceItemAmountsDiff* temp = amountsdec_;
  amountsdec_ = NULL;
  return temp;
}
inline void InvoiceCorrectionItem::set_allocated_amountsdec(::Diadoc::Api::Proto::Invoicing::InvoiceItemAmountsDiff* amountsdec) {
  delete amountsdec_;
  amountsdec_ = amountsdec;
  if (amountsdec) {
    set_has_amountsdec();
  } else {
    clear_has_amountsdec();
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.InvoiceCorrectionItem.AmountsDec)
}

// optional string AdditionalInfo = 6;
inline bool InvoiceCorrectionItem::has_additionalinfo() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void InvoiceCorrectionItem::set_has_additionalinfo() {
  _has_bits_[0] |= 0x00000020u;
}
inline void InvoiceCorrectionItem::clear_has_additionalinfo() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void InvoiceCorrectionItem::clear_additionalinfo() {
  if (additionalinfo_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    additionalinfo_->clear();
  }
  clear_has_additionalinfo();
}
inline const ::std::string& InvoiceCorrectionItem::additionalinfo() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.InvoiceCorrectionItem.AdditionalInfo)
  return *additionalinfo_;
}
inline void InvoiceCorrectionItem::set_additionalinfo(const ::std::string& value) {
  set_has_additionalinfo();
  if (additionalinfo_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    additionalinfo_ = new ::std::string;
  }
  additionalinfo_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.InvoiceCorrectionItem.AdditionalInfo)
}
inline void InvoiceCorrectionItem::set_additionalinfo(const char* value) {
  set_has_additionalinfo();
  if (additionalinfo_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    additionalinfo_ = new ::std::string;
  }
  additionalinfo_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.InvoiceCorrectionItem.AdditionalInfo)
}
inline void InvoiceCorrectionItem::set_additionalinfo(const char* value, size_t size) {
  set_has_additionalinfo();
  if (additionalinfo_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    additionalinfo_ = new ::std::string;
  }
  additionalinfo_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.InvoiceCorrectionItem.AdditionalInfo)
}
inline ::std::string* InvoiceCorrectionItem::mutable_additionalinfo() {
  set_has_additionalinfo();
  if (additionalinfo_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    additionalinfo_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.InvoiceCorrectionItem.AdditionalInfo)
  return additionalinfo_;
}
inline ::std::string* InvoiceCorrectionItem::release_additionalinfo() {
  clear_has_additionalinfo();
  if (additionalinfo_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = additionalinfo_;
    additionalinfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void InvoiceCorrectionItem::set_allocated_additionalinfo(::std::string* additionalinfo) {
  if (additionalinfo_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete additionalinfo_;
  }
  if (additionalinfo) {
    set_has_additionalinfo();
    additionalinfo_ = additionalinfo;
  } else {
    clear_has_additionalinfo();
    additionalinfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.InvoiceCorrectionItem.AdditionalInfo)
}

// repeated .Diadoc.Api.Proto.Invoicing.AdditionalInfo AdditionalInfos = 7;
inline int InvoiceCorrectionItem::additionalinfos_size() const {
  return additionalinfos_.size();
}
inline void InvoiceCorrectionItem::clear_additionalinfos() {
  additionalinfos_.Clear();
}
inline const ::Diadoc::Api::Proto::Invoicing::AdditionalInfo& InvoiceCorrectionItem::additionalinfos(int index) const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.InvoiceCorrectionItem.AdditionalInfos)
  return additionalinfos_.Get(index);
}
inline ::Diadoc::Api::Proto::Invoicing::AdditionalInfo* InvoiceCorrectionItem::mutable_additionalinfos(int index) {
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.InvoiceCorrectionItem.AdditionalInfos)
  return additionalinfos_.Mutable(index);
}
inline ::Diadoc::Api::Proto::Invoicing::AdditionalInfo* InvoiceCorrectionItem::add_additionalinfos() {
  // @@protoc_insertion_point(field_add:Diadoc.Api.Proto.Invoicing.InvoiceCorrectionItem.AdditionalInfos)
  return additionalinfos_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::AdditionalInfo >&
InvoiceCorrectionItem::additionalinfos() const {
  // @@protoc_insertion_point(field_list:Diadoc.Api.Proto.Invoicing.InvoiceCorrectionItem.AdditionalInfos)
  return additionalinfos_;
}
inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::AdditionalInfo >*
InvoiceCorrectionItem::mutable_additionalinfos() {
  // @@protoc_insertion_point(field_mutable_list:Diadoc.Api.Proto.Invoicing.InvoiceCorrectionItem.AdditionalInfos)
  return &additionalinfos_;
}

// -------------------------------------------------------------------

// CorrectableInvoiceItemFields

// optional string Unit = 1;
inline bool CorrectableInvoiceItemFields::has_unit() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CorrectableInvoiceItemFields::set_has_unit() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CorrectableInvoiceItemFields::clear_has_unit() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CorrectableInvoiceItemFields::clear_unit() {
  if (unit_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    unit_->clear();
  }
  clear_has_unit();
}
inline const ::std::string& CorrectableInvoiceItemFields::unit() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.CorrectableInvoiceItemFields.Unit)
  return *unit_;
}
inline void CorrectableInvoiceItemFields::set_unit(const ::std::string& value) {
  set_has_unit();
  if (unit_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    unit_ = new ::std::string;
  }
  unit_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.CorrectableInvoiceItemFields.Unit)
}
inline void CorrectableInvoiceItemFields::set_unit(const char* value) {
  set_has_unit();
  if (unit_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    unit_ = new ::std::string;
  }
  unit_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.CorrectableInvoiceItemFields.Unit)
}
inline void CorrectableInvoiceItemFields::set_unit(const char* value, size_t size) {
  set_has_unit();
  if (unit_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    unit_ = new ::std::string;
  }
  unit_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.CorrectableInvoiceItemFields.Unit)
}
inline ::std::string* CorrectableInvoiceItemFields::mutable_unit() {
  set_has_unit();
  if (unit_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    unit_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.CorrectableInvoiceItemFields.Unit)
  return unit_;
}
inline ::std::string* CorrectableInvoiceItemFields::release_unit() {
  clear_has_unit();
  if (unit_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = unit_;
    unit_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CorrectableInvoiceItemFields::set_allocated_unit(::std::string* unit) {
  if (unit_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete unit_;
  }
  if (unit) {
    set_has_unit();
    unit_ = unit;
  } else {
    clear_has_unit();
    unit_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.CorrectableInvoiceItemFields.Unit)
}

// optional string Quantity = 2;
inline bool CorrectableInvoiceItemFields::has_quantity() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CorrectableInvoiceItemFields::set_has_quantity() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CorrectableInvoiceItemFields::clear_has_quantity() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CorrectableInvoiceItemFields::clear_quantity() {
  if (quantity_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    quantity_->clear();
  }
  clear_has_quantity();
}
inline const ::std::string& CorrectableInvoiceItemFields::quantity() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.CorrectableInvoiceItemFields.Quantity)
  return *quantity_;
}
inline void CorrectableInvoiceItemFields::set_quantity(const ::std::string& value) {
  set_has_quantity();
  if (quantity_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    quantity_ = new ::std::string;
  }
  quantity_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.CorrectableInvoiceItemFields.Quantity)
}
inline void CorrectableInvoiceItemFields::set_quantity(const char* value) {
  set_has_quantity();
  if (quantity_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    quantity_ = new ::std::string;
  }
  quantity_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.CorrectableInvoiceItemFields.Quantity)
}
inline void CorrectableInvoiceItemFields::set_quantity(const char* value, size_t size) {
  set_has_quantity();
  if (quantity_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    quantity_ = new ::std::string;
  }
  quantity_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.CorrectableInvoiceItemFields.Quantity)
}
inline ::std::string* CorrectableInvoiceItemFields::mutable_quantity() {
  set_has_quantity();
  if (quantity_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    quantity_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.CorrectableInvoiceItemFields.Quantity)
  return quantity_;
}
inline ::std::string* CorrectableInvoiceItemFields::release_quantity() {
  clear_has_quantity();
  if (quantity_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = quantity_;
    quantity_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CorrectableInvoiceItemFields::set_allocated_quantity(::std::string* quantity) {
  if (quantity_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete quantity_;
  }
  if (quantity) {
    set_has_quantity();
    quantity_ = quantity;
  } else {
    clear_has_quantity();
    quantity_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.CorrectableInvoiceItemFields.Quantity)
}

// optional string Price = 3;
inline bool CorrectableInvoiceItemFields::has_price() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CorrectableInvoiceItemFields::set_has_price() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CorrectableInvoiceItemFields::clear_has_price() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CorrectableInvoiceItemFields::clear_price() {
  if (price_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    price_->clear();
  }
  clear_has_price();
}
inline const ::std::string& CorrectableInvoiceItemFields::price() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.CorrectableInvoiceItemFields.Price)
  return *price_;
}
inline void CorrectableInvoiceItemFields::set_price(const ::std::string& value) {
  set_has_price();
  if (price_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    price_ = new ::std::string;
  }
  price_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.CorrectableInvoiceItemFields.Price)
}
inline void CorrectableInvoiceItemFields::set_price(const char* value) {
  set_has_price();
  if (price_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    price_ = new ::std::string;
  }
  price_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.CorrectableInvoiceItemFields.Price)
}
inline void CorrectableInvoiceItemFields::set_price(const char* value, size_t size) {
  set_has_price();
  if (price_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    price_ = new ::std::string;
  }
  price_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.CorrectableInvoiceItemFields.Price)
}
inline ::std::string* CorrectableInvoiceItemFields::mutable_price() {
  set_has_price();
  if (price_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    price_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.CorrectableInvoiceItemFields.Price)
  return price_;
}
inline ::std::string* CorrectableInvoiceItemFields::release_price() {
  clear_has_price();
  if (price_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = price_;
    price_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CorrectableInvoiceItemFields::set_allocated_price(::std::string* price) {
  if (price_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete price_;
  }
  if (price) {
    set_has_price();
    price_ = price;
  } else {
    clear_has_price();
    price_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.CorrectableInvoiceItemFields.Price)
}

// optional string Excise = 4;
inline bool CorrectableInvoiceItemFields::has_excise() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CorrectableInvoiceItemFields::set_has_excise() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CorrectableInvoiceItemFields::clear_has_excise() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CorrectableInvoiceItemFields::clear_excise() {
  if (excise_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    excise_->clear();
  }
  clear_has_excise();
}
inline const ::std::string& CorrectableInvoiceItemFields::excise() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.CorrectableInvoiceItemFields.Excise)
  return *excise_;
}
inline void CorrectableInvoiceItemFields::set_excise(const ::std::string& value) {
  set_has_excise();
  if (excise_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    excise_ = new ::std::string;
  }
  excise_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.CorrectableInvoiceItemFields.Excise)
}
inline void CorrectableInvoiceItemFields::set_excise(const char* value) {
  set_has_excise();
  if (excise_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    excise_ = new ::std::string;
  }
  excise_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.CorrectableInvoiceItemFields.Excise)
}
inline void CorrectableInvoiceItemFields::set_excise(const char* value, size_t size) {
  set_has_excise();
  if (excise_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    excise_ = new ::std::string;
  }
  excise_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.CorrectableInvoiceItemFields.Excise)
}
inline ::std::string* CorrectableInvoiceItemFields::mutable_excise() {
  set_has_excise();
  if (excise_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    excise_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.CorrectableInvoiceItemFields.Excise)
  return excise_;
}
inline ::std::string* CorrectableInvoiceItemFields::release_excise() {
  clear_has_excise();
  if (excise_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = excise_;
    excise_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CorrectableInvoiceItemFields::set_allocated_excise(::std::string* excise) {
  if (excise_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete excise_;
  }
  if (excise) {
    set_has_excise();
    excise_ = excise;
  } else {
    clear_has_excise();
    excise_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.CorrectableInvoiceItemFields.Excise)
}

// required .Diadoc.Api.Proto.Invoicing.TaxRate TaxRate = 5;
inline bool CorrectableInvoiceItemFields::has_taxrate() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CorrectableInvoiceItemFields::set_has_taxrate() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CorrectableInvoiceItemFields::clear_has_taxrate() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CorrectableInvoiceItemFields::clear_taxrate() {
  taxrate_ = 0;
  clear_has_taxrate();
}
inline ::Diadoc::Api::Proto::Invoicing::TaxRate CorrectableInvoiceItemFields::taxrate() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.CorrectableInvoiceItemFields.TaxRate)
  return static_cast< ::Diadoc::Api::Proto::Invoicing::TaxRate >(taxrate_);
}
inline void CorrectableInvoiceItemFields::set_taxrate(::Diadoc::Api::Proto::Invoicing::TaxRate value) {
  assert(::Diadoc::Api::Proto::Invoicing::TaxRate_IsValid(value));
  set_has_taxrate();
  taxrate_ = value;
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.CorrectableInvoiceItemFields.TaxRate)
}

// optional string SubtotalWithVatExcluded = 6;
inline bool CorrectableInvoiceItemFields::has_subtotalwithvatexcluded() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CorrectableInvoiceItemFields::set_has_subtotalwithvatexcluded() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CorrectableInvoiceItemFields::clear_has_subtotalwithvatexcluded() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CorrectableInvoiceItemFields::clear_subtotalwithvatexcluded() {
  if (subtotalwithvatexcluded_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    subtotalwithvatexcluded_->clear();
  }
  clear_has_subtotalwithvatexcluded();
}
inline const ::std::string& CorrectableInvoiceItemFields::subtotalwithvatexcluded() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.CorrectableInvoiceItemFields.SubtotalWithVatExcluded)
  return *subtotalwithvatexcluded_;
}
inline void CorrectableInvoiceItemFields::set_subtotalwithvatexcluded(const ::std::string& value) {
  set_has_subtotalwithvatexcluded();
  if (subtotalwithvatexcluded_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    subtotalwithvatexcluded_ = new ::std::string;
  }
  subtotalwithvatexcluded_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.CorrectableInvoiceItemFields.SubtotalWithVatExcluded)
}
inline void CorrectableInvoiceItemFields::set_subtotalwithvatexcluded(const char* value) {
  set_has_subtotalwithvatexcluded();
  if (subtotalwithvatexcluded_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    subtotalwithvatexcluded_ = new ::std::string;
  }
  subtotalwithvatexcluded_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.CorrectableInvoiceItemFields.SubtotalWithVatExcluded)
}
inline void CorrectableInvoiceItemFields::set_subtotalwithvatexcluded(const char* value, size_t size) {
  set_has_subtotalwithvatexcluded();
  if (subtotalwithvatexcluded_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    subtotalwithvatexcluded_ = new ::std::string;
  }
  subtotalwithvatexcluded_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.CorrectableInvoiceItemFields.SubtotalWithVatExcluded)
}
inline ::std::string* CorrectableInvoiceItemFields::mutable_subtotalwithvatexcluded() {
  set_has_subtotalwithvatexcluded();
  if (subtotalwithvatexcluded_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    subtotalwithvatexcluded_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.CorrectableInvoiceItemFields.SubtotalWithVatExcluded)
  return subtotalwithvatexcluded_;
}
inline ::std::string* CorrectableInvoiceItemFields::release_subtotalwithvatexcluded() {
  clear_has_subtotalwithvatexcluded();
  if (subtotalwithvatexcluded_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = subtotalwithvatexcluded_;
    subtotalwithvatexcluded_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CorrectableInvoiceItemFields::set_allocated_subtotalwithvatexcluded(::std::string* subtotalwithvatexcluded) {
  if (subtotalwithvatexcluded_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete subtotalwithvatexcluded_;
  }
  if (subtotalwithvatexcluded) {
    set_has_subtotalwithvatexcluded();
    subtotalwithvatexcluded_ = subtotalwithvatexcluded;
  } else {
    clear_has_subtotalwithvatexcluded();
    subtotalwithvatexcluded_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.CorrectableInvoiceItemFields.SubtotalWithVatExcluded)
}

// optional string Vat = 7;
inline bool CorrectableInvoiceItemFields::has_vat() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CorrectableInvoiceItemFields::set_has_vat() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CorrectableInvoiceItemFields::clear_has_vat() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CorrectableInvoiceItemFields::clear_vat() {
  if (vat_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vat_->clear();
  }
  clear_has_vat();
}
inline const ::std::string& CorrectableInvoiceItemFields::vat() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.CorrectableInvoiceItemFields.Vat)
  return *vat_;
}
inline void CorrectableInvoiceItemFields::set_vat(const ::std::string& value) {
  set_has_vat();
  if (vat_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vat_ = new ::std::string;
  }
  vat_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.CorrectableInvoiceItemFields.Vat)
}
inline void CorrectableInvoiceItemFields::set_vat(const char* value) {
  set_has_vat();
  if (vat_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vat_ = new ::std::string;
  }
  vat_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.CorrectableInvoiceItemFields.Vat)
}
inline void CorrectableInvoiceItemFields::set_vat(const char* value, size_t size) {
  set_has_vat();
  if (vat_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vat_ = new ::std::string;
  }
  vat_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.CorrectableInvoiceItemFields.Vat)
}
inline ::std::string* CorrectableInvoiceItemFields::mutable_vat() {
  set_has_vat();
  if (vat_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vat_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.CorrectableInvoiceItemFields.Vat)
  return vat_;
}
inline ::std::string* CorrectableInvoiceItemFields::release_vat() {
  clear_has_vat();
  if (vat_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = vat_;
    vat_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CorrectableInvoiceItemFields::set_allocated_vat(::std::string* vat) {
  if (vat_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete vat_;
  }
  if (vat) {
    set_has_vat();
    vat_ = vat;
  } else {
    clear_has_vat();
    vat_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.CorrectableInvoiceItemFields.Vat)
}

// required string Subtotal = 8;
inline bool CorrectableInvoiceItemFields::has_subtotal() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CorrectableInvoiceItemFields::set_has_subtotal() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CorrectableInvoiceItemFields::clear_has_subtotal() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CorrectableInvoiceItemFields::clear_subtotal() {
  if (subtotal_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    subtotal_->clear();
  }
  clear_has_subtotal();
}
inline const ::std::string& CorrectableInvoiceItemFields::subtotal() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.CorrectableInvoiceItemFields.Subtotal)
  return *subtotal_;
}
inline void CorrectableInvoiceItemFields::set_subtotal(const ::std::string& value) {
  set_has_subtotal();
  if (subtotal_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    subtotal_ = new ::std::string;
  }
  subtotal_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.CorrectableInvoiceItemFields.Subtotal)
}
inline void CorrectableInvoiceItemFields::set_subtotal(const char* value) {
  set_has_subtotal();
  if (subtotal_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    subtotal_ = new ::std::string;
  }
  subtotal_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.CorrectableInvoiceItemFields.Subtotal)
}
inline void CorrectableInvoiceItemFields::set_subtotal(const char* value, size_t size) {
  set_has_subtotal();
  if (subtotal_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    subtotal_ = new ::std::string;
  }
  subtotal_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.CorrectableInvoiceItemFields.Subtotal)
}
inline ::std::string* CorrectableInvoiceItemFields::mutable_subtotal() {
  set_has_subtotal();
  if (subtotal_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    subtotal_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.CorrectableInvoiceItemFields.Subtotal)
  return subtotal_;
}
inline ::std::string* CorrectableInvoiceItemFields::release_subtotal() {
  clear_has_subtotal();
  if (subtotal_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = subtotal_;
    subtotal_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CorrectableInvoiceItemFields::set_allocated_subtotal(::std::string* subtotal) {
  if (subtotal_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete subtotal_;
  }
  if (subtotal) {
    set_has_subtotal();
    subtotal_ = subtotal;
  } else {
    clear_has_subtotal();
    subtotal_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.CorrectableInvoiceItemFields.Subtotal)
}

// -------------------------------------------------------------------

// InvoiceItemAmountsDiff

// optional string Excise = 1;
inline bool InvoiceItemAmountsDiff::has_excise() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InvoiceItemAmountsDiff::set_has_excise() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InvoiceItemAmountsDiff::clear_has_excise() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InvoiceItemAmountsDiff::clear_excise() {
  if (excise_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    excise_->clear();
  }
  clear_has_excise();
}
inline const ::std::string& InvoiceItemAmountsDiff::excise() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.InvoiceItemAmountsDiff.Excise)
  return *excise_;
}
inline void InvoiceItemAmountsDiff::set_excise(const ::std::string& value) {
  set_has_excise();
  if (excise_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    excise_ = new ::std::string;
  }
  excise_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.InvoiceItemAmountsDiff.Excise)
}
inline void InvoiceItemAmountsDiff::set_excise(const char* value) {
  set_has_excise();
  if (excise_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    excise_ = new ::std::string;
  }
  excise_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.InvoiceItemAmountsDiff.Excise)
}
inline void InvoiceItemAmountsDiff::set_excise(const char* value, size_t size) {
  set_has_excise();
  if (excise_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    excise_ = new ::std::string;
  }
  excise_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.InvoiceItemAmountsDiff.Excise)
}
inline ::std::string* InvoiceItemAmountsDiff::mutable_excise() {
  set_has_excise();
  if (excise_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    excise_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.InvoiceItemAmountsDiff.Excise)
  return excise_;
}
inline ::std::string* InvoiceItemAmountsDiff::release_excise() {
  clear_has_excise();
  if (excise_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = excise_;
    excise_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void InvoiceItemAmountsDiff::set_allocated_excise(::std::string* excise) {
  if (excise_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete excise_;
  }
  if (excise) {
    set_has_excise();
    excise_ = excise;
  } else {
    clear_has_excise();
    excise_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.InvoiceItemAmountsDiff.Excise)
}

// optional string SubtotalWithVatExcluded = 2;
inline bool InvoiceItemAmountsDiff::has_subtotalwithvatexcluded() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InvoiceItemAmountsDiff::set_has_subtotalwithvatexcluded() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InvoiceItemAmountsDiff::clear_has_subtotalwithvatexcluded() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InvoiceItemAmountsDiff::clear_subtotalwithvatexcluded() {
  if (subtotalwithvatexcluded_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    subtotalwithvatexcluded_->clear();
  }
  clear_has_subtotalwithvatexcluded();
}
inline const ::std::string& InvoiceItemAmountsDiff::subtotalwithvatexcluded() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.InvoiceItemAmountsDiff.SubtotalWithVatExcluded)
  return *subtotalwithvatexcluded_;
}
inline void InvoiceItemAmountsDiff::set_subtotalwithvatexcluded(const ::std::string& value) {
  set_has_subtotalwithvatexcluded();
  if (subtotalwithvatexcluded_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    subtotalwithvatexcluded_ = new ::std::string;
  }
  subtotalwithvatexcluded_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.InvoiceItemAmountsDiff.SubtotalWithVatExcluded)
}
inline void InvoiceItemAmountsDiff::set_subtotalwithvatexcluded(const char* value) {
  set_has_subtotalwithvatexcluded();
  if (subtotalwithvatexcluded_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    subtotalwithvatexcluded_ = new ::std::string;
  }
  subtotalwithvatexcluded_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.InvoiceItemAmountsDiff.SubtotalWithVatExcluded)
}
inline void InvoiceItemAmountsDiff::set_subtotalwithvatexcluded(const char* value, size_t size) {
  set_has_subtotalwithvatexcluded();
  if (subtotalwithvatexcluded_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    subtotalwithvatexcluded_ = new ::std::string;
  }
  subtotalwithvatexcluded_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.InvoiceItemAmountsDiff.SubtotalWithVatExcluded)
}
inline ::std::string* InvoiceItemAmountsDiff::mutable_subtotalwithvatexcluded() {
  set_has_subtotalwithvatexcluded();
  if (subtotalwithvatexcluded_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    subtotalwithvatexcluded_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.InvoiceItemAmountsDiff.SubtotalWithVatExcluded)
  return subtotalwithvatexcluded_;
}
inline ::std::string* InvoiceItemAmountsDiff::release_subtotalwithvatexcluded() {
  clear_has_subtotalwithvatexcluded();
  if (subtotalwithvatexcluded_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = subtotalwithvatexcluded_;
    subtotalwithvatexcluded_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void InvoiceItemAmountsDiff::set_allocated_subtotalwithvatexcluded(::std::string* subtotalwithvatexcluded) {
  if (subtotalwithvatexcluded_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete subtotalwithvatexcluded_;
  }
  if (subtotalwithvatexcluded) {
    set_has_subtotalwithvatexcluded();
    subtotalwithvatexcluded_ = subtotalwithvatexcluded;
  } else {
    clear_has_subtotalwithvatexcluded();
    subtotalwithvatexcluded_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.InvoiceItemAmountsDiff.SubtotalWithVatExcluded)
}

// optional string Vat = 3;
inline bool InvoiceItemAmountsDiff::has_vat() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InvoiceItemAmountsDiff::set_has_vat() {
  _has_bits_[0] |= 0x00000004u;
}
inline void InvoiceItemAmountsDiff::clear_has_vat() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void InvoiceItemAmountsDiff::clear_vat() {
  if (vat_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vat_->clear();
  }
  clear_has_vat();
}
inline const ::std::string& InvoiceItemAmountsDiff::vat() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.InvoiceItemAmountsDiff.Vat)
  return *vat_;
}
inline void InvoiceItemAmountsDiff::set_vat(const ::std::string& value) {
  set_has_vat();
  if (vat_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vat_ = new ::std::string;
  }
  vat_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.InvoiceItemAmountsDiff.Vat)
}
inline void InvoiceItemAmountsDiff::set_vat(const char* value) {
  set_has_vat();
  if (vat_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vat_ = new ::std::string;
  }
  vat_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.InvoiceItemAmountsDiff.Vat)
}
inline void InvoiceItemAmountsDiff::set_vat(const char* value, size_t size) {
  set_has_vat();
  if (vat_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vat_ = new ::std::string;
  }
  vat_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.InvoiceItemAmountsDiff.Vat)
}
inline ::std::string* InvoiceItemAmountsDiff::mutable_vat() {
  set_has_vat();
  if (vat_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vat_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.InvoiceItemAmountsDiff.Vat)
  return vat_;
}
inline ::std::string* InvoiceItemAmountsDiff::release_vat() {
  clear_has_vat();
  if (vat_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = vat_;
    vat_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void InvoiceItemAmountsDiff::set_allocated_vat(::std::string* vat) {
  if (vat_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete vat_;
  }
  if (vat) {
    set_has_vat();
    vat_ = vat;
  } else {
    clear_has_vat();
    vat_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.InvoiceItemAmountsDiff.Vat)
}

// optional string Subtotal = 4;
inline bool InvoiceItemAmountsDiff::has_subtotal() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void InvoiceItemAmountsDiff::set_has_subtotal() {
  _has_bits_[0] |= 0x00000008u;
}
inline void InvoiceItemAmountsDiff::clear_has_subtotal() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void InvoiceItemAmountsDiff::clear_subtotal() {
  if (subtotal_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    subtotal_->clear();
  }
  clear_has_subtotal();
}
inline const ::std::string& InvoiceItemAmountsDiff::subtotal() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.InvoiceItemAmountsDiff.Subtotal)
  return *subtotal_;
}
inline void InvoiceItemAmountsDiff::set_subtotal(const ::std::string& value) {
  set_has_subtotal();
  if (subtotal_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    subtotal_ = new ::std::string;
  }
  subtotal_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.InvoiceItemAmountsDiff.Subtotal)
}
inline void InvoiceItemAmountsDiff::set_subtotal(const char* value) {
  set_has_subtotal();
  if (subtotal_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    subtotal_ = new ::std::string;
  }
  subtotal_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.InvoiceItemAmountsDiff.Subtotal)
}
inline void InvoiceItemAmountsDiff::set_subtotal(const char* value, size_t size) {
  set_has_subtotal();
  if (subtotal_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    subtotal_ = new ::std::string;
  }
  subtotal_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.InvoiceItemAmountsDiff.Subtotal)
}
inline ::std::string* InvoiceItemAmountsDiff::mutable_subtotal() {
  set_has_subtotal();
  if (subtotal_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    subtotal_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.InvoiceItemAmountsDiff.Subtotal)
  return subtotal_;
}
inline ::std::string* InvoiceItemAmountsDiff::release_subtotal() {
  clear_has_subtotal();
  if (subtotal_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = subtotal_;
    subtotal_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void InvoiceItemAmountsDiff::set_allocated_subtotal(::std::string* subtotal) {
  if (subtotal_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete subtotal_;
  }
  if (subtotal) {
    set_has_subtotal();
    subtotal_ = subtotal;
  } else {
    clear_has_subtotal();
    subtotal_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.InvoiceItemAmountsDiff.Subtotal)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace Invoicing
}  // namespace Proto
}  // namespace Api
}  // namespace Diadoc

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::Diadoc::Api::Proto::Invoicing::InvoiceFormatVersion> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Diadoc::Api::Proto::Invoicing::InvoiceFormatVersion>() {
  return ::Diadoc::Api::Proto::Invoicing::InvoiceFormatVersion_descriptor();
}
template <> struct is_proto_enum< ::Diadoc::Api::Proto::Invoicing::TaxRate> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Diadoc::Api::Proto::Invoicing::TaxRate>() {
  return ::Diadoc::Api::Proto::Invoicing::TaxRate_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_Invoicing_2fInvoiceInfo_2eproto__INCLUDED
