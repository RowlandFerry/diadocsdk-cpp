// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Invoicing/OrganizationInfo.proto

#ifndef PROTOBUF_Invoicing_2fOrganizationInfo_2eproto__INCLUDED
#define PROTOBUF_Invoicing_2fOrganizationInfo_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include "Address.pb.h"
// @@protoc_insertion_point(includes)

namespace Diadoc {
namespace Api {
namespace Proto {
namespace Invoicing {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_Invoicing_2fOrganizationInfo_2eproto();
void protobuf_AssignDesc_Invoicing_2fOrganizationInfo_2eproto();
void protobuf_ShutdownFile_Invoicing_2fOrganizationInfo_2eproto();

class DocflowParticipant;
class DiadocOrganizationInfo;
class OrganizationInfo;

// ===================================================================

class DocflowParticipant : public ::google::protobuf::Message {
 public:
  DocflowParticipant();
  virtual ~DocflowParticipant();

  DocflowParticipant(const DocflowParticipant& from);

  inline DocflowParticipant& operator=(const DocflowParticipant& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DocflowParticipant& default_instance();

  void Swap(DocflowParticipant* other);

  // implements Message ----------------------------------------------

  DocflowParticipant* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DocflowParticipant& from);
  void MergeFrom(const DocflowParticipant& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string BoxId = 1;
  inline bool has_boxid() const;
  inline void clear_boxid();
  static const int kBoxIdFieldNumber = 1;
  inline const ::std::string& boxid() const;
  inline void set_boxid(const ::std::string& value);
  inline void set_boxid(const char* value);
  inline void set_boxid(const char* value, size_t size);
  inline ::std::string* mutable_boxid();
  inline ::std::string* release_boxid();
  inline void set_allocated_boxid(::std::string* boxid);

  // optional string Inn = 2;
  inline bool has_inn() const;
  inline void clear_inn();
  static const int kInnFieldNumber = 2;
  inline const ::std::string& inn() const;
  inline void set_inn(const ::std::string& value);
  inline void set_inn(const char* value);
  inline void set_inn(const char* value, size_t size);
  inline ::std::string* mutable_inn();
  inline ::std::string* release_inn();
  inline void set_allocated_inn(::std::string* inn);

  // optional string Kpp = 3;
  inline bool has_kpp() const;
  inline void clear_kpp();
  static const int kKppFieldNumber = 3;
  inline const ::std::string& kpp() const;
  inline void set_kpp(const ::std::string& value);
  inline void set_kpp(const char* value);
  inline void set_kpp(const char* value, size_t size);
  inline ::std::string* mutable_kpp();
  inline ::std::string* release_kpp();
  inline void set_allocated_kpp(::std::string* kpp);

  // optional string FnsParticipantId = 4;
  inline bool has_fnsparticipantid() const;
  inline void clear_fnsparticipantid();
  static const int kFnsParticipantIdFieldNumber = 4;
  inline const ::std::string& fnsparticipantid() const;
  inline void set_fnsparticipantid(const ::std::string& value);
  inline void set_fnsparticipantid(const char* value);
  inline void set_fnsparticipantid(const char* value, size_t size);
  inline ::std::string* mutable_fnsparticipantid();
  inline ::std::string* release_fnsparticipantid();
  inline void set_allocated_fnsparticipantid(::std::string* fnsparticipantid);

  // @@protoc_insertion_point(class_scope:Diadoc.Api.Proto.Invoicing.DocflowParticipant)
 private:
  inline void set_has_boxid();
  inline void clear_has_boxid();
  inline void set_has_inn();
  inline void clear_has_inn();
  inline void set_has_kpp();
  inline void clear_has_kpp();
  inline void set_has_fnsparticipantid();
  inline void clear_has_fnsparticipantid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* boxid_;
  ::std::string* inn_;
  ::std::string* kpp_;
  ::std::string* fnsparticipantid_;
  friend void  protobuf_AddDesc_Invoicing_2fOrganizationInfo_2eproto();
  friend void protobuf_AssignDesc_Invoicing_2fOrganizationInfo_2eproto();
  friend void protobuf_ShutdownFile_Invoicing_2fOrganizationInfo_2eproto();

  void InitAsDefaultInstance();
  static DocflowParticipant* default_instance_;
};
// -------------------------------------------------------------------

class DiadocOrganizationInfo : public ::google::protobuf::Message {
 public:
  DiadocOrganizationInfo();
  virtual ~DiadocOrganizationInfo();

  DiadocOrganizationInfo(const DiadocOrganizationInfo& from);

  inline DiadocOrganizationInfo& operator=(const DiadocOrganizationInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DiadocOrganizationInfo& default_instance();

  void Swap(DiadocOrganizationInfo* other);

  // implements Message ----------------------------------------------

  DiadocOrganizationInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DiadocOrganizationInfo& from);
  void MergeFrom(const DiadocOrganizationInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string BoxId = 1;
  inline bool has_boxid() const;
  inline void clear_boxid();
  static const int kBoxIdFieldNumber = 1;
  inline const ::std::string& boxid() const;
  inline void set_boxid(const ::std::string& value);
  inline void set_boxid(const char* value);
  inline void set_boxid(const char* value, size_t size);
  inline ::std::string* mutable_boxid();
  inline ::std::string* release_boxid();
  inline void set_allocated_boxid(::std::string* boxid);

  // optional .Diadoc.Api.Proto.Invoicing.OrganizationInfo OrgInfo = 2;
  inline bool has_orginfo() const;
  inline void clear_orginfo();
  static const int kOrgInfoFieldNumber = 2;
  inline const ::Diadoc::Api::Proto::Invoicing::OrganizationInfo& orginfo() const;
  inline ::Diadoc::Api::Proto::Invoicing::OrganizationInfo* mutable_orginfo();
  inline ::Diadoc::Api::Proto::Invoicing::OrganizationInfo* release_orginfo();
  inline void set_allocated_orginfo(::Diadoc::Api::Proto::Invoicing::OrganizationInfo* orginfo);

  // @@protoc_insertion_point(class_scope:Diadoc.Api.Proto.Invoicing.DiadocOrganizationInfo)
 private:
  inline void set_has_boxid();
  inline void clear_has_boxid();
  inline void set_has_orginfo();
  inline void clear_has_orginfo();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* boxid_;
  ::Diadoc::Api::Proto::Invoicing::OrganizationInfo* orginfo_;
  friend void  protobuf_AddDesc_Invoicing_2fOrganizationInfo_2eproto();
  friend void protobuf_AssignDesc_Invoicing_2fOrganizationInfo_2eproto();
  friend void protobuf_ShutdownFile_Invoicing_2fOrganizationInfo_2eproto();

  void InitAsDefaultInstance();
  static DiadocOrganizationInfo* default_instance_;
};
// -------------------------------------------------------------------

class OrganizationInfo : public ::google::protobuf::Message {
 public:
  OrganizationInfo();
  virtual ~OrganizationInfo();

  OrganizationInfo(const OrganizationInfo& from);

  inline OrganizationInfo& operator=(const OrganizationInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OrganizationInfo& default_instance();

  void Swap(OrganizationInfo* other);

  // implements Message ----------------------------------------------

  OrganizationInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OrganizationInfo& from);
  void MergeFrom(const OrganizationInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string Name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string Inn = 2;
  inline bool has_inn() const;
  inline void clear_inn();
  static const int kInnFieldNumber = 2;
  inline const ::std::string& inn() const;
  inline void set_inn(const ::std::string& value);
  inline void set_inn(const char* value);
  inline void set_inn(const char* value, size_t size);
  inline ::std::string* mutable_inn();
  inline ::std::string* release_inn();
  inline void set_allocated_inn(::std::string* inn);

  // optional string Kpp = 3;
  inline bool has_kpp() const;
  inline void clear_kpp();
  static const int kKppFieldNumber = 3;
  inline const ::std::string& kpp() const;
  inline void set_kpp(const ::std::string& value);
  inline void set_kpp(const char* value);
  inline void set_kpp(const char* value, size_t size);
  inline ::std::string* mutable_kpp();
  inline ::std::string* release_kpp();
  inline void set_allocated_kpp(::std::string* kpp);

  // required .Diadoc.Api.Proto.Address Address = 4;
  inline bool has_address() const;
  inline void clear_address();
  static const int kAddressFieldNumber = 4;
  inline const ::Diadoc::Api::Proto::Address& address() const;
  inline ::Diadoc::Api::Proto::Address* mutable_address();
  inline ::Diadoc::Api::Proto::Address* release_address();
  inline void set_allocated_address(::Diadoc::Api::Proto::Address* address);

  // optional bool IsSoleProprietor = 5 [default = false];
  inline bool has_issoleproprietor() const;
  inline void clear_issoleproprietor();
  static const int kIsSoleProprietorFieldNumber = 5;
  inline bool issoleproprietor() const;
  inline void set_issoleproprietor(bool value);

  // optional string Okopf = 6;
  inline bool has_okopf() const;
  inline void clear_okopf();
  static const int kOkopfFieldNumber = 6;
  inline const ::std::string& okopf() const;
  inline void set_okopf(const ::std::string& value);
  inline void set_okopf(const char* value);
  inline void set_okopf(const char* value, size_t size);
  inline ::std::string* mutable_okopf();
  inline ::std::string* release_okopf();
  inline void set_allocated_okopf(::std::string* okopf);

  // optional string Okpo = 7;
  inline bool has_okpo() const;
  inline void clear_okpo();
  static const int kOkpoFieldNumber = 7;
  inline const ::std::string& okpo() const;
  inline void set_okpo(const ::std::string& value);
  inline void set_okpo(const char* value);
  inline void set_okpo(const char* value, size_t size);
  inline ::std::string* mutable_okpo();
  inline ::std::string* release_okpo();
  inline void set_allocated_okpo(::std::string* okpo);

  // optional string Okdp = 8;
  inline bool has_okdp() const;
  inline void clear_okdp();
  static const int kOkdpFieldNumber = 8;
  inline const ::std::string& okdp() const;
  inline void set_okdp(const ::std::string& value);
  inline void set_okdp(const char* value);
  inline void set_okdp(const char* value, size_t size);
  inline ::std::string* mutable_okdp();
  inline ::std::string* release_okdp();
  inline void set_allocated_okdp(::std::string* okdp);

  // optional string Phone = 9;
  inline bool has_phone() const;
  inline void clear_phone();
  static const int kPhoneFieldNumber = 9;
  inline const ::std::string& phone() const;
  inline void set_phone(const ::std::string& value);
  inline void set_phone(const char* value);
  inline void set_phone(const char* value, size_t size);
  inline ::std::string* mutable_phone();
  inline ::std::string* release_phone();
  inline void set_allocated_phone(::std::string* phone);

  // optional string Fax = 10;
  inline bool has_fax() const;
  inline void clear_fax();
  static const int kFaxFieldNumber = 10;
  inline const ::std::string& fax() const;
  inline void set_fax(const ::std::string& value);
  inline void set_fax(const char* value);
  inline void set_fax(const char* value, size_t size);
  inline ::std::string* mutable_fax();
  inline ::std::string* release_fax();
  inline void set_allocated_fax(::std::string* fax);

  // optional string BankAccountNumber = 11;
  inline bool has_bankaccountnumber() const;
  inline void clear_bankaccountnumber();
  static const int kBankAccountNumberFieldNumber = 11;
  inline const ::std::string& bankaccountnumber() const;
  inline void set_bankaccountnumber(const ::std::string& value);
  inline void set_bankaccountnumber(const char* value);
  inline void set_bankaccountnumber(const char* value, size_t size);
  inline ::std::string* mutable_bankaccountnumber();
  inline ::std::string* release_bankaccountnumber();
  inline void set_allocated_bankaccountnumber(::std::string* bankaccountnumber);

  // optional string BankName = 12;
  inline bool has_bankname() const;
  inline void clear_bankname();
  static const int kBankNameFieldNumber = 12;
  inline const ::std::string& bankname() const;
  inline void set_bankname(const ::std::string& value);
  inline void set_bankname(const char* value);
  inline void set_bankname(const char* value, size_t size);
  inline ::std::string* mutable_bankname();
  inline ::std::string* release_bankname();
  inline void set_allocated_bankname(::std::string* bankname);

  // optional string BankId = 13;
  inline bool has_bankid() const;
  inline void clear_bankid();
  static const int kBankIdFieldNumber = 13;
  inline const ::std::string& bankid() const;
  inline void set_bankid(const ::std::string& value);
  inline void set_bankid(const char* value);
  inline void set_bankid(const char* value, size_t size);
  inline ::std::string* mutable_bankid();
  inline ::std::string* release_bankid();
  inline void set_allocated_bankid(::std::string* bankid);

  // optional string Department = 14;
  inline bool has_department() const;
  inline void clear_department();
  static const int kDepartmentFieldNumber = 14;
  inline const ::std::string& department() const;
  inline void set_department(const ::std::string& value);
  inline void set_department(const char* value);
  inline void set_department(const char* value, size_t size);
  inline ::std::string* mutable_department();
  inline ::std::string* release_department();
  inline void set_allocated_department(::std::string* department);

  // optional string FnsParticipantId = 15;
  inline bool has_fnsparticipantid() const;
  inline void clear_fnsparticipantid();
  static const int kFnsParticipantIdFieldNumber = 15;
  inline const ::std::string& fnsparticipantid() const;
  inline void set_fnsparticipantid(const ::std::string& value);
  inline void set_fnsparticipantid(const char* value);
  inline void set_fnsparticipantid(const char* value, size_t size);
  inline ::std::string* mutable_fnsparticipantid();
  inline ::std::string* release_fnsparticipantid();
  inline void set_allocated_fnsparticipantid(::std::string* fnsparticipantid);

  // @@protoc_insertion_point(class_scope:Diadoc.Api.Proto.Invoicing.OrganizationInfo)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_inn();
  inline void clear_has_inn();
  inline void set_has_kpp();
  inline void clear_has_kpp();
  inline void set_has_address();
  inline void clear_has_address();
  inline void set_has_issoleproprietor();
  inline void clear_has_issoleproprietor();
  inline void set_has_okopf();
  inline void clear_has_okopf();
  inline void set_has_okpo();
  inline void clear_has_okpo();
  inline void set_has_okdp();
  inline void clear_has_okdp();
  inline void set_has_phone();
  inline void clear_has_phone();
  inline void set_has_fax();
  inline void clear_has_fax();
  inline void set_has_bankaccountnumber();
  inline void clear_has_bankaccountnumber();
  inline void set_has_bankname();
  inline void clear_has_bankname();
  inline void set_has_bankid();
  inline void clear_has_bankid();
  inline void set_has_department();
  inline void clear_has_department();
  inline void set_has_fnsparticipantid();
  inline void clear_has_fnsparticipantid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::std::string* inn_;
  ::std::string* kpp_;
  ::Diadoc::Api::Proto::Address* address_;
  ::std::string* okopf_;
  ::std::string* okpo_;
  ::std::string* okdp_;
  ::std::string* phone_;
  ::std::string* fax_;
  ::std::string* bankaccountnumber_;
  ::std::string* bankname_;
  ::std::string* bankid_;
  ::std::string* department_;
  ::std::string* fnsparticipantid_;
  bool issoleproprietor_;
  friend void  protobuf_AddDesc_Invoicing_2fOrganizationInfo_2eproto();
  friend void protobuf_AssignDesc_Invoicing_2fOrganizationInfo_2eproto();
  friend void protobuf_ShutdownFile_Invoicing_2fOrganizationInfo_2eproto();

  void InitAsDefaultInstance();
  static OrganizationInfo* default_instance_;
};
// ===================================================================


// ===================================================================

// DocflowParticipant

// optional string BoxId = 1;
inline bool DocflowParticipant::has_boxid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DocflowParticipant::set_has_boxid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DocflowParticipant::clear_has_boxid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DocflowParticipant::clear_boxid() {
  if (boxid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    boxid_->clear();
  }
  clear_has_boxid();
}
inline const ::std::string& DocflowParticipant::boxid() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.DocflowParticipant.BoxId)
  return *boxid_;
}
inline void DocflowParticipant::set_boxid(const ::std::string& value) {
  set_has_boxid();
  if (boxid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    boxid_ = new ::std::string;
  }
  boxid_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.DocflowParticipant.BoxId)
}
inline void DocflowParticipant::set_boxid(const char* value) {
  set_has_boxid();
  if (boxid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    boxid_ = new ::std::string;
  }
  boxid_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.DocflowParticipant.BoxId)
}
inline void DocflowParticipant::set_boxid(const char* value, size_t size) {
  set_has_boxid();
  if (boxid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    boxid_ = new ::std::string;
  }
  boxid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.DocflowParticipant.BoxId)
}
inline ::std::string* DocflowParticipant::mutable_boxid() {
  set_has_boxid();
  if (boxid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    boxid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.DocflowParticipant.BoxId)
  return boxid_;
}
inline ::std::string* DocflowParticipant::release_boxid() {
  clear_has_boxid();
  if (boxid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = boxid_;
    boxid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void DocflowParticipant::set_allocated_boxid(::std::string* boxid) {
  if (boxid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete boxid_;
  }
  if (boxid) {
    set_has_boxid();
    boxid_ = boxid;
  } else {
    clear_has_boxid();
    boxid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.DocflowParticipant.BoxId)
}

// optional string Inn = 2;
inline bool DocflowParticipant::has_inn() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DocflowParticipant::set_has_inn() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DocflowParticipant::clear_has_inn() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DocflowParticipant::clear_inn() {
  if (inn_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    inn_->clear();
  }
  clear_has_inn();
}
inline const ::std::string& DocflowParticipant::inn() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.DocflowParticipant.Inn)
  return *inn_;
}
inline void DocflowParticipant::set_inn(const ::std::string& value) {
  set_has_inn();
  if (inn_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    inn_ = new ::std::string;
  }
  inn_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.DocflowParticipant.Inn)
}
inline void DocflowParticipant::set_inn(const char* value) {
  set_has_inn();
  if (inn_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    inn_ = new ::std::string;
  }
  inn_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.DocflowParticipant.Inn)
}
inline void DocflowParticipant::set_inn(const char* value, size_t size) {
  set_has_inn();
  if (inn_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    inn_ = new ::std::string;
  }
  inn_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.DocflowParticipant.Inn)
}
inline ::std::string* DocflowParticipant::mutable_inn() {
  set_has_inn();
  if (inn_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    inn_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.DocflowParticipant.Inn)
  return inn_;
}
inline ::std::string* DocflowParticipant::release_inn() {
  clear_has_inn();
  if (inn_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = inn_;
    inn_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void DocflowParticipant::set_allocated_inn(::std::string* inn) {
  if (inn_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete inn_;
  }
  if (inn) {
    set_has_inn();
    inn_ = inn;
  } else {
    clear_has_inn();
    inn_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.DocflowParticipant.Inn)
}

// optional string Kpp = 3;
inline bool DocflowParticipant::has_kpp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DocflowParticipant::set_has_kpp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DocflowParticipant::clear_has_kpp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DocflowParticipant::clear_kpp() {
  if (kpp_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    kpp_->clear();
  }
  clear_has_kpp();
}
inline const ::std::string& DocflowParticipant::kpp() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.DocflowParticipant.Kpp)
  return *kpp_;
}
inline void DocflowParticipant::set_kpp(const ::std::string& value) {
  set_has_kpp();
  if (kpp_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    kpp_ = new ::std::string;
  }
  kpp_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.DocflowParticipant.Kpp)
}
inline void DocflowParticipant::set_kpp(const char* value) {
  set_has_kpp();
  if (kpp_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    kpp_ = new ::std::string;
  }
  kpp_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.DocflowParticipant.Kpp)
}
inline void DocflowParticipant::set_kpp(const char* value, size_t size) {
  set_has_kpp();
  if (kpp_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    kpp_ = new ::std::string;
  }
  kpp_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.DocflowParticipant.Kpp)
}
inline ::std::string* DocflowParticipant::mutable_kpp() {
  set_has_kpp();
  if (kpp_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    kpp_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.DocflowParticipant.Kpp)
  return kpp_;
}
inline ::std::string* DocflowParticipant::release_kpp() {
  clear_has_kpp();
  if (kpp_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = kpp_;
    kpp_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void DocflowParticipant::set_allocated_kpp(::std::string* kpp) {
  if (kpp_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete kpp_;
  }
  if (kpp) {
    set_has_kpp();
    kpp_ = kpp;
  } else {
    clear_has_kpp();
    kpp_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.DocflowParticipant.Kpp)
}

// optional string FnsParticipantId = 4;
inline bool DocflowParticipant::has_fnsparticipantid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DocflowParticipant::set_has_fnsparticipantid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DocflowParticipant::clear_has_fnsparticipantid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DocflowParticipant::clear_fnsparticipantid() {
  if (fnsparticipantid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fnsparticipantid_->clear();
  }
  clear_has_fnsparticipantid();
}
inline const ::std::string& DocflowParticipant::fnsparticipantid() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.DocflowParticipant.FnsParticipantId)
  return *fnsparticipantid_;
}
inline void DocflowParticipant::set_fnsparticipantid(const ::std::string& value) {
  set_has_fnsparticipantid();
  if (fnsparticipantid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fnsparticipantid_ = new ::std::string;
  }
  fnsparticipantid_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.DocflowParticipant.FnsParticipantId)
}
inline void DocflowParticipant::set_fnsparticipantid(const char* value) {
  set_has_fnsparticipantid();
  if (fnsparticipantid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fnsparticipantid_ = new ::std::string;
  }
  fnsparticipantid_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.DocflowParticipant.FnsParticipantId)
}
inline void DocflowParticipant::set_fnsparticipantid(const char* value, size_t size) {
  set_has_fnsparticipantid();
  if (fnsparticipantid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fnsparticipantid_ = new ::std::string;
  }
  fnsparticipantid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.DocflowParticipant.FnsParticipantId)
}
inline ::std::string* DocflowParticipant::mutable_fnsparticipantid() {
  set_has_fnsparticipantid();
  if (fnsparticipantid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fnsparticipantid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.DocflowParticipant.FnsParticipantId)
  return fnsparticipantid_;
}
inline ::std::string* DocflowParticipant::release_fnsparticipantid() {
  clear_has_fnsparticipantid();
  if (fnsparticipantid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = fnsparticipantid_;
    fnsparticipantid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void DocflowParticipant::set_allocated_fnsparticipantid(::std::string* fnsparticipantid) {
  if (fnsparticipantid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete fnsparticipantid_;
  }
  if (fnsparticipantid) {
    set_has_fnsparticipantid();
    fnsparticipantid_ = fnsparticipantid;
  } else {
    clear_has_fnsparticipantid();
    fnsparticipantid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.DocflowParticipant.FnsParticipantId)
}

// -------------------------------------------------------------------

// DiadocOrganizationInfo

// optional string BoxId = 1;
inline bool DiadocOrganizationInfo::has_boxid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DiadocOrganizationInfo::set_has_boxid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DiadocOrganizationInfo::clear_has_boxid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DiadocOrganizationInfo::clear_boxid() {
  if (boxid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    boxid_->clear();
  }
  clear_has_boxid();
}
inline const ::std::string& DiadocOrganizationInfo::boxid() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.DiadocOrganizationInfo.BoxId)
  return *boxid_;
}
inline void DiadocOrganizationInfo::set_boxid(const ::std::string& value) {
  set_has_boxid();
  if (boxid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    boxid_ = new ::std::string;
  }
  boxid_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.DiadocOrganizationInfo.BoxId)
}
inline void DiadocOrganizationInfo::set_boxid(const char* value) {
  set_has_boxid();
  if (boxid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    boxid_ = new ::std::string;
  }
  boxid_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.DiadocOrganizationInfo.BoxId)
}
inline void DiadocOrganizationInfo::set_boxid(const char* value, size_t size) {
  set_has_boxid();
  if (boxid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    boxid_ = new ::std::string;
  }
  boxid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.DiadocOrganizationInfo.BoxId)
}
inline ::std::string* DiadocOrganizationInfo::mutable_boxid() {
  set_has_boxid();
  if (boxid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    boxid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.DiadocOrganizationInfo.BoxId)
  return boxid_;
}
inline ::std::string* DiadocOrganizationInfo::release_boxid() {
  clear_has_boxid();
  if (boxid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = boxid_;
    boxid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void DiadocOrganizationInfo::set_allocated_boxid(::std::string* boxid) {
  if (boxid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete boxid_;
  }
  if (boxid) {
    set_has_boxid();
    boxid_ = boxid;
  } else {
    clear_has_boxid();
    boxid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.DiadocOrganizationInfo.BoxId)
}

// optional .Diadoc.Api.Proto.Invoicing.OrganizationInfo OrgInfo = 2;
inline bool DiadocOrganizationInfo::has_orginfo() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DiadocOrganizationInfo::set_has_orginfo() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DiadocOrganizationInfo::clear_has_orginfo() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DiadocOrganizationInfo::clear_orginfo() {
  if (orginfo_ != NULL) orginfo_->::Diadoc::Api::Proto::Invoicing::OrganizationInfo::Clear();
  clear_has_orginfo();
}
inline const ::Diadoc::Api::Proto::Invoicing::OrganizationInfo& DiadocOrganizationInfo::orginfo() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.DiadocOrganizationInfo.OrgInfo)
  return orginfo_ != NULL ? *orginfo_ : *default_instance_->orginfo_;
}
inline ::Diadoc::Api::Proto::Invoicing::OrganizationInfo* DiadocOrganizationInfo::mutable_orginfo() {
  set_has_orginfo();
  if (orginfo_ == NULL) orginfo_ = new ::Diadoc::Api::Proto::Invoicing::OrganizationInfo;
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.DiadocOrganizationInfo.OrgInfo)
  return orginfo_;
}
inline ::Diadoc::Api::Proto::Invoicing::OrganizationInfo* DiadocOrganizationInfo::release_orginfo() {
  clear_has_orginfo();
  ::Diadoc::Api::Proto::Invoicing::OrganizationInfo* temp = orginfo_;
  orginfo_ = NULL;
  return temp;
}
inline void DiadocOrganizationInfo::set_allocated_orginfo(::Diadoc::Api::Proto::Invoicing::OrganizationInfo* orginfo) {
  delete orginfo_;
  orginfo_ = orginfo;
  if (orginfo) {
    set_has_orginfo();
  } else {
    clear_has_orginfo();
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.DiadocOrganizationInfo.OrgInfo)
}

// -------------------------------------------------------------------

// OrganizationInfo

// required string Name = 1;
inline bool OrganizationInfo::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OrganizationInfo::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OrganizationInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OrganizationInfo::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& OrganizationInfo::name() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.OrganizationInfo.Name)
  return *name_;
}
inline void OrganizationInfo::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.OrganizationInfo.Name)
}
inline void OrganizationInfo::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.OrganizationInfo.Name)
}
inline void OrganizationInfo::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.OrganizationInfo.Name)
}
inline ::std::string* OrganizationInfo::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.OrganizationInfo.Name)
  return name_;
}
inline ::std::string* OrganizationInfo::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void OrganizationInfo::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.OrganizationInfo.Name)
}

// optional string Inn = 2;
inline bool OrganizationInfo::has_inn() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OrganizationInfo::set_has_inn() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OrganizationInfo::clear_has_inn() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OrganizationInfo::clear_inn() {
  if (inn_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    inn_->clear();
  }
  clear_has_inn();
}
inline const ::std::string& OrganizationInfo::inn() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.OrganizationInfo.Inn)
  return *inn_;
}
inline void OrganizationInfo::set_inn(const ::std::string& value) {
  set_has_inn();
  if (inn_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    inn_ = new ::std::string;
  }
  inn_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.OrganizationInfo.Inn)
}
inline void OrganizationInfo::set_inn(const char* value) {
  set_has_inn();
  if (inn_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    inn_ = new ::std::string;
  }
  inn_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.OrganizationInfo.Inn)
}
inline void OrganizationInfo::set_inn(const char* value, size_t size) {
  set_has_inn();
  if (inn_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    inn_ = new ::std::string;
  }
  inn_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.OrganizationInfo.Inn)
}
inline ::std::string* OrganizationInfo::mutable_inn() {
  set_has_inn();
  if (inn_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    inn_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.OrganizationInfo.Inn)
  return inn_;
}
inline ::std::string* OrganizationInfo::release_inn() {
  clear_has_inn();
  if (inn_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = inn_;
    inn_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void OrganizationInfo::set_allocated_inn(::std::string* inn) {
  if (inn_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete inn_;
  }
  if (inn) {
    set_has_inn();
    inn_ = inn;
  } else {
    clear_has_inn();
    inn_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.OrganizationInfo.Inn)
}

// optional string Kpp = 3;
inline bool OrganizationInfo::has_kpp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void OrganizationInfo::set_has_kpp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void OrganizationInfo::clear_has_kpp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void OrganizationInfo::clear_kpp() {
  if (kpp_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    kpp_->clear();
  }
  clear_has_kpp();
}
inline const ::std::string& OrganizationInfo::kpp() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.OrganizationInfo.Kpp)
  return *kpp_;
}
inline void OrganizationInfo::set_kpp(const ::std::string& value) {
  set_has_kpp();
  if (kpp_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    kpp_ = new ::std::string;
  }
  kpp_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.OrganizationInfo.Kpp)
}
inline void OrganizationInfo::set_kpp(const char* value) {
  set_has_kpp();
  if (kpp_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    kpp_ = new ::std::string;
  }
  kpp_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.OrganizationInfo.Kpp)
}
inline void OrganizationInfo::set_kpp(const char* value, size_t size) {
  set_has_kpp();
  if (kpp_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    kpp_ = new ::std::string;
  }
  kpp_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.OrganizationInfo.Kpp)
}
inline ::std::string* OrganizationInfo::mutable_kpp() {
  set_has_kpp();
  if (kpp_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    kpp_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.OrganizationInfo.Kpp)
  return kpp_;
}
inline ::std::string* OrganizationInfo::release_kpp() {
  clear_has_kpp();
  if (kpp_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = kpp_;
    kpp_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void OrganizationInfo::set_allocated_kpp(::std::string* kpp) {
  if (kpp_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete kpp_;
  }
  if (kpp) {
    set_has_kpp();
    kpp_ = kpp;
  } else {
    clear_has_kpp();
    kpp_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.OrganizationInfo.Kpp)
}

// required .Diadoc.Api.Proto.Address Address = 4;
inline bool OrganizationInfo::has_address() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void OrganizationInfo::set_has_address() {
  _has_bits_[0] |= 0x00000008u;
}
inline void OrganizationInfo::clear_has_address() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void OrganizationInfo::clear_address() {
  if (address_ != NULL) address_->::Diadoc::Api::Proto::Address::Clear();
  clear_has_address();
}
inline const ::Diadoc::Api::Proto::Address& OrganizationInfo::address() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.OrganizationInfo.Address)
  return address_ != NULL ? *address_ : *default_instance_->address_;
}
inline ::Diadoc::Api::Proto::Address* OrganizationInfo::mutable_address() {
  set_has_address();
  if (address_ == NULL) address_ = new ::Diadoc::Api::Proto::Address;
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.OrganizationInfo.Address)
  return address_;
}
inline ::Diadoc::Api::Proto::Address* OrganizationInfo::release_address() {
  clear_has_address();
  ::Diadoc::Api::Proto::Address* temp = address_;
  address_ = NULL;
  return temp;
}
inline void OrganizationInfo::set_allocated_address(::Diadoc::Api::Proto::Address* address) {
  delete address_;
  address_ = address;
  if (address) {
    set_has_address();
  } else {
    clear_has_address();
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.OrganizationInfo.Address)
}

// optional bool IsSoleProprietor = 5 [default = false];
inline bool OrganizationInfo::has_issoleproprietor() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void OrganizationInfo::set_has_issoleproprietor() {
  _has_bits_[0] |= 0x00000010u;
}
inline void OrganizationInfo::clear_has_issoleproprietor() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void OrganizationInfo::clear_issoleproprietor() {
  issoleproprietor_ = false;
  clear_has_issoleproprietor();
}
inline bool OrganizationInfo::issoleproprietor() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.OrganizationInfo.IsSoleProprietor)
  return issoleproprietor_;
}
inline void OrganizationInfo::set_issoleproprietor(bool value) {
  set_has_issoleproprietor();
  issoleproprietor_ = value;
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.OrganizationInfo.IsSoleProprietor)
}

// optional string Okopf = 6;
inline bool OrganizationInfo::has_okopf() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void OrganizationInfo::set_has_okopf() {
  _has_bits_[0] |= 0x00000020u;
}
inline void OrganizationInfo::clear_has_okopf() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void OrganizationInfo::clear_okopf() {
  if (okopf_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    okopf_->clear();
  }
  clear_has_okopf();
}
inline const ::std::string& OrganizationInfo::okopf() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.OrganizationInfo.Okopf)
  return *okopf_;
}
inline void OrganizationInfo::set_okopf(const ::std::string& value) {
  set_has_okopf();
  if (okopf_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    okopf_ = new ::std::string;
  }
  okopf_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.OrganizationInfo.Okopf)
}
inline void OrganizationInfo::set_okopf(const char* value) {
  set_has_okopf();
  if (okopf_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    okopf_ = new ::std::string;
  }
  okopf_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.OrganizationInfo.Okopf)
}
inline void OrganizationInfo::set_okopf(const char* value, size_t size) {
  set_has_okopf();
  if (okopf_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    okopf_ = new ::std::string;
  }
  okopf_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.OrganizationInfo.Okopf)
}
inline ::std::string* OrganizationInfo::mutable_okopf() {
  set_has_okopf();
  if (okopf_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    okopf_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.OrganizationInfo.Okopf)
  return okopf_;
}
inline ::std::string* OrganizationInfo::release_okopf() {
  clear_has_okopf();
  if (okopf_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = okopf_;
    okopf_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void OrganizationInfo::set_allocated_okopf(::std::string* okopf) {
  if (okopf_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete okopf_;
  }
  if (okopf) {
    set_has_okopf();
    okopf_ = okopf;
  } else {
    clear_has_okopf();
    okopf_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.OrganizationInfo.Okopf)
}

// optional string Okpo = 7;
inline bool OrganizationInfo::has_okpo() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void OrganizationInfo::set_has_okpo() {
  _has_bits_[0] |= 0x00000040u;
}
inline void OrganizationInfo::clear_has_okpo() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void OrganizationInfo::clear_okpo() {
  if (okpo_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    okpo_->clear();
  }
  clear_has_okpo();
}
inline const ::std::string& OrganizationInfo::okpo() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.OrganizationInfo.Okpo)
  return *okpo_;
}
inline void OrganizationInfo::set_okpo(const ::std::string& value) {
  set_has_okpo();
  if (okpo_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    okpo_ = new ::std::string;
  }
  okpo_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.OrganizationInfo.Okpo)
}
inline void OrganizationInfo::set_okpo(const char* value) {
  set_has_okpo();
  if (okpo_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    okpo_ = new ::std::string;
  }
  okpo_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.OrganizationInfo.Okpo)
}
inline void OrganizationInfo::set_okpo(const char* value, size_t size) {
  set_has_okpo();
  if (okpo_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    okpo_ = new ::std::string;
  }
  okpo_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.OrganizationInfo.Okpo)
}
inline ::std::string* OrganizationInfo::mutable_okpo() {
  set_has_okpo();
  if (okpo_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    okpo_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.OrganizationInfo.Okpo)
  return okpo_;
}
inline ::std::string* OrganizationInfo::release_okpo() {
  clear_has_okpo();
  if (okpo_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = okpo_;
    okpo_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void OrganizationInfo::set_allocated_okpo(::std::string* okpo) {
  if (okpo_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete okpo_;
  }
  if (okpo) {
    set_has_okpo();
    okpo_ = okpo;
  } else {
    clear_has_okpo();
    okpo_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.OrganizationInfo.Okpo)
}

// optional string Okdp = 8;
inline bool OrganizationInfo::has_okdp() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void OrganizationInfo::set_has_okdp() {
  _has_bits_[0] |= 0x00000080u;
}
inline void OrganizationInfo::clear_has_okdp() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void OrganizationInfo::clear_okdp() {
  if (okdp_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    okdp_->clear();
  }
  clear_has_okdp();
}
inline const ::std::string& OrganizationInfo::okdp() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.OrganizationInfo.Okdp)
  return *okdp_;
}
inline void OrganizationInfo::set_okdp(const ::std::string& value) {
  set_has_okdp();
  if (okdp_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    okdp_ = new ::std::string;
  }
  okdp_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.OrganizationInfo.Okdp)
}
inline void OrganizationInfo::set_okdp(const char* value) {
  set_has_okdp();
  if (okdp_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    okdp_ = new ::std::string;
  }
  okdp_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.OrganizationInfo.Okdp)
}
inline void OrganizationInfo::set_okdp(const char* value, size_t size) {
  set_has_okdp();
  if (okdp_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    okdp_ = new ::std::string;
  }
  okdp_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.OrganizationInfo.Okdp)
}
inline ::std::string* OrganizationInfo::mutable_okdp() {
  set_has_okdp();
  if (okdp_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    okdp_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.OrganizationInfo.Okdp)
  return okdp_;
}
inline ::std::string* OrganizationInfo::release_okdp() {
  clear_has_okdp();
  if (okdp_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = okdp_;
    okdp_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void OrganizationInfo::set_allocated_okdp(::std::string* okdp) {
  if (okdp_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete okdp_;
  }
  if (okdp) {
    set_has_okdp();
    okdp_ = okdp;
  } else {
    clear_has_okdp();
    okdp_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.OrganizationInfo.Okdp)
}

// optional string Phone = 9;
inline bool OrganizationInfo::has_phone() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void OrganizationInfo::set_has_phone() {
  _has_bits_[0] |= 0x00000100u;
}
inline void OrganizationInfo::clear_has_phone() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void OrganizationInfo::clear_phone() {
  if (phone_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    phone_->clear();
  }
  clear_has_phone();
}
inline const ::std::string& OrganizationInfo::phone() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.OrganizationInfo.Phone)
  return *phone_;
}
inline void OrganizationInfo::set_phone(const ::std::string& value) {
  set_has_phone();
  if (phone_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    phone_ = new ::std::string;
  }
  phone_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.OrganizationInfo.Phone)
}
inline void OrganizationInfo::set_phone(const char* value) {
  set_has_phone();
  if (phone_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    phone_ = new ::std::string;
  }
  phone_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.OrganizationInfo.Phone)
}
inline void OrganizationInfo::set_phone(const char* value, size_t size) {
  set_has_phone();
  if (phone_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    phone_ = new ::std::string;
  }
  phone_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.OrganizationInfo.Phone)
}
inline ::std::string* OrganizationInfo::mutable_phone() {
  set_has_phone();
  if (phone_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    phone_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.OrganizationInfo.Phone)
  return phone_;
}
inline ::std::string* OrganizationInfo::release_phone() {
  clear_has_phone();
  if (phone_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = phone_;
    phone_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void OrganizationInfo::set_allocated_phone(::std::string* phone) {
  if (phone_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete phone_;
  }
  if (phone) {
    set_has_phone();
    phone_ = phone;
  } else {
    clear_has_phone();
    phone_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.OrganizationInfo.Phone)
}

// optional string Fax = 10;
inline bool OrganizationInfo::has_fax() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void OrganizationInfo::set_has_fax() {
  _has_bits_[0] |= 0x00000200u;
}
inline void OrganizationInfo::clear_has_fax() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void OrganizationInfo::clear_fax() {
  if (fax_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fax_->clear();
  }
  clear_has_fax();
}
inline const ::std::string& OrganizationInfo::fax() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.OrganizationInfo.Fax)
  return *fax_;
}
inline void OrganizationInfo::set_fax(const ::std::string& value) {
  set_has_fax();
  if (fax_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fax_ = new ::std::string;
  }
  fax_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.OrganizationInfo.Fax)
}
inline void OrganizationInfo::set_fax(const char* value) {
  set_has_fax();
  if (fax_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fax_ = new ::std::string;
  }
  fax_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.OrganizationInfo.Fax)
}
inline void OrganizationInfo::set_fax(const char* value, size_t size) {
  set_has_fax();
  if (fax_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fax_ = new ::std::string;
  }
  fax_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.OrganizationInfo.Fax)
}
inline ::std::string* OrganizationInfo::mutable_fax() {
  set_has_fax();
  if (fax_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fax_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.OrganizationInfo.Fax)
  return fax_;
}
inline ::std::string* OrganizationInfo::release_fax() {
  clear_has_fax();
  if (fax_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = fax_;
    fax_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void OrganizationInfo::set_allocated_fax(::std::string* fax) {
  if (fax_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete fax_;
  }
  if (fax) {
    set_has_fax();
    fax_ = fax;
  } else {
    clear_has_fax();
    fax_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.OrganizationInfo.Fax)
}

// optional string BankAccountNumber = 11;
inline bool OrganizationInfo::has_bankaccountnumber() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void OrganizationInfo::set_has_bankaccountnumber() {
  _has_bits_[0] |= 0x00000400u;
}
inline void OrganizationInfo::clear_has_bankaccountnumber() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void OrganizationInfo::clear_bankaccountnumber() {
  if (bankaccountnumber_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bankaccountnumber_->clear();
  }
  clear_has_bankaccountnumber();
}
inline const ::std::string& OrganizationInfo::bankaccountnumber() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.OrganizationInfo.BankAccountNumber)
  return *bankaccountnumber_;
}
inline void OrganizationInfo::set_bankaccountnumber(const ::std::string& value) {
  set_has_bankaccountnumber();
  if (bankaccountnumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bankaccountnumber_ = new ::std::string;
  }
  bankaccountnumber_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.OrganizationInfo.BankAccountNumber)
}
inline void OrganizationInfo::set_bankaccountnumber(const char* value) {
  set_has_bankaccountnumber();
  if (bankaccountnumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bankaccountnumber_ = new ::std::string;
  }
  bankaccountnumber_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.OrganizationInfo.BankAccountNumber)
}
inline void OrganizationInfo::set_bankaccountnumber(const char* value, size_t size) {
  set_has_bankaccountnumber();
  if (bankaccountnumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bankaccountnumber_ = new ::std::string;
  }
  bankaccountnumber_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.OrganizationInfo.BankAccountNumber)
}
inline ::std::string* OrganizationInfo::mutable_bankaccountnumber() {
  set_has_bankaccountnumber();
  if (bankaccountnumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bankaccountnumber_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.OrganizationInfo.BankAccountNumber)
  return bankaccountnumber_;
}
inline ::std::string* OrganizationInfo::release_bankaccountnumber() {
  clear_has_bankaccountnumber();
  if (bankaccountnumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = bankaccountnumber_;
    bankaccountnumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void OrganizationInfo::set_allocated_bankaccountnumber(::std::string* bankaccountnumber) {
  if (bankaccountnumber_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete bankaccountnumber_;
  }
  if (bankaccountnumber) {
    set_has_bankaccountnumber();
    bankaccountnumber_ = bankaccountnumber;
  } else {
    clear_has_bankaccountnumber();
    bankaccountnumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.OrganizationInfo.BankAccountNumber)
}

// optional string BankName = 12;
inline bool OrganizationInfo::has_bankname() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void OrganizationInfo::set_has_bankname() {
  _has_bits_[0] |= 0x00000800u;
}
inline void OrganizationInfo::clear_has_bankname() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void OrganizationInfo::clear_bankname() {
  if (bankname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bankname_->clear();
  }
  clear_has_bankname();
}
inline const ::std::string& OrganizationInfo::bankname() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.OrganizationInfo.BankName)
  return *bankname_;
}
inline void OrganizationInfo::set_bankname(const ::std::string& value) {
  set_has_bankname();
  if (bankname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bankname_ = new ::std::string;
  }
  bankname_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.OrganizationInfo.BankName)
}
inline void OrganizationInfo::set_bankname(const char* value) {
  set_has_bankname();
  if (bankname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bankname_ = new ::std::string;
  }
  bankname_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.OrganizationInfo.BankName)
}
inline void OrganizationInfo::set_bankname(const char* value, size_t size) {
  set_has_bankname();
  if (bankname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bankname_ = new ::std::string;
  }
  bankname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.OrganizationInfo.BankName)
}
inline ::std::string* OrganizationInfo::mutable_bankname() {
  set_has_bankname();
  if (bankname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bankname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.OrganizationInfo.BankName)
  return bankname_;
}
inline ::std::string* OrganizationInfo::release_bankname() {
  clear_has_bankname();
  if (bankname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = bankname_;
    bankname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void OrganizationInfo::set_allocated_bankname(::std::string* bankname) {
  if (bankname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete bankname_;
  }
  if (bankname) {
    set_has_bankname();
    bankname_ = bankname;
  } else {
    clear_has_bankname();
    bankname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.OrganizationInfo.BankName)
}

// optional string BankId = 13;
inline bool OrganizationInfo::has_bankid() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void OrganizationInfo::set_has_bankid() {
  _has_bits_[0] |= 0x00001000u;
}
inline void OrganizationInfo::clear_has_bankid() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void OrganizationInfo::clear_bankid() {
  if (bankid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bankid_->clear();
  }
  clear_has_bankid();
}
inline const ::std::string& OrganizationInfo::bankid() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.OrganizationInfo.BankId)
  return *bankid_;
}
inline void OrganizationInfo::set_bankid(const ::std::string& value) {
  set_has_bankid();
  if (bankid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bankid_ = new ::std::string;
  }
  bankid_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.OrganizationInfo.BankId)
}
inline void OrganizationInfo::set_bankid(const char* value) {
  set_has_bankid();
  if (bankid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bankid_ = new ::std::string;
  }
  bankid_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.OrganizationInfo.BankId)
}
inline void OrganizationInfo::set_bankid(const char* value, size_t size) {
  set_has_bankid();
  if (bankid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bankid_ = new ::std::string;
  }
  bankid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.OrganizationInfo.BankId)
}
inline ::std::string* OrganizationInfo::mutable_bankid() {
  set_has_bankid();
  if (bankid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bankid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.OrganizationInfo.BankId)
  return bankid_;
}
inline ::std::string* OrganizationInfo::release_bankid() {
  clear_has_bankid();
  if (bankid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = bankid_;
    bankid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void OrganizationInfo::set_allocated_bankid(::std::string* bankid) {
  if (bankid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete bankid_;
  }
  if (bankid) {
    set_has_bankid();
    bankid_ = bankid;
  } else {
    clear_has_bankid();
    bankid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.OrganizationInfo.BankId)
}

// optional string Department = 14;
inline bool OrganizationInfo::has_department() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void OrganizationInfo::set_has_department() {
  _has_bits_[0] |= 0x00002000u;
}
inline void OrganizationInfo::clear_has_department() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void OrganizationInfo::clear_department() {
  if (department_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    department_->clear();
  }
  clear_has_department();
}
inline const ::std::string& OrganizationInfo::department() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.OrganizationInfo.Department)
  return *department_;
}
inline void OrganizationInfo::set_department(const ::std::string& value) {
  set_has_department();
  if (department_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    department_ = new ::std::string;
  }
  department_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.OrganizationInfo.Department)
}
inline void OrganizationInfo::set_department(const char* value) {
  set_has_department();
  if (department_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    department_ = new ::std::string;
  }
  department_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.OrganizationInfo.Department)
}
inline void OrganizationInfo::set_department(const char* value, size_t size) {
  set_has_department();
  if (department_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    department_ = new ::std::string;
  }
  department_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.OrganizationInfo.Department)
}
inline ::std::string* OrganizationInfo::mutable_department() {
  set_has_department();
  if (department_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    department_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.OrganizationInfo.Department)
  return department_;
}
inline ::std::string* OrganizationInfo::release_department() {
  clear_has_department();
  if (department_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = department_;
    department_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void OrganizationInfo::set_allocated_department(::std::string* department) {
  if (department_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete department_;
  }
  if (department) {
    set_has_department();
    department_ = department;
  } else {
    clear_has_department();
    department_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.OrganizationInfo.Department)
}

// optional string FnsParticipantId = 15;
inline bool OrganizationInfo::has_fnsparticipantid() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void OrganizationInfo::set_has_fnsparticipantid() {
  _has_bits_[0] |= 0x00004000u;
}
inline void OrganizationInfo::clear_has_fnsparticipantid() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void OrganizationInfo::clear_fnsparticipantid() {
  if (fnsparticipantid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fnsparticipantid_->clear();
  }
  clear_has_fnsparticipantid();
}
inline const ::std::string& OrganizationInfo::fnsparticipantid() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.OrganizationInfo.FnsParticipantId)
  return *fnsparticipantid_;
}
inline void OrganizationInfo::set_fnsparticipantid(const ::std::string& value) {
  set_has_fnsparticipantid();
  if (fnsparticipantid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fnsparticipantid_ = new ::std::string;
  }
  fnsparticipantid_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.OrganizationInfo.FnsParticipantId)
}
inline void OrganizationInfo::set_fnsparticipantid(const char* value) {
  set_has_fnsparticipantid();
  if (fnsparticipantid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fnsparticipantid_ = new ::std::string;
  }
  fnsparticipantid_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.OrganizationInfo.FnsParticipantId)
}
inline void OrganizationInfo::set_fnsparticipantid(const char* value, size_t size) {
  set_has_fnsparticipantid();
  if (fnsparticipantid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fnsparticipantid_ = new ::std::string;
  }
  fnsparticipantid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.OrganizationInfo.FnsParticipantId)
}
inline ::std::string* OrganizationInfo::mutable_fnsparticipantid() {
  set_has_fnsparticipantid();
  if (fnsparticipantid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fnsparticipantid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.OrganizationInfo.FnsParticipantId)
  return fnsparticipantid_;
}
inline ::std::string* OrganizationInfo::release_fnsparticipantid() {
  clear_has_fnsparticipantid();
  if (fnsparticipantid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = fnsparticipantid_;
    fnsparticipantid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void OrganizationInfo::set_allocated_fnsparticipantid(::std::string* fnsparticipantid) {
  if (fnsparticipantid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete fnsparticipantid_;
  }
  if (fnsparticipantid) {
    set_has_fnsparticipantid();
    fnsparticipantid_ = fnsparticipantid;
  } else {
    clear_has_fnsparticipantid();
    fnsparticipantid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.OrganizationInfo.FnsParticipantId)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace Invoicing
}  // namespace Proto
}  // namespace Api
}  // namespace Diadoc

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_Invoicing_2fOrganizationInfo_2eproto__INCLUDED
