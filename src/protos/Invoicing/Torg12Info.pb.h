// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Invoicing/Torg12Info.proto

#ifndef PROTOBUF_Invoicing_2fTorg12Info_2eproto__INCLUDED
#define PROTOBUF_Invoicing_2fTorg12Info_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include "Invoicing/Signer.pb.h"
#include "Invoicing/Official.pb.h"
#include "Invoicing/OrganizationInfo.pb.h"
// @@protoc_insertion_point(includes)

namespace Diadoc {
namespace Api {
namespace Proto {
namespace Invoicing {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_Invoicing_2fTorg12Info_2eproto();
void protobuf_AssignDesc_Invoicing_2fTorg12Info_2eproto();
void protobuf_ShutdownFile_Invoicing_2fTorg12Info_2eproto();

class Torg12SellerTitleInfo;
class Torg12BuyerTitleInfo;
class Torg12Item;
class Grounds;

// ===================================================================

class Torg12SellerTitleInfo : public ::google::protobuf::Message {
 public:
  Torg12SellerTitleInfo();
  virtual ~Torg12SellerTitleInfo();

  Torg12SellerTitleInfo(const Torg12SellerTitleInfo& from);

  inline Torg12SellerTitleInfo& operator=(const Torg12SellerTitleInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Torg12SellerTitleInfo& default_instance();

  void Swap(Torg12SellerTitleInfo* other);

  // implements Message ----------------------------------------------

  Torg12SellerTitleInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Torg12SellerTitleInfo& from);
  void MergeFrom(const Torg12SellerTitleInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string DocumentDate = 1;
  inline bool has_documentdate() const;
  inline void clear_documentdate();
  static const int kDocumentDateFieldNumber = 1;
  inline const ::std::string& documentdate() const;
  inline void set_documentdate(const ::std::string& value);
  inline void set_documentdate(const char* value);
  inline void set_documentdate(const char* value, size_t size);
  inline ::std::string* mutable_documentdate();
  inline ::std::string* release_documentdate();
  inline void set_allocated_documentdate(::std::string* documentdate);

  // optional string DocumentNumber = 2;
  inline bool has_documentnumber() const;
  inline void clear_documentnumber();
  static const int kDocumentNumberFieldNumber = 2;
  inline const ::std::string& documentnumber() const;
  inline void set_documentnumber(const ::std::string& value);
  inline void set_documentnumber(const char* value);
  inline void set_documentnumber(const char* value, size_t size);
  inline ::std::string* mutable_documentnumber();
  inline ::std::string* release_documentnumber();
  inline void set_allocated_documentnumber(::std::string* documentnumber);

  // required .Diadoc.Api.Proto.Invoicing.DocflowParticipant SellerDocflowParticipant = 3;
  inline bool has_sellerdocflowparticipant() const;
  inline void clear_sellerdocflowparticipant();
  static const int kSellerDocflowParticipantFieldNumber = 3;
  inline const ::Diadoc::Api::Proto::Invoicing::DocflowParticipant& sellerdocflowparticipant() const;
  inline ::Diadoc::Api::Proto::Invoicing::DocflowParticipant* mutable_sellerdocflowparticipant();
  inline ::Diadoc::Api::Proto::Invoicing::DocflowParticipant* release_sellerdocflowparticipant();
  inline void set_allocated_sellerdocflowparticipant(::Diadoc::Api::Proto::Invoicing::DocflowParticipant* sellerdocflowparticipant);

  // required .Diadoc.Api.Proto.Invoicing.DocflowParticipant BuyerDocflowParticipant = 4;
  inline bool has_buyerdocflowparticipant() const;
  inline void clear_buyerdocflowparticipant();
  static const int kBuyerDocflowParticipantFieldNumber = 4;
  inline const ::Diadoc::Api::Proto::Invoicing::DocflowParticipant& buyerdocflowparticipant() const;
  inline ::Diadoc::Api::Proto::Invoicing::DocflowParticipant* mutable_buyerdocflowparticipant();
  inline ::Diadoc::Api::Proto::Invoicing::DocflowParticipant* release_buyerdocflowparticipant();
  inline void set_allocated_buyerdocflowparticipant(::Diadoc::Api::Proto::Invoicing::DocflowParticipant* buyerdocflowparticipant);

  // optional .Diadoc.Api.Proto.Invoicing.OrganizationInfo Shipper = 5;
  inline bool has_shipper() const;
  inline void clear_shipper();
  static const int kShipperFieldNumber = 5;
  inline const ::Diadoc::Api::Proto::Invoicing::OrganizationInfo& shipper() const;
  inline ::Diadoc::Api::Proto::Invoicing::OrganizationInfo* mutable_shipper();
  inline ::Diadoc::Api::Proto::Invoicing::OrganizationInfo* release_shipper();
  inline void set_allocated_shipper(::Diadoc::Api::Proto::Invoicing::OrganizationInfo* shipper);

  // optional .Diadoc.Api.Proto.Invoicing.OrganizationInfo Consignee = 6;
  inline bool has_consignee() const;
  inline void clear_consignee();
  static const int kConsigneeFieldNumber = 6;
  inline const ::Diadoc::Api::Proto::Invoicing::OrganizationInfo& consignee() const;
  inline ::Diadoc::Api::Proto::Invoicing::OrganizationInfo* mutable_consignee();
  inline ::Diadoc::Api::Proto::Invoicing::OrganizationInfo* release_consignee();
  inline void set_allocated_consignee(::Diadoc::Api::Proto::Invoicing::OrganizationInfo* consignee);

  // optional .Diadoc.Api.Proto.Invoicing.OrganizationInfo Supplier = 7;
  inline bool has_supplier() const;
  inline void clear_supplier();
  static const int kSupplierFieldNumber = 7;
  inline const ::Diadoc::Api::Proto::Invoicing::OrganizationInfo& supplier() const;
  inline ::Diadoc::Api::Proto::Invoicing::OrganizationInfo* mutable_supplier();
  inline ::Diadoc::Api::Proto::Invoicing::OrganizationInfo* release_supplier();
  inline void set_allocated_supplier(::Diadoc::Api::Proto::Invoicing::OrganizationInfo* supplier);

  // optional .Diadoc.Api.Proto.Invoicing.OrganizationInfo Payer = 8;
  inline bool has_payer() const;
  inline void clear_payer();
  static const int kPayerFieldNumber = 8;
  inline const ::Diadoc::Api::Proto::Invoicing::OrganizationInfo& payer() const;
  inline ::Diadoc::Api::Proto::Invoicing::OrganizationInfo* mutable_payer();
  inline ::Diadoc::Api::Proto::Invoicing::OrganizationInfo* release_payer();
  inline void set_allocated_payer(::Diadoc::Api::Proto::Invoicing::OrganizationInfo* payer);

  // optional .Diadoc.Api.Proto.Invoicing.Grounds Grounds = 9;
  inline bool has_grounds() const;
  inline void clear_grounds();
  static const int kGroundsFieldNumber = 9;
  inline const ::Diadoc::Api::Proto::Invoicing::Grounds& grounds() const;
  inline ::Diadoc::Api::Proto::Invoicing::Grounds* mutable_grounds();
  inline ::Diadoc::Api::Proto::Invoicing::Grounds* release_grounds();
  inline void set_allocated_grounds(::Diadoc::Api::Proto::Invoicing::Grounds* grounds);

  // optional string WaybillDate = 10;
  inline bool has_waybilldate() const;
  inline void clear_waybilldate();
  static const int kWaybillDateFieldNumber = 10;
  inline const ::std::string& waybilldate() const;
  inline void set_waybilldate(const ::std::string& value);
  inline void set_waybilldate(const char* value);
  inline void set_waybilldate(const char* value, size_t size);
  inline ::std::string* mutable_waybilldate();
  inline ::std::string* release_waybilldate();
  inline void set_allocated_waybilldate(::std::string* waybilldate);

  // optional string WaybillNumber = 11;
  inline bool has_waybillnumber() const;
  inline void clear_waybillnumber();
  static const int kWaybillNumberFieldNumber = 11;
  inline const ::std::string& waybillnumber() const;
  inline void set_waybillnumber(const ::std::string& value);
  inline void set_waybillnumber(const char* value);
  inline void set_waybillnumber(const char* value, size_t size);
  inline ::std::string* mutable_waybillnumber();
  inline ::std::string* release_waybillnumber();
  inline void set_allocated_waybillnumber(::std::string* waybillnumber);

  // optional string OperationCode = 12;
  inline bool has_operationcode() const;
  inline void clear_operationcode();
  static const int kOperationCodeFieldNumber = 12;
  inline const ::std::string& operationcode() const;
  inline void set_operationcode(const ::std::string& value);
  inline void set_operationcode(const char* value);
  inline void set_operationcode(const char* value, size_t size);
  inline ::std::string* mutable_operationcode();
  inline ::std::string* release_operationcode();
  inline void set_allocated_operationcode(::std::string* operationcode);

  // repeated .Diadoc.Api.Proto.Invoicing.Torg12Item Items = 13;
  inline int items_size() const;
  inline void clear_items();
  static const int kItemsFieldNumber = 13;
  inline const ::Diadoc::Api::Proto::Invoicing::Torg12Item& items(int index) const;
  inline ::Diadoc::Api::Proto::Invoicing::Torg12Item* mutable_items(int index);
  inline ::Diadoc::Api::Proto::Invoicing::Torg12Item* add_items();
  inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::Torg12Item >&
      items() const;
  inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::Torg12Item >*
      mutable_items();

  // optional string ParcelsQuantityTotal = 14;
  inline bool has_parcelsquantitytotal() const;
  inline void clear_parcelsquantitytotal();
  static const int kParcelsQuantityTotalFieldNumber = 14;
  inline const ::std::string& parcelsquantitytotal() const;
  inline void set_parcelsquantitytotal(const ::std::string& value);
  inline void set_parcelsquantitytotal(const char* value);
  inline void set_parcelsquantitytotal(const char* value, size_t size);
  inline ::std::string* mutable_parcelsquantitytotal();
  inline ::std::string* release_parcelsquantitytotal();
  inline void set_allocated_parcelsquantitytotal(::std::string* parcelsquantitytotal);

  // optional string ParcelsQuantityTotalInWords = 15;
  inline bool has_parcelsquantitytotalinwords() const;
  inline void clear_parcelsquantitytotalinwords();
  static const int kParcelsQuantityTotalInWordsFieldNumber = 15;
  inline const ::std::string& parcelsquantitytotalinwords() const;
  inline void set_parcelsquantitytotalinwords(const ::std::string& value);
  inline void set_parcelsquantitytotalinwords(const char* value);
  inline void set_parcelsquantitytotalinwords(const char* value, size_t size);
  inline ::std::string* mutable_parcelsquantitytotalinwords();
  inline ::std::string* release_parcelsquantitytotalinwords();
  inline void set_allocated_parcelsquantitytotalinwords(::std::string* parcelsquantitytotalinwords);

  // optional string GrossQuantityTotal = 16;
  inline bool has_grossquantitytotal() const;
  inline void clear_grossquantitytotal();
  static const int kGrossQuantityTotalFieldNumber = 16;
  inline const ::std::string& grossquantitytotal() const;
  inline void set_grossquantitytotal(const ::std::string& value);
  inline void set_grossquantitytotal(const char* value);
  inline void set_grossquantitytotal(const char* value, size_t size);
  inline ::std::string* mutable_grossquantitytotal();
  inline ::std::string* release_grossquantitytotal();
  inline void set_allocated_grossquantitytotal(::std::string* grossquantitytotal);

  // optional string GrossQuantityTotalInWords = 17;
  inline bool has_grossquantitytotalinwords() const;
  inline void clear_grossquantitytotalinwords();
  static const int kGrossQuantityTotalInWordsFieldNumber = 17;
  inline const ::std::string& grossquantitytotalinwords() const;
  inline void set_grossquantitytotalinwords(const ::std::string& value);
  inline void set_grossquantitytotalinwords(const char* value);
  inline void set_grossquantitytotalinwords(const char* value, size_t size);
  inline ::std::string* mutable_grossquantitytotalinwords();
  inline ::std::string* release_grossquantitytotalinwords();
  inline void set_allocated_grossquantitytotalinwords(::std::string* grossquantitytotalinwords);

  // optional string NetQuantityTotal = 18;
  inline bool has_netquantitytotal() const;
  inline void clear_netquantitytotal();
  static const int kNetQuantityTotalFieldNumber = 18;
  inline const ::std::string& netquantitytotal() const;
  inline void set_netquantitytotal(const ::std::string& value);
  inline void set_netquantitytotal(const char* value);
  inline void set_netquantitytotal(const char* value, size_t size);
  inline ::std::string* mutable_netquantitytotal();
  inline ::std::string* release_netquantitytotal();
  inline void set_allocated_netquantitytotal(::std::string* netquantitytotal);

  // optional string NetQuantityTotalInWords = 19;
  inline bool has_netquantitytotalinwords() const;
  inline void clear_netquantitytotalinwords();
  static const int kNetQuantityTotalInWordsFieldNumber = 19;
  inline const ::std::string& netquantitytotalinwords() const;
  inline void set_netquantitytotalinwords(const ::std::string& value);
  inline void set_netquantitytotalinwords(const char* value);
  inline void set_netquantitytotalinwords(const char* value, size_t size);
  inline ::std::string* mutable_netquantitytotalinwords();
  inline ::std::string* release_netquantitytotalinwords();
  inline void set_allocated_netquantitytotalinwords(::std::string* netquantitytotalinwords);

  // optional string QuantityTotal = 20;
  inline bool has_quantitytotal() const;
  inline void clear_quantitytotal();
  static const int kQuantityTotalFieldNumber = 20;
  inline const ::std::string& quantitytotal() const;
  inline void set_quantitytotal(const ::std::string& value);
  inline void set_quantitytotal(const char* value);
  inline void set_quantitytotal(const char* value, size_t size);
  inline ::std::string* mutable_quantitytotal();
  inline ::std::string* release_quantitytotal();
  inline void set_allocated_quantitytotal(::std::string* quantitytotal);

  // optional string TotalWithVatExcluded = 21;
  inline bool has_totalwithvatexcluded() const;
  inline void clear_totalwithvatexcluded();
  static const int kTotalWithVatExcludedFieldNumber = 21;
  inline const ::std::string& totalwithvatexcluded() const;
  inline void set_totalwithvatexcluded(const ::std::string& value);
  inline void set_totalwithvatexcluded(const char* value);
  inline void set_totalwithvatexcluded(const char* value, size_t size);
  inline ::std::string* mutable_totalwithvatexcluded();
  inline ::std::string* release_totalwithvatexcluded();
  inline void set_allocated_totalwithvatexcluded(::std::string* totalwithvatexcluded);

  // optional string Vat = 22;
  inline bool has_vat() const;
  inline void clear_vat();
  static const int kVatFieldNumber = 22;
  inline const ::std::string& vat() const;
  inline void set_vat(const ::std::string& value);
  inline void set_vat(const char* value);
  inline void set_vat(const char* value, size_t size);
  inline ::std::string* mutable_vat();
  inline ::std::string* release_vat();
  inline void set_allocated_vat(::std::string* vat);

  // required string Total = 23;
  inline bool has_total() const;
  inline void clear_total();
  static const int kTotalFieldNumber = 23;
  inline const ::std::string& total() const;
  inline void set_total(const ::std::string& value);
  inline void set_total(const char* value);
  inline void set_total(const char* value, size_t size);
  inline ::std::string* mutable_total();
  inline ::std::string* release_total();
  inline void set_allocated_total(::std::string* total);

  // optional string TotalInWords = 24;
  inline bool has_totalinwords() const;
  inline void clear_totalinwords();
  static const int kTotalInWordsFieldNumber = 24;
  inline const ::std::string& totalinwords() const;
  inline void set_totalinwords(const ::std::string& value);
  inline void set_totalinwords(const char* value);
  inline void set_totalinwords(const char* value, size_t size);
  inline ::std::string* mutable_totalinwords();
  inline ::std::string* release_totalinwords();
  inline void set_allocated_totalinwords(::std::string* totalinwords);

  // optional string SupplyDate = 25;
  inline bool has_supplydate() const;
  inline void clear_supplydate();
  static const int kSupplyDateFieldNumber = 25;
  inline const ::std::string& supplydate() const;
  inline void set_supplydate(const ::std::string& value);
  inline void set_supplydate(const char* value);
  inline void set_supplydate(const char* value, size_t size);
  inline ::std::string* mutable_supplydate();
  inline ::std::string* release_supplydate();
  inline void set_allocated_supplydate(::std::string* supplydate);

  // optional .Diadoc.Api.Proto.Invoicing.Official SupplyAllowedBy = 26;
  inline bool has_supplyallowedby() const;
  inline void clear_supplyallowedby();
  static const int kSupplyAllowedByFieldNumber = 26;
  inline const ::Diadoc::Api::Proto::Invoicing::Official& supplyallowedby() const;
  inline ::Diadoc::Api::Proto::Invoicing::Official* mutable_supplyallowedby();
  inline ::Diadoc::Api::Proto::Invoicing::Official* release_supplyallowedby();
  inline void set_allocated_supplyallowedby(::Diadoc::Api::Proto::Invoicing::Official* supplyallowedby);

  // optional .Diadoc.Api.Proto.Invoicing.Official SupplyPerformedBy = 27;
  inline bool has_supplyperformedby() const;
  inline void clear_supplyperformedby();
  static const int kSupplyPerformedByFieldNumber = 27;
  inline const ::Diadoc::Api::Proto::Invoicing::Official& supplyperformedby() const;
  inline ::Diadoc::Api::Proto::Invoicing::Official* mutable_supplyperformedby();
  inline ::Diadoc::Api::Proto::Invoicing::Official* release_supplyperformedby();
  inline void set_allocated_supplyperformedby(::Diadoc::Api::Proto::Invoicing::Official* supplyperformedby);

  // optional .Diadoc.Api.Proto.Invoicing.Official ChiefAccountant = 28;
  inline bool has_chiefaccountant() const;
  inline void clear_chiefaccountant();
  static const int kChiefAccountantFieldNumber = 28;
  inline const ::Diadoc::Api::Proto::Invoicing::Official& chiefaccountant() const;
  inline ::Diadoc::Api::Proto::Invoicing::Official* mutable_chiefaccountant();
  inline ::Diadoc::Api::Proto::Invoicing::Official* release_chiefaccountant();
  inline void set_allocated_chiefaccountant(::Diadoc::Api::Proto::Invoicing::Official* chiefaccountant);

  // required .Diadoc.Api.Proto.Invoicing.Signer Signer = 29;
  inline bool has_signer() const;
  inline void clear_signer();
  static const int kSignerFieldNumber = 29;
  inline const ::Diadoc::Api::Proto::Invoicing::Signer& signer() const;
  inline ::Diadoc::Api::Proto::Invoicing::Signer* mutable_signer();
  inline ::Diadoc::Api::Proto::Invoicing::Signer* release_signer();
  inline void set_allocated_signer(::Diadoc::Api::Proto::Invoicing::Signer* signer);

  // optional string AdditionalInfo = 30;
  inline bool has_additionalinfo() const;
  inline void clear_additionalinfo();
  static const int kAdditionalInfoFieldNumber = 30;
  inline const ::std::string& additionalinfo() const;
  inline void set_additionalinfo(const ::std::string& value);
  inline void set_additionalinfo(const char* value);
  inline void set_additionalinfo(const char* value, size_t size);
  inline ::std::string* mutable_additionalinfo();
  inline ::std::string* release_additionalinfo();
  inline void set_allocated_additionalinfo(::std::string* additionalinfo);

  // optional string AttachmentSheetsQuantity = 31;
  inline bool has_attachmentsheetsquantity() const;
  inline void clear_attachmentsheetsquantity();
  static const int kAttachmentSheetsQuantityFieldNumber = 31;
  inline const ::std::string& attachmentsheetsquantity() const;
  inline void set_attachmentsheetsquantity(const ::std::string& value);
  inline void set_attachmentsheetsquantity(const char* value);
  inline void set_attachmentsheetsquantity(const char* value, size_t size);
  inline ::std::string* mutable_attachmentsheetsquantity();
  inline ::std::string* release_attachmentsheetsquantity();
  inline void set_allocated_attachmentsheetsquantity(::std::string* attachmentsheetsquantity);

  // @@protoc_insertion_point(class_scope:Diadoc.Api.Proto.Invoicing.Torg12SellerTitleInfo)
 private:
  inline void set_has_documentdate();
  inline void clear_has_documentdate();
  inline void set_has_documentnumber();
  inline void clear_has_documentnumber();
  inline void set_has_sellerdocflowparticipant();
  inline void clear_has_sellerdocflowparticipant();
  inline void set_has_buyerdocflowparticipant();
  inline void clear_has_buyerdocflowparticipant();
  inline void set_has_shipper();
  inline void clear_has_shipper();
  inline void set_has_consignee();
  inline void clear_has_consignee();
  inline void set_has_supplier();
  inline void clear_has_supplier();
  inline void set_has_payer();
  inline void clear_has_payer();
  inline void set_has_grounds();
  inline void clear_has_grounds();
  inline void set_has_waybilldate();
  inline void clear_has_waybilldate();
  inline void set_has_waybillnumber();
  inline void clear_has_waybillnumber();
  inline void set_has_operationcode();
  inline void clear_has_operationcode();
  inline void set_has_parcelsquantitytotal();
  inline void clear_has_parcelsquantitytotal();
  inline void set_has_parcelsquantitytotalinwords();
  inline void clear_has_parcelsquantitytotalinwords();
  inline void set_has_grossquantitytotal();
  inline void clear_has_grossquantitytotal();
  inline void set_has_grossquantitytotalinwords();
  inline void clear_has_grossquantitytotalinwords();
  inline void set_has_netquantitytotal();
  inline void clear_has_netquantitytotal();
  inline void set_has_netquantitytotalinwords();
  inline void clear_has_netquantitytotalinwords();
  inline void set_has_quantitytotal();
  inline void clear_has_quantitytotal();
  inline void set_has_totalwithvatexcluded();
  inline void clear_has_totalwithvatexcluded();
  inline void set_has_vat();
  inline void clear_has_vat();
  inline void set_has_total();
  inline void clear_has_total();
  inline void set_has_totalinwords();
  inline void clear_has_totalinwords();
  inline void set_has_supplydate();
  inline void clear_has_supplydate();
  inline void set_has_supplyallowedby();
  inline void clear_has_supplyallowedby();
  inline void set_has_supplyperformedby();
  inline void clear_has_supplyperformedby();
  inline void set_has_chiefaccountant();
  inline void clear_has_chiefaccountant();
  inline void set_has_signer();
  inline void clear_has_signer();
  inline void set_has_additionalinfo();
  inline void clear_has_additionalinfo();
  inline void set_has_attachmentsheetsquantity();
  inline void clear_has_attachmentsheetsquantity();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* documentdate_;
  ::std::string* documentnumber_;
  ::Diadoc::Api::Proto::Invoicing::DocflowParticipant* sellerdocflowparticipant_;
  ::Diadoc::Api::Proto::Invoicing::DocflowParticipant* buyerdocflowparticipant_;
  ::Diadoc::Api::Proto::Invoicing::OrganizationInfo* shipper_;
  ::Diadoc::Api::Proto::Invoicing::OrganizationInfo* consignee_;
  ::Diadoc::Api::Proto::Invoicing::OrganizationInfo* supplier_;
  ::Diadoc::Api::Proto::Invoicing::OrganizationInfo* payer_;
  ::Diadoc::Api::Proto::Invoicing::Grounds* grounds_;
  ::std::string* waybilldate_;
  ::std::string* waybillnumber_;
  ::std::string* operationcode_;
  ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::Torg12Item > items_;
  ::std::string* parcelsquantitytotal_;
  ::std::string* parcelsquantitytotalinwords_;
  ::std::string* grossquantitytotal_;
  ::std::string* grossquantitytotalinwords_;
  ::std::string* netquantitytotal_;
  ::std::string* netquantitytotalinwords_;
  ::std::string* quantitytotal_;
  ::std::string* totalwithvatexcluded_;
  ::std::string* vat_;
  ::std::string* total_;
  ::std::string* totalinwords_;
  ::std::string* supplydate_;
  ::Diadoc::Api::Proto::Invoicing::Official* supplyallowedby_;
  ::Diadoc::Api::Proto::Invoicing::Official* supplyperformedby_;
  ::Diadoc::Api::Proto::Invoicing::Official* chiefaccountant_;
  ::Diadoc::Api::Proto::Invoicing::Signer* signer_;
  ::std::string* additionalinfo_;
  ::std::string* attachmentsheetsquantity_;
  friend void  protobuf_AddDesc_Invoicing_2fTorg12Info_2eproto();
  friend void protobuf_AssignDesc_Invoicing_2fTorg12Info_2eproto();
  friend void protobuf_ShutdownFile_Invoicing_2fTorg12Info_2eproto();

  void InitAsDefaultInstance();
  static Torg12SellerTitleInfo* default_instance_;
};
// -------------------------------------------------------------------

class Torg12BuyerTitleInfo : public ::google::protobuf::Message {
 public:
  Torg12BuyerTitleInfo();
  virtual ~Torg12BuyerTitleInfo();

  Torg12BuyerTitleInfo(const Torg12BuyerTitleInfo& from);

  inline Torg12BuyerTitleInfo& operator=(const Torg12BuyerTitleInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Torg12BuyerTitleInfo& default_instance();

  void Swap(Torg12BuyerTitleInfo* other);

  // implements Message ----------------------------------------------

  Torg12BuyerTitleInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Torg12BuyerTitleInfo& from);
  void MergeFrom(const Torg12BuyerTitleInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string ShipmentReceiptDate = 1;
  inline bool has_shipmentreceiptdate() const;
  inline void clear_shipmentreceiptdate();
  static const int kShipmentReceiptDateFieldNumber = 1;
  inline const ::std::string& shipmentreceiptdate() const;
  inline void set_shipmentreceiptdate(const ::std::string& value);
  inline void set_shipmentreceiptdate(const char* value);
  inline void set_shipmentreceiptdate(const char* value, size_t size);
  inline ::std::string* mutable_shipmentreceiptdate();
  inline ::std::string* release_shipmentreceiptdate();
  inline void set_allocated_shipmentreceiptdate(::std::string* shipmentreceiptdate);

  // optional .Diadoc.Api.Proto.Invoicing.Attorney Attorney = 2;
  inline bool has_attorney() const;
  inline void clear_attorney();
  static const int kAttorneyFieldNumber = 2;
  inline const ::Diadoc::Api::Proto::Invoicing::Attorney& attorney() const;
  inline ::Diadoc::Api::Proto::Invoicing::Attorney* mutable_attorney();
  inline ::Diadoc::Api::Proto::Invoicing::Attorney* release_attorney();
  inline void set_allocated_attorney(::Diadoc::Api::Proto::Invoicing::Attorney* attorney);

  // optional .Diadoc.Api.Proto.Invoicing.Official AcceptedBy = 3;
  inline bool has_acceptedby() const;
  inline void clear_acceptedby();
  static const int kAcceptedByFieldNumber = 3;
  inline const ::Diadoc::Api::Proto::Invoicing::Official& acceptedby() const;
  inline ::Diadoc::Api::Proto::Invoicing::Official* mutable_acceptedby();
  inline ::Diadoc::Api::Proto::Invoicing::Official* release_acceptedby();
  inline void set_allocated_acceptedby(::Diadoc::Api::Proto::Invoicing::Official* acceptedby);

  // optional .Diadoc.Api.Proto.Invoicing.Official ReceivedBy = 4;
  inline bool has_receivedby() const;
  inline void clear_receivedby();
  static const int kReceivedByFieldNumber = 4;
  inline const ::Diadoc::Api::Proto::Invoicing::Official& receivedby() const;
  inline ::Diadoc::Api::Proto::Invoicing::Official* mutable_receivedby();
  inline ::Diadoc::Api::Proto::Invoicing::Official* release_receivedby();
  inline void set_allocated_receivedby(::Diadoc::Api::Proto::Invoicing::Official* receivedby);

  // required .Diadoc.Api.Proto.Invoicing.Signer Signer = 5;
  inline bool has_signer() const;
  inline void clear_signer();
  static const int kSignerFieldNumber = 5;
  inline const ::Diadoc::Api::Proto::Invoicing::Signer& signer() const;
  inline ::Diadoc::Api::Proto::Invoicing::Signer* mutable_signer();
  inline ::Diadoc::Api::Proto::Invoicing::Signer* release_signer();
  inline void set_allocated_signer(::Diadoc::Api::Proto::Invoicing::Signer* signer);

  // optional string AdditionalInfo = 6;
  inline bool has_additionalinfo() const;
  inline void clear_additionalinfo();
  static const int kAdditionalInfoFieldNumber = 6;
  inline const ::std::string& additionalinfo() const;
  inline void set_additionalinfo(const ::std::string& value);
  inline void set_additionalinfo(const char* value);
  inline void set_additionalinfo(const char* value, size_t size);
  inline ::std::string* mutable_additionalinfo();
  inline ::std::string* release_additionalinfo();
  inline void set_allocated_additionalinfo(::std::string* additionalinfo);

  // @@protoc_insertion_point(class_scope:Diadoc.Api.Proto.Invoicing.Torg12BuyerTitleInfo)
 private:
  inline void set_has_shipmentreceiptdate();
  inline void clear_has_shipmentreceiptdate();
  inline void set_has_attorney();
  inline void clear_has_attorney();
  inline void set_has_acceptedby();
  inline void clear_has_acceptedby();
  inline void set_has_receivedby();
  inline void clear_has_receivedby();
  inline void set_has_signer();
  inline void clear_has_signer();
  inline void set_has_additionalinfo();
  inline void clear_has_additionalinfo();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* shipmentreceiptdate_;
  ::Diadoc::Api::Proto::Invoicing::Attorney* attorney_;
  ::Diadoc::Api::Proto::Invoicing::Official* acceptedby_;
  ::Diadoc::Api::Proto::Invoicing::Official* receivedby_;
  ::Diadoc::Api::Proto::Invoicing::Signer* signer_;
  ::std::string* additionalinfo_;
  friend void  protobuf_AddDesc_Invoicing_2fTorg12Info_2eproto();
  friend void protobuf_AssignDesc_Invoicing_2fTorg12Info_2eproto();
  friend void protobuf_ShutdownFile_Invoicing_2fTorg12Info_2eproto();

  void InitAsDefaultInstance();
  static Torg12BuyerTitleInfo* default_instance_;
};
// -------------------------------------------------------------------

class Torg12Item : public ::google::protobuf::Message {
 public:
  Torg12Item();
  virtual ~Torg12Item();

  Torg12Item(const Torg12Item& from);

  inline Torg12Item& operator=(const Torg12Item& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Torg12Item& default_instance();

  void Swap(Torg12Item* other);

  // implements Message ----------------------------------------------

  Torg12Item* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Torg12Item& from);
  void MergeFrom(const Torg12Item& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string Name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string Feature = 2;
  inline bool has_feature() const;
  inline void clear_feature();
  static const int kFeatureFieldNumber = 2;
  inline const ::std::string& feature() const;
  inline void set_feature(const ::std::string& value);
  inline void set_feature(const char* value);
  inline void set_feature(const char* value, size_t size);
  inline ::std::string* mutable_feature();
  inline ::std::string* release_feature();
  inline void set_allocated_feature(::std::string* feature);

  // optional string Sort = 3;
  inline bool has_sort() const;
  inline void clear_sort();
  static const int kSortFieldNumber = 3;
  inline const ::std::string& sort() const;
  inline void set_sort(const ::std::string& value);
  inline void set_sort(const char* value);
  inline void set_sort(const char* value, size_t size);
  inline ::std::string* mutable_sort();
  inline ::std::string* release_sort();
  inline void set_allocated_sort(::std::string* sort);

  // optional string NomenclatureArticle = 4;
  inline bool has_nomenclaturearticle() const;
  inline void clear_nomenclaturearticle();
  static const int kNomenclatureArticleFieldNumber = 4;
  inline const ::std::string& nomenclaturearticle() const;
  inline void set_nomenclaturearticle(const ::std::string& value);
  inline void set_nomenclaturearticle(const char* value);
  inline void set_nomenclaturearticle(const char* value, size_t size);
  inline ::std::string* mutable_nomenclaturearticle();
  inline ::std::string* release_nomenclaturearticle();
  inline void set_allocated_nomenclaturearticle(::std::string* nomenclaturearticle);

  // optional string Code = 5;
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 5;
  inline const ::std::string& code() const;
  inline void set_code(const ::std::string& value);
  inline void set_code(const char* value);
  inline void set_code(const char* value, size_t size);
  inline ::std::string* mutable_code();
  inline ::std::string* release_code();
  inline void set_allocated_code(::std::string* code);

  // optional string UnitCode = 6;
  inline bool has_unitcode() const;
  inline void clear_unitcode();
  static const int kUnitCodeFieldNumber = 6;
  inline const ::std::string& unitcode() const;
  inline void set_unitcode(const ::std::string& value);
  inline void set_unitcode(const char* value);
  inline void set_unitcode(const char* value, size_t size);
  inline ::std::string* mutable_unitcode();
  inline ::std::string* release_unitcode();
  inline void set_allocated_unitcode(::std::string* unitcode);

  // required string UnitName = 7;
  inline bool has_unitname() const;
  inline void clear_unitname();
  static const int kUnitNameFieldNumber = 7;
  inline const ::std::string& unitname() const;
  inline void set_unitname(const ::std::string& value);
  inline void set_unitname(const char* value);
  inline void set_unitname(const char* value, size_t size);
  inline ::std::string* mutable_unitname();
  inline ::std::string* release_unitname();
  inline void set_allocated_unitname(::std::string* unitname);

  // optional string ParcelType = 8;
  inline bool has_parceltype() const;
  inline void clear_parceltype();
  static const int kParcelTypeFieldNumber = 8;
  inline const ::std::string& parceltype() const;
  inline void set_parceltype(const ::std::string& value);
  inline void set_parceltype(const char* value);
  inline void set_parceltype(const char* value, size_t size);
  inline ::std::string* mutable_parceltype();
  inline ::std::string* release_parceltype();
  inline void set_allocated_parceltype(::std::string* parceltype);

  // optional string ParcelCapacity = 9;
  inline bool has_parcelcapacity() const;
  inline void clear_parcelcapacity();
  static const int kParcelCapacityFieldNumber = 9;
  inline const ::std::string& parcelcapacity() const;
  inline void set_parcelcapacity(const ::std::string& value);
  inline void set_parcelcapacity(const char* value);
  inline void set_parcelcapacity(const char* value, size_t size);
  inline ::std::string* mutable_parcelcapacity();
  inline ::std::string* release_parcelcapacity();
  inline void set_allocated_parcelcapacity(::std::string* parcelcapacity);

  // optional string ParcelsQuantity = 10;
  inline bool has_parcelsquantity() const;
  inline void clear_parcelsquantity();
  static const int kParcelsQuantityFieldNumber = 10;
  inline const ::std::string& parcelsquantity() const;
  inline void set_parcelsquantity(const ::std::string& value);
  inline void set_parcelsquantity(const char* value);
  inline void set_parcelsquantity(const char* value, size_t size);
  inline ::std::string* mutable_parcelsquantity();
  inline ::std::string* release_parcelsquantity();
  inline void set_allocated_parcelsquantity(::std::string* parcelsquantity);

  // optional string GrossQuantity = 11;
  inline bool has_grossquantity() const;
  inline void clear_grossquantity();
  static const int kGrossQuantityFieldNumber = 11;
  inline const ::std::string& grossquantity() const;
  inline void set_grossquantity(const ::std::string& value);
  inline void set_grossquantity(const char* value);
  inline void set_grossquantity(const char* value, size_t size);
  inline ::std::string* mutable_grossquantity();
  inline ::std::string* release_grossquantity();
  inline void set_allocated_grossquantity(::std::string* grossquantity);

  // required string Quantity = 12;
  inline bool has_quantity() const;
  inline void clear_quantity();
  static const int kQuantityFieldNumber = 12;
  inline const ::std::string& quantity() const;
  inline void set_quantity(const ::std::string& value);
  inline void set_quantity(const char* value);
  inline void set_quantity(const char* value, size_t size);
  inline ::std::string* mutable_quantity();
  inline ::std::string* release_quantity();
  inline void set_allocated_quantity(::std::string* quantity);

  // optional string Price = 13;
  inline bool has_price() const;
  inline void clear_price();
  static const int kPriceFieldNumber = 13;
  inline const ::std::string& price() const;
  inline void set_price(const ::std::string& value);
  inline void set_price(const char* value);
  inline void set_price(const char* value, size_t size);
  inline ::std::string* mutable_price();
  inline ::std::string* release_price();
  inline void set_allocated_price(::std::string* price);

  // required string TaxRate = 14;
  inline bool has_taxrate() const;
  inline void clear_taxrate();
  static const int kTaxRateFieldNumber = 14;
  inline const ::std::string& taxrate() const;
  inline void set_taxrate(const ::std::string& value);
  inline void set_taxrate(const char* value);
  inline void set_taxrate(const char* value, size_t size);
  inline ::std::string* mutable_taxrate();
  inline ::std::string* release_taxrate();
  inline void set_allocated_taxrate(::std::string* taxrate);

  // optional string SubtotalWithVatExcluded = 15;
  inline bool has_subtotalwithvatexcluded() const;
  inline void clear_subtotalwithvatexcluded();
  static const int kSubtotalWithVatExcludedFieldNumber = 15;
  inline const ::std::string& subtotalwithvatexcluded() const;
  inline void set_subtotalwithvatexcluded(const ::std::string& value);
  inline void set_subtotalwithvatexcluded(const char* value);
  inline void set_subtotalwithvatexcluded(const char* value, size_t size);
  inline ::std::string* mutable_subtotalwithvatexcluded();
  inline ::std::string* release_subtotalwithvatexcluded();
  inline void set_allocated_subtotalwithvatexcluded(::std::string* subtotalwithvatexcluded);

  // optional string Vat = 16;
  inline bool has_vat() const;
  inline void clear_vat();
  static const int kVatFieldNumber = 16;
  inline const ::std::string& vat() const;
  inline void set_vat(const ::std::string& value);
  inline void set_vat(const char* value);
  inline void set_vat(const char* value, size_t size);
  inline ::std::string* mutable_vat();
  inline ::std::string* release_vat();
  inline void set_allocated_vat(::std::string* vat);

  // required string Subtotal = 17;
  inline bool has_subtotal() const;
  inline void clear_subtotal();
  static const int kSubtotalFieldNumber = 17;
  inline const ::std::string& subtotal() const;
  inline void set_subtotal(const ::std::string& value);
  inline void set_subtotal(const char* value);
  inline void set_subtotal(const char* value, size_t size);
  inline ::std::string* mutable_subtotal();
  inline ::std::string* release_subtotal();
  inline void set_allocated_subtotal(::std::string* subtotal);

  // optional string AdditionalInfo = 18;
  inline bool has_additionalinfo() const;
  inline void clear_additionalinfo();
  static const int kAdditionalInfoFieldNumber = 18;
  inline const ::std::string& additionalinfo() const;
  inline void set_additionalinfo(const ::std::string& value);
  inline void set_additionalinfo(const char* value);
  inline void set_additionalinfo(const char* value, size_t size);
  inline ::std::string* mutable_additionalinfo();
  inline ::std::string* release_additionalinfo();
  inline void set_allocated_additionalinfo(::std::string* additionalinfo);

  // @@protoc_insertion_point(class_scope:Diadoc.Api.Proto.Invoicing.Torg12Item)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_feature();
  inline void clear_has_feature();
  inline void set_has_sort();
  inline void clear_has_sort();
  inline void set_has_nomenclaturearticle();
  inline void clear_has_nomenclaturearticle();
  inline void set_has_code();
  inline void clear_has_code();
  inline void set_has_unitcode();
  inline void clear_has_unitcode();
  inline void set_has_unitname();
  inline void clear_has_unitname();
  inline void set_has_parceltype();
  inline void clear_has_parceltype();
  inline void set_has_parcelcapacity();
  inline void clear_has_parcelcapacity();
  inline void set_has_parcelsquantity();
  inline void clear_has_parcelsquantity();
  inline void set_has_grossquantity();
  inline void clear_has_grossquantity();
  inline void set_has_quantity();
  inline void clear_has_quantity();
  inline void set_has_price();
  inline void clear_has_price();
  inline void set_has_taxrate();
  inline void clear_has_taxrate();
  inline void set_has_subtotalwithvatexcluded();
  inline void clear_has_subtotalwithvatexcluded();
  inline void set_has_vat();
  inline void clear_has_vat();
  inline void set_has_subtotal();
  inline void clear_has_subtotal();
  inline void set_has_additionalinfo();
  inline void clear_has_additionalinfo();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::std::string* feature_;
  ::std::string* sort_;
  ::std::string* nomenclaturearticle_;
  ::std::string* code_;
  ::std::string* unitcode_;
  ::std::string* unitname_;
  ::std::string* parceltype_;
  ::std::string* parcelcapacity_;
  ::std::string* parcelsquantity_;
  ::std::string* grossquantity_;
  ::std::string* quantity_;
  ::std::string* price_;
  ::std::string* taxrate_;
  ::std::string* subtotalwithvatexcluded_;
  ::std::string* vat_;
  ::std::string* subtotal_;
  ::std::string* additionalinfo_;
  friend void  protobuf_AddDesc_Invoicing_2fTorg12Info_2eproto();
  friend void protobuf_AssignDesc_Invoicing_2fTorg12Info_2eproto();
  friend void protobuf_ShutdownFile_Invoicing_2fTorg12Info_2eproto();

  void InitAsDefaultInstance();
  static Torg12Item* default_instance_;
};
// -------------------------------------------------------------------

class Grounds : public ::google::protobuf::Message {
 public:
  Grounds();
  virtual ~Grounds();

  Grounds(const Grounds& from);

  inline Grounds& operator=(const Grounds& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Grounds& default_instance();

  void Swap(Grounds* other);

  // implements Message ----------------------------------------------

  Grounds* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Grounds& from);
  void MergeFrom(const Grounds& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string DocumentName = 1;
  inline bool has_documentname() const;
  inline void clear_documentname();
  static const int kDocumentNameFieldNumber = 1;
  inline const ::std::string& documentname() const;
  inline void set_documentname(const ::std::string& value);
  inline void set_documentname(const char* value);
  inline void set_documentname(const char* value, size_t size);
  inline ::std::string* mutable_documentname();
  inline ::std::string* release_documentname();
  inline void set_allocated_documentname(::std::string* documentname);

  // optional string DocumentNumber = 2;
  inline bool has_documentnumber() const;
  inline void clear_documentnumber();
  static const int kDocumentNumberFieldNumber = 2;
  inline const ::std::string& documentnumber() const;
  inline void set_documentnumber(const ::std::string& value);
  inline void set_documentnumber(const char* value);
  inline void set_documentnumber(const char* value, size_t size);
  inline ::std::string* mutable_documentnumber();
  inline ::std::string* release_documentnumber();
  inline void set_allocated_documentnumber(::std::string* documentnumber);

  // optional string DocumentDate = 3;
  inline bool has_documentdate() const;
  inline void clear_documentdate();
  static const int kDocumentDateFieldNumber = 3;
  inline const ::std::string& documentdate() const;
  inline void set_documentdate(const ::std::string& value);
  inline void set_documentdate(const char* value);
  inline void set_documentdate(const char* value, size_t size);
  inline ::std::string* mutable_documentdate();
  inline ::std::string* release_documentdate();
  inline void set_allocated_documentdate(::std::string* documentdate);

  // optional string AdditionalInfo = 4;
  inline bool has_additionalinfo() const;
  inline void clear_additionalinfo();
  static const int kAdditionalInfoFieldNumber = 4;
  inline const ::std::string& additionalinfo() const;
  inline void set_additionalinfo(const ::std::string& value);
  inline void set_additionalinfo(const char* value);
  inline void set_additionalinfo(const char* value, size_t size);
  inline ::std::string* mutable_additionalinfo();
  inline ::std::string* release_additionalinfo();
  inline void set_allocated_additionalinfo(::std::string* additionalinfo);

  // @@protoc_insertion_point(class_scope:Diadoc.Api.Proto.Invoicing.Grounds)
 private:
  inline void set_has_documentname();
  inline void clear_has_documentname();
  inline void set_has_documentnumber();
  inline void clear_has_documentnumber();
  inline void set_has_documentdate();
  inline void clear_has_documentdate();
  inline void set_has_additionalinfo();
  inline void clear_has_additionalinfo();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* documentname_;
  ::std::string* documentnumber_;
  ::std::string* documentdate_;
  ::std::string* additionalinfo_;
  friend void  protobuf_AddDesc_Invoicing_2fTorg12Info_2eproto();
  friend void protobuf_AssignDesc_Invoicing_2fTorg12Info_2eproto();
  friend void protobuf_ShutdownFile_Invoicing_2fTorg12Info_2eproto();

  void InitAsDefaultInstance();
  static Grounds* default_instance_;
};
// ===================================================================


// ===================================================================

// Torg12SellerTitleInfo

// required string DocumentDate = 1;
inline bool Torg12SellerTitleInfo::has_documentdate() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Torg12SellerTitleInfo::set_has_documentdate() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Torg12SellerTitleInfo::clear_has_documentdate() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Torg12SellerTitleInfo::clear_documentdate() {
  if (documentdate_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    documentdate_->clear();
  }
  clear_has_documentdate();
}
inline const ::std::string& Torg12SellerTitleInfo::documentdate() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.Torg12SellerTitleInfo.DocumentDate)
  return *documentdate_;
}
inline void Torg12SellerTitleInfo::set_documentdate(const ::std::string& value) {
  set_has_documentdate();
  if (documentdate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    documentdate_ = new ::std::string;
  }
  documentdate_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.Torg12SellerTitleInfo.DocumentDate)
}
inline void Torg12SellerTitleInfo::set_documentdate(const char* value) {
  set_has_documentdate();
  if (documentdate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    documentdate_ = new ::std::string;
  }
  documentdate_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.Torg12SellerTitleInfo.DocumentDate)
}
inline void Torg12SellerTitleInfo::set_documentdate(const char* value, size_t size) {
  set_has_documentdate();
  if (documentdate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    documentdate_ = new ::std::string;
  }
  documentdate_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.Torg12SellerTitleInfo.DocumentDate)
}
inline ::std::string* Torg12SellerTitleInfo::mutable_documentdate() {
  set_has_documentdate();
  if (documentdate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    documentdate_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.Torg12SellerTitleInfo.DocumentDate)
  return documentdate_;
}
inline ::std::string* Torg12SellerTitleInfo::release_documentdate() {
  clear_has_documentdate();
  if (documentdate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = documentdate_;
    documentdate_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Torg12SellerTitleInfo::set_allocated_documentdate(::std::string* documentdate) {
  if (documentdate_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete documentdate_;
  }
  if (documentdate) {
    set_has_documentdate();
    documentdate_ = documentdate;
  } else {
    clear_has_documentdate();
    documentdate_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.Torg12SellerTitleInfo.DocumentDate)
}

// optional string DocumentNumber = 2;
inline bool Torg12SellerTitleInfo::has_documentnumber() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Torg12SellerTitleInfo::set_has_documentnumber() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Torg12SellerTitleInfo::clear_has_documentnumber() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Torg12SellerTitleInfo::clear_documentnumber() {
  if (documentnumber_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    documentnumber_->clear();
  }
  clear_has_documentnumber();
}
inline const ::std::string& Torg12SellerTitleInfo::documentnumber() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.Torg12SellerTitleInfo.DocumentNumber)
  return *documentnumber_;
}
inline void Torg12SellerTitleInfo::set_documentnumber(const ::std::string& value) {
  set_has_documentnumber();
  if (documentnumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    documentnumber_ = new ::std::string;
  }
  documentnumber_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.Torg12SellerTitleInfo.DocumentNumber)
}
inline void Torg12SellerTitleInfo::set_documentnumber(const char* value) {
  set_has_documentnumber();
  if (documentnumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    documentnumber_ = new ::std::string;
  }
  documentnumber_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.Torg12SellerTitleInfo.DocumentNumber)
}
inline void Torg12SellerTitleInfo::set_documentnumber(const char* value, size_t size) {
  set_has_documentnumber();
  if (documentnumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    documentnumber_ = new ::std::string;
  }
  documentnumber_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.Torg12SellerTitleInfo.DocumentNumber)
}
inline ::std::string* Torg12SellerTitleInfo::mutable_documentnumber() {
  set_has_documentnumber();
  if (documentnumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    documentnumber_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.Torg12SellerTitleInfo.DocumentNumber)
  return documentnumber_;
}
inline ::std::string* Torg12SellerTitleInfo::release_documentnumber() {
  clear_has_documentnumber();
  if (documentnumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = documentnumber_;
    documentnumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Torg12SellerTitleInfo::set_allocated_documentnumber(::std::string* documentnumber) {
  if (documentnumber_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete documentnumber_;
  }
  if (documentnumber) {
    set_has_documentnumber();
    documentnumber_ = documentnumber;
  } else {
    clear_has_documentnumber();
    documentnumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.Torg12SellerTitleInfo.DocumentNumber)
}

// required .Diadoc.Api.Proto.Invoicing.DocflowParticipant SellerDocflowParticipant = 3;
inline bool Torg12SellerTitleInfo::has_sellerdocflowparticipant() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Torg12SellerTitleInfo::set_has_sellerdocflowparticipant() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Torg12SellerTitleInfo::clear_has_sellerdocflowparticipant() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Torg12SellerTitleInfo::clear_sellerdocflowparticipant() {
  if (sellerdocflowparticipant_ != NULL) sellerdocflowparticipant_->::Diadoc::Api::Proto::Invoicing::DocflowParticipant::Clear();
  clear_has_sellerdocflowparticipant();
}
inline const ::Diadoc::Api::Proto::Invoicing::DocflowParticipant& Torg12SellerTitleInfo::sellerdocflowparticipant() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.Torg12SellerTitleInfo.SellerDocflowParticipant)
  return sellerdocflowparticipant_ != NULL ? *sellerdocflowparticipant_ : *default_instance_->sellerdocflowparticipant_;
}
inline ::Diadoc::Api::Proto::Invoicing::DocflowParticipant* Torg12SellerTitleInfo::mutable_sellerdocflowparticipant() {
  set_has_sellerdocflowparticipant();
  if (sellerdocflowparticipant_ == NULL) sellerdocflowparticipant_ = new ::Diadoc::Api::Proto::Invoicing::DocflowParticipant;
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.Torg12SellerTitleInfo.SellerDocflowParticipant)
  return sellerdocflowparticipant_;
}
inline ::Diadoc::Api::Proto::Invoicing::DocflowParticipant* Torg12SellerTitleInfo::release_sellerdocflowparticipant() {
  clear_has_sellerdocflowparticipant();
  ::Diadoc::Api::Proto::Invoicing::DocflowParticipant* temp = sellerdocflowparticipant_;
  sellerdocflowparticipant_ = NULL;
  return temp;
}
inline void Torg12SellerTitleInfo::set_allocated_sellerdocflowparticipant(::Diadoc::Api::Proto::Invoicing::DocflowParticipant* sellerdocflowparticipant) {
  delete sellerdocflowparticipant_;
  sellerdocflowparticipant_ = sellerdocflowparticipant;
  if (sellerdocflowparticipant) {
    set_has_sellerdocflowparticipant();
  } else {
    clear_has_sellerdocflowparticipant();
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.Torg12SellerTitleInfo.SellerDocflowParticipant)
}

// required .Diadoc.Api.Proto.Invoicing.DocflowParticipant BuyerDocflowParticipant = 4;
inline bool Torg12SellerTitleInfo::has_buyerdocflowparticipant() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Torg12SellerTitleInfo::set_has_buyerdocflowparticipant() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Torg12SellerTitleInfo::clear_has_buyerdocflowparticipant() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Torg12SellerTitleInfo::clear_buyerdocflowparticipant() {
  if (buyerdocflowparticipant_ != NULL) buyerdocflowparticipant_->::Diadoc::Api::Proto::Invoicing::DocflowParticipant::Clear();
  clear_has_buyerdocflowparticipant();
}
inline const ::Diadoc::Api::Proto::Invoicing::DocflowParticipant& Torg12SellerTitleInfo::buyerdocflowparticipant() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.Torg12SellerTitleInfo.BuyerDocflowParticipant)
  return buyerdocflowparticipant_ != NULL ? *buyerdocflowparticipant_ : *default_instance_->buyerdocflowparticipant_;
}
inline ::Diadoc::Api::Proto::Invoicing::DocflowParticipant* Torg12SellerTitleInfo::mutable_buyerdocflowparticipant() {
  set_has_buyerdocflowparticipant();
  if (buyerdocflowparticipant_ == NULL) buyerdocflowparticipant_ = new ::Diadoc::Api::Proto::Invoicing::DocflowParticipant;
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.Torg12SellerTitleInfo.BuyerDocflowParticipant)
  return buyerdocflowparticipant_;
}
inline ::Diadoc::Api::Proto::Invoicing::DocflowParticipant* Torg12SellerTitleInfo::release_buyerdocflowparticipant() {
  clear_has_buyerdocflowparticipant();
  ::Diadoc::Api::Proto::Invoicing::DocflowParticipant* temp = buyerdocflowparticipant_;
  buyerdocflowparticipant_ = NULL;
  return temp;
}
inline void Torg12SellerTitleInfo::set_allocated_buyerdocflowparticipant(::Diadoc::Api::Proto::Invoicing::DocflowParticipant* buyerdocflowparticipant) {
  delete buyerdocflowparticipant_;
  buyerdocflowparticipant_ = buyerdocflowparticipant;
  if (buyerdocflowparticipant) {
    set_has_buyerdocflowparticipant();
  } else {
    clear_has_buyerdocflowparticipant();
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.Torg12SellerTitleInfo.BuyerDocflowParticipant)
}

// optional .Diadoc.Api.Proto.Invoicing.OrganizationInfo Shipper = 5;
inline bool Torg12SellerTitleInfo::has_shipper() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Torg12SellerTitleInfo::set_has_shipper() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Torg12SellerTitleInfo::clear_has_shipper() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Torg12SellerTitleInfo::clear_shipper() {
  if (shipper_ != NULL) shipper_->::Diadoc::Api::Proto::Invoicing::OrganizationInfo::Clear();
  clear_has_shipper();
}
inline const ::Diadoc::Api::Proto::Invoicing::OrganizationInfo& Torg12SellerTitleInfo::shipper() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.Torg12SellerTitleInfo.Shipper)
  return shipper_ != NULL ? *shipper_ : *default_instance_->shipper_;
}
inline ::Diadoc::Api::Proto::Invoicing::OrganizationInfo* Torg12SellerTitleInfo::mutable_shipper() {
  set_has_shipper();
  if (shipper_ == NULL) shipper_ = new ::Diadoc::Api::Proto::Invoicing::OrganizationInfo;
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.Torg12SellerTitleInfo.Shipper)
  return shipper_;
}
inline ::Diadoc::Api::Proto::Invoicing::OrganizationInfo* Torg12SellerTitleInfo::release_shipper() {
  clear_has_shipper();
  ::Diadoc::Api::Proto::Invoicing::OrganizationInfo* temp = shipper_;
  shipper_ = NULL;
  return temp;
}
inline void Torg12SellerTitleInfo::set_allocated_shipper(::Diadoc::Api::Proto::Invoicing::OrganizationInfo* shipper) {
  delete shipper_;
  shipper_ = shipper;
  if (shipper) {
    set_has_shipper();
  } else {
    clear_has_shipper();
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.Torg12SellerTitleInfo.Shipper)
}

// optional .Diadoc.Api.Proto.Invoicing.OrganizationInfo Consignee = 6;
inline bool Torg12SellerTitleInfo::has_consignee() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Torg12SellerTitleInfo::set_has_consignee() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Torg12SellerTitleInfo::clear_has_consignee() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Torg12SellerTitleInfo::clear_consignee() {
  if (consignee_ != NULL) consignee_->::Diadoc::Api::Proto::Invoicing::OrganizationInfo::Clear();
  clear_has_consignee();
}
inline const ::Diadoc::Api::Proto::Invoicing::OrganizationInfo& Torg12SellerTitleInfo::consignee() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.Torg12SellerTitleInfo.Consignee)
  return consignee_ != NULL ? *consignee_ : *default_instance_->consignee_;
}
inline ::Diadoc::Api::Proto::Invoicing::OrganizationInfo* Torg12SellerTitleInfo::mutable_consignee() {
  set_has_consignee();
  if (consignee_ == NULL) consignee_ = new ::Diadoc::Api::Proto::Invoicing::OrganizationInfo;
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.Torg12SellerTitleInfo.Consignee)
  return consignee_;
}
inline ::Diadoc::Api::Proto::Invoicing::OrganizationInfo* Torg12SellerTitleInfo::release_consignee() {
  clear_has_consignee();
  ::Diadoc::Api::Proto::Invoicing::OrganizationInfo* temp = consignee_;
  consignee_ = NULL;
  return temp;
}
inline void Torg12SellerTitleInfo::set_allocated_consignee(::Diadoc::Api::Proto::Invoicing::OrganizationInfo* consignee) {
  delete consignee_;
  consignee_ = consignee;
  if (consignee) {
    set_has_consignee();
  } else {
    clear_has_consignee();
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.Torg12SellerTitleInfo.Consignee)
}

// optional .Diadoc.Api.Proto.Invoicing.OrganizationInfo Supplier = 7;
inline bool Torg12SellerTitleInfo::has_supplier() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Torg12SellerTitleInfo::set_has_supplier() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Torg12SellerTitleInfo::clear_has_supplier() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Torg12SellerTitleInfo::clear_supplier() {
  if (supplier_ != NULL) supplier_->::Diadoc::Api::Proto::Invoicing::OrganizationInfo::Clear();
  clear_has_supplier();
}
inline const ::Diadoc::Api::Proto::Invoicing::OrganizationInfo& Torg12SellerTitleInfo::supplier() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.Torg12SellerTitleInfo.Supplier)
  return supplier_ != NULL ? *supplier_ : *default_instance_->supplier_;
}
inline ::Diadoc::Api::Proto::Invoicing::OrganizationInfo* Torg12SellerTitleInfo::mutable_supplier() {
  set_has_supplier();
  if (supplier_ == NULL) supplier_ = new ::Diadoc::Api::Proto::Invoicing::OrganizationInfo;
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.Torg12SellerTitleInfo.Supplier)
  return supplier_;
}
inline ::Diadoc::Api::Proto::Invoicing::OrganizationInfo* Torg12SellerTitleInfo::release_supplier() {
  clear_has_supplier();
  ::Diadoc::Api::Proto::Invoicing::OrganizationInfo* temp = supplier_;
  supplier_ = NULL;
  return temp;
}
inline void Torg12SellerTitleInfo::set_allocated_supplier(::Diadoc::Api::Proto::Invoicing::OrganizationInfo* supplier) {
  delete supplier_;
  supplier_ = supplier;
  if (supplier) {
    set_has_supplier();
  } else {
    clear_has_supplier();
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.Torg12SellerTitleInfo.Supplier)
}

// optional .Diadoc.Api.Proto.Invoicing.OrganizationInfo Payer = 8;
inline bool Torg12SellerTitleInfo::has_payer() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Torg12SellerTitleInfo::set_has_payer() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Torg12SellerTitleInfo::clear_has_payer() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Torg12SellerTitleInfo::clear_payer() {
  if (payer_ != NULL) payer_->::Diadoc::Api::Proto::Invoicing::OrganizationInfo::Clear();
  clear_has_payer();
}
inline const ::Diadoc::Api::Proto::Invoicing::OrganizationInfo& Torg12SellerTitleInfo::payer() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.Torg12SellerTitleInfo.Payer)
  return payer_ != NULL ? *payer_ : *default_instance_->payer_;
}
inline ::Diadoc::Api::Proto::Invoicing::OrganizationInfo* Torg12SellerTitleInfo::mutable_payer() {
  set_has_payer();
  if (payer_ == NULL) payer_ = new ::Diadoc::Api::Proto::Invoicing::OrganizationInfo;
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.Torg12SellerTitleInfo.Payer)
  return payer_;
}
inline ::Diadoc::Api::Proto::Invoicing::OrganizationInfo* Torg12SellerTitleInfo::release_payer() {
  clear_has_payer();
  ::Diadoc::Api::Proto::Invoicing::OrganizationInfo* temp = payer_;
  payer_ = NULL;
  return temp;
}
inline void Torg12SellerTitleInfo::set_allocated_payer(::Diadoc::Api::Proto::Invoicing::OrganizationInfo* payer) {
  delete payer_;
  payer_ = payer;
  if (payer) {
    set_has_payer();
  } else {
    clear_has_payer();
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.Torg12SellerTitleInfo.Payer)
}

// optional .Diadoc.Api.Proto.Invoicing.Grounds Grounds = 9;
inline bool Torg12SellerTitleInfo::has_grounds() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Torg12SellerTitleInfo::set_has_grounds() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Torg12SellerTitleInfo::clear_has_grounds() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Torg12SellerTitleInfo::clear_grounds() {
  if (grounds_ != NULL) grounds_->::Diadoc::Api::Proto::Invoicing::Grounds::Clear();
  clear_has_grounds();
}
inline const ::Diadoc::Api::Proto::Invoicing::Grounds& Torg12SellerTitleInfo::grounds() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.Torg12SellerTitleInfo.Grounds)
  return grounds_ != NULL ? *grounds_ : *default_instance_->grounds_;
}
inline ::Diadoc::Api::Proto::Invoicing::Grounds* Torg12SellerTitleInfo::mutable_grounds() {
  set_has_grounds();
  if (grounds_ == NULL) grounds_ = new ::Diadoc::Api::Proto::Invoicing::Grounds;
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.Torg12SellerTitleInfo.Grounds)
  return grounds_;
}
inline ::Diadoc::Api::Proto::Invoicing::Grounds* Torg12SellerTitleInfo::release_grounds() {
  clear_has_grounds();
  ::Diadoc::Api::Proto::Invoicing::Grounds* temp = grounds_;
  grounds_ = NULL;
  return temp;
}
inline void Torg12SellerTitleInfo::set_allocated_grounds(::Diadoc::Api::Proto::Invoicing::Grounds* grounds) {
  delete grounds_;
  grounds_ = grounds;
  if (grounds) {
    set_has_grounds();
  } else {
    clear_has_grounds();
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.Torg12SellerTitleInfo.Grounds)
}

// optional string WaybillDate = 10;
inline bool Torg12SellerTitleInfo::has_waybilldate() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Torg12SellerTitleInfo::set_has_waybilldate() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Torg12SellerTitleInfo::clear_has_waybilldate() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Torg12SellerTitleInfo::clear_waybilldate() {
  if (waybilldate_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    waybilldate_->clear();
  }
  clear_has_waybilldate();
}
inline const ::std::string& Torg12SellerTitleInfo::waybilldate() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.Torg12SellerTitleInfo.WaybillDate)
  return *waybilldate_;
}
inline void Torg12SellerTitleInfo::set_waybilldate(const ::std::string& value) {
  set_has_waybilldate();
  if (waybilldate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    waybilldate_ = new ::std::string;
  }
  waybilldate_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.Torg12SellerTitleInfo.WaybillDate)
}
inline void Torg12SellerTitleInfo::set_waybilldate(const char* value) {
  set_has_waybilldate();
  if (waybilldate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    waybilldate_ = new ::std::string;
  }
  waybilldate_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.Torg12SellerTitleInfo.WaybillDate)
}
inline void Torg12SellerTitleInfo::set_waybilldate(const char* value, size_t size) {
  set_has_waybilldate();
  if (waybilldate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    waybilldate_ = new ::std::string;
  }
  waybilldate_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.Torg12SellerTitleInfo.WaybillDate)
}
inline ::std::string* Torg12SellerTitleInfo::mutable_waybilldate() {
  set_has_waybilldate();
  if (waybilldate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    waybilldate_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.Torg12SellerTitleInfo.WaybillDate)
  return waybilldate_;
}
inline ::std::string* Torg12SellerTitleInfo::release_waybilldate() {
  clear_has_waybilldate();
  if (waybilldate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = waybilldate_;
    waybilldate_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Torg12SellerTitleInfo::set_allocated_waybilldate(::std::string* waybilldate) {
  if (waybilldate_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete waybilldate_;
  }
  if (waybilldate) {
    set_has_waybilldate();
    waybilldate_ = waybilldate;
  } else {
    clear_has_waybilldate();
    waybilldate_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.Torg12SellerTitleInfo.WaybillDate)
}

// optional string WaybillNumber = 11;
inline bool Torg12SellerTitleInfo::has_waybillnumber() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Torg12SellerTitleInfo::set_has_waybillnumber() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Torg12SellerTitleInfo::clear_has_waybillnumber() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Torg12SellerTitleInfo::clear_waybillnumber() {
  if (waybillnumber_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    waybillnumber_->clear();
  }
  clear_has_waybillnumber();
}
inline const ::std::string& Torg12SellerTitleInfo::waybillnumber() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.Torg12SellerTitleInfo.WaybillNumber)
  return *waybillnumber_;
}
inline void Torg12SellerTitleInfo::set_waybillnumber(const ::std::string& value) {
  set_has_waybillnumber();
  if (waybillnumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    waybillnumber_ = new ::std::string;
  }
  waybillnumber_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.Torg12SellerTitleInfo.WaybillNumber)
}
inline void Torg12SellerTitleInfo::set_waybillnumber(const char* value) {
  set_has_waybillnumber();
  if (waybillnumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    waybillnumber_ = new ::std::string;
  }
  waybillnumber_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.Torg12SellerTitleInfo.WaybillNumber)
}
inline void Torg12SellerTitleInfo::set_waybillnumber(const char* value, size_t size) {
  set_has_waybillnumber();
  if (waybillnumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    waybillnumber_ = new ::std::string;
  }
  waybillnumber_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.Torg12SellerTitleInfo.WaybillNumber)
}
inline ::std::string* Torg12SellerTitleInfo::mutable_waybillnumber() {
  set_has_waybillnumber();
  if (waybillnumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    waybillnumber_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.Torg12SellerTitleInfo.WaybillNumber)
  return waybillnumber_;
}
inline ::std::string* Torg12SellerTitleInfo::release_waybillnumber() {
  clear_has_waybillnumber();
  if (waybillnumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = waybillnumber_;
    waybillnumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Torg12SellerTitleInfo::set_allocated_waybillnumber(::std::string* waybillnumber) {
  if (waybillnumber_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete waybillnumber_;
  }
  if (waybillnumber) {
    set_has_waybillnumber();
    waybillnumber_ = waybillnumber;
  } else {
    clear_has_waybillnumber();
    waybillnumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.Torg12SellerTitleInfo.WaybillNumber)
}

// optional string OperationCode = 12;
inline bool Torg12SellerTitleInfo::has_operationcode() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Torg12SellerTitleInfo::set_has_operationcode() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Torg12SellerTitleInfo::clear_has_operationcode() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Torg12SellerTitleInfo::clear_operationcode() {
  if (operationcode_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    operationcode_->clear();
  }
  clear_has_operationcode();
}
inline const ::std::string& Torg12SellerTitleInfo::operationcode() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.Torg12SellerTitleInfo.OperationCode)
  return *operationcode_;
}
inline void Torg12SellerTitleInfo::set_operationcode(const ::std::string& value) {
  set_has_operationcode();
  if (operationcode_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    operationcode_ = new ::std::string;
  }
  operationcode_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.Torg12SellerTitleInfo.OperationCode)
}
inline void Torg12SellerTitleInfo::set_operationcode(const char* value) {
  set_has_operationcode();
  if (operationcode_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    operationcode_ = new ::std::string;
  }
  operationcode_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.Torg12SellerTitleInfo.OperationCode)
}
inline void Torg12SellerTitleInfo::set_operationcode(const char* value, size_t size) {
  set_has_operationcode();
  if (operationcode_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    operationcode_ = new ::std::string;
  }
  operationcode_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.Torg12SellerTitleInfo.OperationCode)
}
inline ::std::string* Torg12SellerTitleInfo::mutable_operationcode() {
  set_has_operationcode();
  if (operationcode_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    operationcode_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.Torg12SellerTitleInfo.OperationCode)
  return operationcode_;
}
inline ::std::string* Torg12SellerTitleInfo::release_operationcode() {
  clear_has_operationcode();
  if (operationcode_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = operationcode_;
    operationcode_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Torg12SellerTitleInfo::set_allocated_operationcode(::std::string* operationcode) {
  if (operationcode_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete operationcode_;
  }
  if (operationcode) {
    set_has_operationcode();
    operationcode_ = operationcode;
  } else {
    clear_has_operationcode();
    operationcode_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.Torg12SellerTitleInfo.OperationCode)
}

// repeated .Diadoc.Api.Proto.Invoicing.Torg12Item Items = 13;
inline int Torg12SellerTitleInfo::items_size() const {
  return items_.size();
}
inline void Torg12SellerTitleInfo::clear_items() {
  items_.Clear();
}
inline const ::Diadoc::Api::Proto::Invoicing::Torg12Item& Torg12SellerTitleInfo::items(int index) const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.Torg12SellerTitleInfo.Items)
  return items_.Get(index);
}
inline ::Diadoc::Api::Proto::Invoicing::Torg12Item* Torg12SellerTitleInfo::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.Torg12SellerTitleInfo.Items)
  return items_.Mutable(index);
}
inline ::Diadoc::Api::Proto::Invoicing::Torg12Item* Torg12SellerTitleInfo::add_items() {
  // @@protoc_insertion_point(field_add:Diadoc.Api.Proto.Invoicing.Torg12SellerTitleInfo.Items)
  return items_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::Torg12Item >&
Torg12SellerTitleInfo::items() const {
  // @@protoc_insertion_point(field_list:Diadoc.Api.Proto.Invoicing.Torg12SellerTitleInfo.Items)
  return items_;
}
inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::Torg12Item >*
Torg12SellerTitleInfo::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:Diadoc.Api.Proto.Invoicing.Torg12SellerTitleInfo.Items)
  return &items_;
}

// optional string ParcelsQuantityTotal = 14;
inline bool Torg12SellerTitleInfo::has_parcelsquantitytotal() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Torg12SellerTitleInfo::set_has_parcelsquantitytotal() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Torg12SellerTitleInfo::clear_has_parcelsquantitytotal() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Torg12SellerTitleInfo::clear_parcelsquantitytotal() {
  if (parcelsquantitytotal_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    parcelsquantitytotal_->clear();
  }
  clear_has_parcelsquantitytotal();
}
inline const ::std::string& Torg12SellerTitleInfo::parcelsquantitytotal() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.Torg12SellerTitleInfo.ParcelsQuantityTotal)
  return *parcelsquantitytotal_;
}
inline void Torg12SellerTitleInfo::set_parcelsquantitytotal(const ::std::string& value) {
  set_has_parcelsquantitytotal();
  if (parcelsquantitytotal_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    parcelsquantitytotal_ = new ::std::string;
  }
  parcelsquantitytotal_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.Torg12SellerTitleInfo.ParcelsQuantityTotal)
}
inline void Torg12SellerTitleInfo::set_parcelsquantitytotal(const char* value) {
  set_has_parcelsquantitytotal();
  if (parcelsquantitytotal_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    parcelsquantitytotal_ = new ::std::string;
  }
  parcelsquantitytotal_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.Torg12SellerTitleInfo.ParcelsQuantityTotal)
}
inline void Torg12SellerTitleInfo::set_parcelsquantitytotal(const char* value, size_t size) {
  set_has_parcelsquantitytotal();
  if (parcelsquantitytotal_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    parcelsquantitytotal_ = new ::std::string;
  }
  parcelsquantitytotal_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.Torg12SellerTitleInfo.ParcelsQuantityTotal)
}
inline ::std::string* Torg12SellerTitleInfo::mutable_parcelsquantitytotal() {
  set_has_parcelsquantitytotal();
  if (parcelsquantitytotal_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    parcelsquantitytotal_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.Torg12SellerTitleInfo.ParcelsQuantityTotal)
  return parcelsquantitytotal_;
}
inline ::std::string* Torg12SellerTitleInfo::release_parcelsquantitytotal() {
  clear_has_parcelsquantitytotal();
  if (parcelsquantitytotal_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = parcelsquantitytotal_;
    parcelsquantitytotal_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Torg12SellerTitleInfo::set_allocated_parcelsquantitytotal(::std::string* parcelsquantitytotal) {
  if (parcelsquantitytotal_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete parcelsquantitytotal_;
  }
  if (parcelsquantitytotal) {
    set_has_parcelsquantitytotal();
    parcelsquantitytotal_ = parcelsquantitytotal;
  } else {
    clear_has_parcelsquantitytotal();
    parcelsquantitytotal_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.Torg12SellerTitleInfo.ParcelsQuantityTotal)
}

// optional string ParcelsQuantityTotalInWords = 15;
inline bool Torg12SellerTitleInfo::has_parcelsquantitytotalinwords() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Torg12SellerTitleInfo::set_has_parcelsquantitytotalinwords() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Torg12SellerTitleInfo::clear_has_parcelsquantitytotalinwords() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void Torg12SellerTitleInfo::clear_parcelsquantitytotalinwords() {
  if (parcelsquantitytotalinwords_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    parcelsquantitytotalinwords_->clear();
  }
  clear_has_parcelsquantitytotalinwords();
}
inline const ::std::string& Torg12SellerTitleInfo::parcelsquantitytotalinwords() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.Torg12SellerTitleInfo.ParcelsQuantityTotalInWords)
  return *parcelsquantitytotalinwords_;
}
inline void Torg12SellerTitleInfo::set_parcelsquantitytotalinwords(const ::std::string& value) {
  set_has_parcelsquantitytotalinwords();
  if (parcelsquantitytotalinwords_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    parcelsquantitytotalinwords_ = new ::std::string;
  }
  parcelsquantitytotalinwords_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.Torg12SellerTitleInfo.ParcelsQuantityTotalInWords)
}
inline void Torg12SellerTitleInfo::set_parcelsquantitytotalinwords(const char* value) {
  set_has_parcelsquantitytotalinwords();
  if (parcelsquantitytotalinwords_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    parcelsquantitytotalinwords_ = new ::std::string;
  }
  parcelsquantitytotalinwords_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.Torg12SellerTitleInfo.ParcelsQuantityTotalInWords)
}
inline void Torg12SellerTitleInfo::set_parcelsquantitytotalinwords(const char* value, size_t size) {
  set_has_parcelsquantitytotalinwords();
  if (parcelsquantitytotalinwords_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    parcelsquantitytotalinwords_ = new ::std::string;
  }
  parcelsquantitytotalinwords_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.Torg12SellerTitleInfo.ParcelsQuantityTotalInWords)
}
inline ::std::string* Torg12SellerTitleInfo::mutable_parcelsquantitytotalinwords() {
  set_has_parcelsquantitytotalinwords();
  if (parcelsquantitytotalinwords_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    parcelsquantitytotalinwords_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.Torg12SellerTitleInfo.ParcelsQuantityTotalInWords)
  return parcelsquantitytotalinwords_;
}
inline ::std::string* Torg12SellerTitleInfo::release_parcelsquantitytotalinwords() {
  clear_has_parcelsquantitytotalinwords();
  if (parcelsquantitytotalinwords_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = parcelsquantitytotalinwords_;
    parcelsquantitytotalinwords_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Torg12SellerTitleInfo::set_allocated_parcelsquantitytotalinwords(::std::string* parcelsquantitytotalinwords) {
  if (parcelsquantitytotalinwords_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete parcelsquantitytotalinwords_;
  }
  if (parcelsquantitytotalinwords) {
    set_has_parcelsquantitytotalinwords();
    parcelsquantitytotalinwords_ = parcelsquantitytotalinwords;
  } else {
    clear_has_parcelsquantitytotalinwords();
    parcelsquantitytotalinwords_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.Torg12SellerTitleInfo.ParcelsQuantityTotalInWords)
}

// optional string GrossQuantityTotal = 16;
inline bool Torg12SellerTitleInfo::has_grossquantitytotal() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void Torg12SellerTitleInfo::set_has_grossquantitytotal() {
  _has_bits_[0] |= 0x00008000u;
}
inline void Torg12SellerTitleInfo::clear_has_grossquantitytotal() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void Torg12SellerTitleInfo::clear_grossquantitytotal() {
  if (grossquantitytotal_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    grossquantitytotal_->clear();
  }
  clear_has_grossquantitytotal();
}
inline const ::std::string& Torg12SellerTitleInfo::grossquantitytotal() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.Torg12SellerTitleInfo.GrossQuantityTotal)
  return *grossquantitytotal_;
}
inline void Torg12SellerTitleInfo::set_grossquantitytotal(const ::std::string& value) {
  set_has_grossquantitytotal();
  if (grossquantitytotal_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    grossquantitytotal_ = new ::std::string;
  }
  grossquantitytotal_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.Torg12SellerTitleInfo.GrossQuantityTotal)
}
inline void Torg12SellerTitleInfo::set_grossquantitytotal(const char* value) {
  set_has_grossquantitytotal();
  if (grossquantitytotal_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    grossquantitytotal_ = new ::std::string;
  }
  grossquantitytotal_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.Torg12SellerTitleInfo.GrossQuantityTotal)
}
inline void Torg12SellerTitleInfo::set_grossquantitytotal(const char* value, size_t size) {
  set_has_grossquantitytotal();
  if (grossquantitytotal_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    grossquantitytotal_ = new ::std::string;
  }
  grossquantitytotal_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.Torg12SellerTitleInfo.GrossQuantityTotal)
}
inline ::std::string* Torg12SellerTitleInfo::mutable_grossquantitytotal() {
  set_has_grossquantitytotal();
  if (grossquantitytotal_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    grossquantitytotal_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.Torg12SellerTitleInfo.GrossQuantityTotal)
  return grossquantitytotal_;
}
inline ::std::string* Torg12SellerTitleInfo::release_grossquantitytotal() {
  clear_has_grossquantitytotal();
  if (grossquantitytotal_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = grossquantitytotal_;
    grossquantitytotal_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Torg12SellerTitleInfo::set_allocated_grossquantitytotal(::std::string* grossquantitytotal) {
  if (grossquantitytotal_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete grossquantitytotal_;
  }
  if (grossquantitytotal) {
    set_has_grossquantitytotal();
    grossquantitytotal_ = grossquantitytotal;
  } else {
    clear_has_grossquantitytotal();
    grossquantitytotal_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.Torg12SellerTitleInfo.GrossQuantityTotal)
}

// optional string GrossQuantityTotalInWords = 17;
inline bool Torg12SellerTitleInfo::has_grossquantitytotalinwords() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void Torg12SellerTitleInfo::set_has_grossquantitytotalinwords() {
  _has_bits_[0] |= 0x00010000u;
}
inline void Torg12SellerTitleInfo::clear_has_grossquantitytotalinwords() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void Torg12SellerTitleInfo::clear_grossquantitytotalinwords() {
  if (grossquantitytotalinwords_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    grossquantitytotalinwords_->clear();
  }
  clear_has_grossquantitytotalinwords();
}
inline const ::std::string& Torg12SellerTitleInfo::grossquantitytotalinwords() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.Torg12SellerTitleInfo.GrossQuantityTotalInWords)
  return *grossquantitytotalinwords_;
}
inline void Torg12SellerTitleInfo::set_grossquantitytotalinwords(const ::std::string& value) {
  set_has_grossquantitytotalinwords();
  if (grossquantitytotalinwords_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    grossquantitytotalinwords_ = new ::std::string;
  }
  grossquantitytotalinwords_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.Torg12SellerTitleInfo.GrossQuantityTotalInWords)
}
inline void Torg12SellerTitleInfo::set_grossquantitytotalinwords(const char* value) {
  set_has_grossquantitytotalinwords();
  if (grossquantitytotalinwords_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    grossquantitytotalinwords_ = new ::std::string;
  }
  grossquantitytotalinwords_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.Torg12SellerTitleInfo.GrossQuantityTotalInWords)
}
inline void Torg12SellerTitleInfo::set_grossquantitytotalinwords(const char* value, size_t size) {
  set_has_grossquantitytotalinwords();
  if (grossquantitytotalinwords_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    grossquantitytotalinwords_ = new ::std::string;
  }
  grossquantitytotalinwords_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.Torg12SellerTitleInfo.GrossQuantityTotalInWords)
}
inline ::std::string* Torg12SellerTitleInfo::mutable_grossquantitytotalinwords() {
  set_has_grossquantitytotalinwords();
  if (grossquantitytotalinwords_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    grossquantitytotalinwords_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.Torg12SellerTitleInfo.GrossQuantityTotalInWords)
  return grossquantitytotalinwords_;
}
inline ::std::string* Torg12SellerTitleInfo::release_grossquantitytotalinwords() {
  clear_has_grossquantitytotalinwords();
  if (grossquantitytotalinwords_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = grossquantitytotalinwords_;
    grossquantitytotalinwords_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Torg12SellerTitleInfo::set_allocated_grossquantitytotalinwords(::std::string* grossquantitytotalinwords) {
  if (grossquantitytotalinwords_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete grossquantitytotalinwords_;
  }
  if (grossquantitytotalinwords) {
    set_has_grossquantitytotalinwords();
    grossquantitytotalinwords_ = grossquantitytotalinwords;
  } else {
    clear_has_grossquantitytotalinwords();
    grossquantitytotalinwords_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.Torg12SellerTitleInfo.GrossQuantityTotalInWords)
}

// optional string NetQuantityTotal = 18;
inline bool Torg12SellerTitleInfo::has_netquantitytotal() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void Torg12SellerTitleInfo::set_has_netquantitytotal() {
  _has_bits_[0] |= 0x00020000u;
}
inline void Torg12SellerTitleInfo::clear_has_netquantitytotal() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void Torg12SellerTitleInfo::clear_netquantitytotal() {
  if (netquantitytotal_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    netquantitytotal_->clear();
  }
  clear_has_netquantitytotal();
}
inline const ::std::string& Torg12SellerTitleInfo::netquantitytotal() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.Torg12SellerTitleInfo.NetQuantityTotal)
  return *netquantitytotal_;
}
inline void Torg12SellerTitleInfo::set_netquantitytotal(const ::std::string& value) {
  set_has_netquantitytotal();
  if (netquantitytotal_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    netquantitytotal_ = new ::std::string;
  }
  netquantitytotal_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.Torg12SellerTitleInfo.NetQuantityTotal)
}
inline void Torg12SellerTitleInfo::set_netquantitytotal(const char* value) {
  set_has_netquantitytotal();
  if (netquantitytotal_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    netquantitytotal_ = new ::std::string;
  }
  netquantitytotal_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.Torg12SellerTitleInfo.NetQuantityTotal)
}
inline void Torg12SellerTitleInfo::set_netquantitytotal(const char* value, size_t size) {
  set_has_netquantitytotal();
  if (netquantitytotal_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    netquantitytotal_ = new ::std::string;
  }
  netquantitytotal_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.Torg12SellerTitleInfo.NetQuantityTotal)
}
inline ::std::string* Torg12SellerTitleInfo::mutable_netquantitytotal() {
  set_has_netquantitytotal();
  if (netquantitytotal_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    netquantitytotal_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.Torg12SellerTitleInfo.NetQuantityTotal)
  return netquantitytotal_;
}
inline ::std::string* Torg12SellerTitleInfo::release_netquantitytotal() {
  clear_has_netquantitytotal();
  if (netquantitytotal_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = netquantitytotal_;
    netquantitytotal_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Torg12SellerTitleInfo::set_allocated_netquantitytotal(::std::string* netquantitytotal) {
  if (netquantitytotal_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete netquantitytotal_;
  }
  if (netquantitytotal) {
    set_has_netquantitytotal();
    netquantitytotal_ = netquantitytotal;
  } else {
    clear_has_netquantitytotal();
    netquantitytotal_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.Torg12SellerTitleInfo.NetQuantityTotal)
}

// optional string NetQuantityTotalInWords = 19;
inline bool Torg12SellerTitleInfo::has_netquantitytotalinwords() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void Torg12SellerTitleInfo::set_has_netquantitytotalinwords() {
  _has_bits_[0] |= 0x00040000u;
}
inline void Torg12SellerTitleInfo::clear_has_netquantitytotalinwords() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void Torg12SellerTitleInfo::clear_netquantitytotalinwords() {
  if (netquantitytotalinwords_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    netquantitytotalinwords_->clear();
  }
  clear_has_netquantitytotalinwords();
}
inline const ::std::string& Torg12SellerTitleInfo::netquantitytotalinwords() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.Torg12SellerTitleInfo.NetQuantityTotalInWords)
  return *netquantitytotalinwords_;
}
inline void Torg12SellerTitleInfo::set_netquantitytotalinwords(const ::std::string& value) {
  set_has_netquantitytotalinwords();
  if (netquantitytotalinwords_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    netquantitytotalinwords_ = new ::std::string;
  }
  netquantitytotalinwords_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.Torg12SellerTitleInfo.NetQuantityTotalInWords)
}
inline void Torg12SellerTitleInfo::set_netquantitytotalinwords(const char* value) {
  set_has_netquantitytotalinwords();
  if (netquantitytotalinwords_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    netquantitytotalinwords_ = new ::std::string;
  }
  netquantitytotalinwords_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.Torg12SellerTitleInfo.NetQuantityTotalInWords)
}
inline void Torg12SellerTitleInfo::set_netquantitytotalinwords(const char* value, size_t size) {
  set_has_netquantitytotalinwords();
  if (netquantitytotalinwords_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    netquantitytotalinwords_ = new ::std::string;
  }
  netquantitytotalinwords_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.Torg12SellerTitleInfo.NetQuantityTotalInWords)
}
inline ::std::string* Torg12SellerTitleInfo::mutable_netquantitytotalinwords() {
  set_has_netquantitytotalinwords();
  if (netquantitytotalinwords_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    netquantitytotalinwords_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.Torg12SellerTitleInfo.NetQuantityTotalInWords)
  return netquantitytotalinwords_;
}
inline ::std::string* Torg12SellerTitleInfo::release_netquantitytotalinwords() {
  clear_has_netquantitytotalinwords();
  if (netquantitytotalinwords_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = netquantitytotalinwords_;
    netquantitytotalinwords_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Torg12SellerTitleInfo::set_allocated_netquantitytotalinwords(::std::string* netquantitytotalinwords) {
  if (netquantitytotalinwords_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete netquantitytotalinwords_;
  }
  if (netquantitytotalinwords) {
    set_has_netquantitytotalinwords();
    netquantitytotalinwords_ = netquantitytotalinwords;
  } else {
    clear_has_netquantitytotalinwords();
    netquantitytotalinwords_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.Torg12SellerTitleInfo.NetQuantityTotalInWords)
}

// optional string QuantityTotal = 20;
inline bool Torg12SellerTitleInfo::has_quantitytotal() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void Torg12SellerTitleInfo::set_has_quantitytotal() {
  _has_bits_[0] |= 0x00080000u;
}
inline void Torg12SellerTitleInfo::clear_has_quantitytotal() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void Torg12SellerTitleInfo::clear_quantitytotal() {
  if (quantitytotal_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    quantitytotal_->clear();
  }
  clear_has_quantitytotal();
}
inline const ::std::string& Torg12SellerTitleInfo::quantitytotal() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.Torg12SellerTitleInfo.QuantityTotal)
  return *quantitytotal_;
}
inline void Torg12SellerTitleInfo::set_quantitytotal(const ::std::string& value) {
  set_has_quantitytotal();
  if (quantitytotal_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    quantitytotal_ = new ::std::string;
  }
  quantitytotal_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.Torg12SellerTitleInfo.QuantityTotal)
}
inline void Torg12SellerTitleInfo::set_quantitytotal(const char* value) {
  set_has_quantitytotal();
  if (quantitytotal_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    quantitytotal_ = new ::std::string;
  }
  quantitytotal_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.Torg12SellerTitleInfo.QuantityTotal)
}
inline void Torg12SellerTitleInfo::set_quantitytotal(const char* value, size_t size) {
  set_has_quantitytotal();
  if (quantitytotal_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    quantitytotal_ = new ::std::string;
  }
  quantitytotal_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.Torg12SellerTitleInfo.QuantityTotal)
}
inline ::std::string* Torg12SellerTitleInfo::mutable_quantitytotal() {
  set_has_quantitytotal();
  if (quantitytotal_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    quantitytotal_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.Torg12SellerTitleInfo.QuantityTotal)
  return quantitytotal_;
}
inline ::std::string* Torg12SellerTitleInfo::release_quantitytotal() {
  clear_has_quantitytotal();
  if (quantitytotal_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = quantitytotal_;
    quantitytotal_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Torg12SellerTitleInfo::set_allocated_quantitytotal(::std::string* quantitytotal) {
  if (quantitytotal_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete quantitytotal_;
  }
  if (quantitytotal) {
    set_has_quantitytotal();
    quantitytotal_ = quantitytotal;
  } else {
    clear_has_quantitytotal();
    quantitytotal_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.Torg12SellerTitleInfo.QuantityTotal)
}

// optional string TotalWithVatExcluded = 21;
inline bool Torg12SellerTitleInfo::has_totalwithvatexcluded() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void Torg12SellerTitleInfo::set_has_totalwithvatexcluded() {
  _has_bits_[0] |= 0x00100000u;
}
inline void Torg12SellerTitleInfo::clear_has_totalwithvatexcluded() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void Torg12SellerTitleInfo::clear_totalwithvatexcluded() {
  if (totalwithvatexcluded_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    totalwithvatexcluded_->clear();
  }
  clear_has_totalwithvatexcluded();
}
inline const ::std::string& Torg12SellerTitleInfo::totalwithvatexcluded() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.Torg12SellerTitleInfo.TotalWithVatExcluded)
  return *totalwithvatexcluded_;
}
inline void Torg12SellerTitleInfo::set_totalwithvatexcluded(const ::std::string& value) {
  set_has_totalwithvatexcluded();
  if (totalwithvatexcluded_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    totalwithvatexcluded_ = new ::std::string;
  }
  totalwithvatexcluded_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.Torg12SellerTitleInfo.TotalWithVatExcluded)
}
inline void Torg12SellerTitleInfo::set_totalwithvatexcluded(const char* value) {
  set_has_totalwithvatexcluded();
  if (totalwithvatexcluded_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    totalwithvatexcluded_ = new ::std::string;
  }
  totalwithvatexcluded_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.Torg12SellerTitleInfo.TotalWithVatExcluded)
}
inline void Torg12SellerTitleInfo::set_totalwithvatexcluded(const char* value, size_t size) {
  set_has_totalwithvatexcluded();
  if (totalwithvatexcluded_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    totalwithvatexcluded_ = new ::std::string;
  }
  totalwithvatexcluded_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.Torg12SellerTitleInfo.TotalWithVatExcluded)
}
inline ::std::string* Torg12SellerTitleInfo::mutable_totalwithvatexcluded() {
  set_has_totalwithvatexcluded();
  if (totalwithvatexcluded_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    totalwithvatexcluded_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.Torg12SellerTitleInfo.TotalWithVatExcluded)
  return totalwithvatexcluded_;
}
inline ::std::string* Torg12SellerTitleInfo::release_totalwithvatexcluded() {
  clear_has_totalwithvatexcluded();
  if (totalwithvatexcluded_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = totalwithvatexcluded_;
    totalwithvatexcluded_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Torg12SellerTitleInfo::set_allocated_totalwithvatexcluded(::std::string* totalwithvatexcluded) {
  if (totalwithvatexcluded_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete totalwithvatexcluded_;
  }
  if (totalwithvatexcluded) {
    set_has_totalwithvatexcluded();
    totalwithvatexcluded_ = totalwithvatexcluded;
  } else {
    clear_has_totalwithvatexcluded();
    totalwithvatexcluded_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.Torg12SellerTitleInfo.TotalWithVatExcluded)
}

// optional string Vat = 22;
inline bool Torg12SellerTitleInfo::has_vat() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void Torg12SellerTitleInfo::set_has_vat() {
  _has_bits_[0] |= 0x00200000u;
}
inline void Torg12SellerTitleInfo::clear_has_vat() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void Torg12SellerTitleInfo::clear_vat() {
  if (vat_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vat_->clear();
  }
  clear_has_vat();
}
inline const ::std::string& Torg12SellerTitleInfo::vat() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.Torg12SellerTitleInfo.Vat)
  return *vat_;
}
inline void Torg12SellerTitleInfo::set_vat(const ::std::string& value) {
  set_has_vat();
  if (vat_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vat_ = new ::std::string;
  }
  vat_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.Torg12SellerTitleInfo.Vat)
}
inline void Torg12SellerTitleInfo::set_vat(const char* value) {
  set_has_vat();
  if (vat_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vat_ = new ::std::string;
  }
  vat_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.Torg12SellerTitleInfo.Vat)
}
inline void Torg12SellerTitleInfo::set_vat(const char* value, size_t size) {
  set_has_vat();
  if (vat_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vat_ = new ::std::string;
  }
  vat_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.Torg12SellerTitleInfo.Vat)
}
inline ::std::string* Torg12SellerTitleInfo::mutable_vat() {
  set_has_vat();
  if (vat_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vat_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.Torg12SellerTitleInfo.Vat)
  return vat_;
}
inline ::std::string* Torg12SellerTitleInfo::release_vat() {
  clear_has_vat();
  if (vat_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = vat_;
    vat_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Torg12SellerTitleInfo::set_allocated_vat(::std::string* vat) {
  if (vat_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete vat_;
  }
  if (vat) {
    set_has_vat();
    vat_ = vat;
  } else {
    clear_has_vat();
    vat_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.Torg12SellerTitleInfo.Vat)
}

// required string Total = 23;
inline bool Torg12SellerTitleInfo::has_total() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void Torg12SellerTitleInfo::set_has_total() {
  _has_bits_[0] |= 0x00400000u;
}
inline void Torg12SellerTitleInfo::clear_has_total() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void Torg12SellerTitleInfo::clear_total() {
  if (total_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    total_->clear();
  }
  clear_has_total();
}
inline const ::std::string& Torg12SellerTitleInfo::total() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.Torg12SellerTitleInfo.Total)
  return *total_;
}
inline void Torg12SellerTitleInfo::set_total(const ::std::string& value) {
  set_has_total();
  if (total_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    total_ = new ::std::string;
  }
  total_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.Torg12SellerTitleInfo.Total)
}
inline void Torg12SellerTitleInfo::set_total(const char* value) {
  set_has_total();
  if (total_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    total_ = new ::std::string;
  }
  total_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.Torg12SellerTitleInfo.Total)
}
inline void Torg12SellerTitleInfo::set_total(const char* value, size_t size) {
  set_has_total();
  if (total_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    total_ = new ::std::string;
  }
  total_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.Torg12SellerTitleInfo.Total)
}
inline ::std::string* Torg12SellerTitleInfo::mutable_total() {
  set_has_total();
  if (total_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    total_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.Torg12SellerTitleInfo.Total)
  return total_;
}
inline ::std::string* Torg12SellerTitleInfo::release_total() {
  clear_has_total();
  if (total_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = total_;
    total_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Torg12SellerTitleInfo::set_allocated_total(::std::string* total) {
  if (total_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete total_;
  }
  if (total) {
    set_has_total();
    total_ = total;
  } else {
    clear_has_total();
    total_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.Torg12SellerTitleInfo.Total)
}

// optional string TotalInWords = 24;
inline bool Torg12SellerTitleInfo::has_totalinwords() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void Torg12SellerTitleInfo::set_has_totalinwords() {
  _has_bits_[0] |= 0x00800000u;
}
inline void Torg12SellerTitleInfo::clear_has_totalinwords() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void Torg12SellerTitleInfo::clear_totalinwords() {
  if (totalinwords_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    totalinwords_->clear();
  }
  clear_has_totalinwords();
}
inline const ::std::string& Torg12SellerTitleInfo::totalinwords() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.Torg12SellerTitleInfo.TotalInWords)
  return *totalinwords_;
}
inline void Torg12SellerTitleInfo::set_totalinwords(const ::std::string& value) {
  set_has_totalinwords();
  if (totalinwords_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    totalinwords_ = new ::std::string;
  }
  totalinwords_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.Torg12SellerTitleInfo.TotalInWords)
}
inline void Torg12SellerTitleInfo::set_totalinwords(const char* value) {
  set_has_totalinwords();
  if (totalinwords_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    totalinwords_ = new ::std::string;
  }
  totalinwords_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.Torg12SellerTitleInfo.TotalInWords)
}
inline void Torg12SellerTitleInfo::set_totalinwords(const char* value, size_t size) {
  set_has_totalinwords();
  if (totalinwords_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    totalinwords_ = new ::std::string;
  }
  totalinwords_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.Torg12SellerTitleInfo.TotalInWords)
}
inline ::std::string* Torg12SellerTitleInfo::mutable_totalinwords() {
  set_has_totalinwords();
  if (totalinwords_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    totalinwords_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.Torg12SellerTitleInfo.TotalInWords)
  return totalinwords_;
}
inline ::std::string* Torg12SellerTitleInfo::release_totalinwords() {
  clear_has_totalinwords();
  if (totalinwords_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = totalinwords_;
    totalinwords_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Torg12SellerTitleInfo::set_allocated_totalinwords(::std::string* totalinwords) {
  if (totalinwords_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete totalinwords_;
  }
  if (totalinwords) {
    set_has_totalinwords();
    totalinwords_ = totalinwords;
  } else {
    clear_has_totalinwords();
    totalinwords_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.Torg12SellerTitleInfo.TotalInWords)
}

// optional string SupplyDate = 25;
inline bool Torg12SellerTitleInfo::has_supplydate() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void Torg12SellerTitleInfo::set_has_supplydate() {
  _has_bits_[0] |= 0x01000000u;
}
inline void Torg12SellerTitleInfo::clear_has_supplydate() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void Torg12SellerTitleInfo::clear_supplydate() {
  if (supplydate_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    supplydate_->clear();
  }
  clear_has_supplydate();
}
inline const ::std::string& Torg12SellerTitleInfo::supplydate() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.Torg12SellerTitleInfo.SupplyDate)
  return *supplydate_;
}
inline void Torg12SellerTitleInfo::set_supplydate(const ::std::string& value) {
  set_has_supplydate();
  if (supplydate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    supplydate_ = new ::std::string;
  }
  supplydate_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.Torg12SellerTitleInfo.SupplyDate)
}
inline void Torg12SellerTitleInfo::set_supplydate(const char* value) {
  set_has_supplydate();
  if (supplydate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    supplydate_ = new ::std::string;
  }
  supplydate_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.Torg12SellerTitleInfo.SupplyDate)
}
inline void Torg12SellerTitleInfo::set_supplydate(const char* value, size_t size) {
  set_has_supplydate();
  if (supplydate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    supplydate_ = new ::std::string;
  }
  supplydate_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.Torg12SellerTitleInfo.SupplyDate)
}
inline ::std::string* Torg12SellerTitleInfo::mutable_supplydate() {
  set_has_supplydate();
  if (supplydate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    supplydate_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.Torg12SellerTitleInfo.SupplyDate)
  return supplydate_;
}
inline ::std::string* Torg12SellerTitleInfo::release_supplydate() {
  clear_has_supplydate();
  if (supplydate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = supplydate_;
    supplydate_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Torg12SellerTitleInfo::set_allocated_supplydate(::std::string* supplydate) {
  if (supplydate_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete supplydate_;
  }
  if (supplydate) {
    set_has_supplydate();
    supplydate_ = supplydate;
  } else {
    clear_has_supplydate();
    supplydate_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.Torg12SellerTitleInfo.SupplyDate)
}

// optional .Diadoc.Api.Proto.Invoicing.Official SupplyAllowedBy = 26;
inline bool Torg12SellerTitleInfo::has_supplyallowedby() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void Torg12SellerTitleInfo::set_has_supplyallowedby() {
  _has_bits_[0] |= 0x02000000u;
}
inline void Torg12SellerTitleInfo::clear_has_supplyallowedby() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void Torg12SellerTitleInfo::clear_supplyallowedby() {
  if (supplyallowedby_ != NULL) supplyallowedby_->::Diadoc::Api::Proto::Invoicing::Official::Clear();
  clear_has_supplyallowedby();
}
inline const ::Diadoc::Api::Proto::Invoicing::Official& Torg12SellerTitleInfo::supplyallowedby() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.Torg12SellerTitleInfo.SupplyAllowedBy)
  return supplyallowedby_ != NULL ? *supplyallowedby_ : *default_instance_->supplyallowedby_;
}
inline ::Diadoc::Api::Proto::Invoicing::Official* Torg12SellerTitleInfo::mutable_supplyallowedby() {
  set_has_supplyallowedby();
  if (supplyallowedby_ == NULL) supplyallowedby_ = new ::Diadoc::Api::Proto::Invoicing::Official;
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.Torg12SellerTitleInfo.SupplyAllowedBy)
  return supplyallowedby_;
}
inline ::Diadoc::Api::Proto::Invoicing::Official* Torg12SellerTitleInfo::release_supplyallowedby() {
  clear_has_supplyallowedby();
  ::Diadoc::Api::Proto::Invoicing::Official* temp = supplyallowedby_;
  supplyallowedby_ = NULL;
  return temp;
}
inline void Torg12SellerTitleInfo::set_allocated_supplyallowedby(::Diadoc::Api::Proto::Invoicing::Official* supplyallowedby) {
  delete supplyallowedby_;
  supplyallowedby_ = supplyallowedby;
  if (supplyallowedby) {
    set_has_supplyallowedby();
  } else {
    clear_has_supplyallowedby();
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.Torg12SellerTitleInfo.SupplyAllowedBy)
}

// optional .Diadoc.Api.Proto.Invoicing.Official SupplyPerformedBy = 27;
inline bool Torg12SellerTitleInfo::has_supplyperformedby() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void Torg12SellerTitleInfo::set_has_supplyperformedby() {
  _has_bits_[0] |= 0x04000000u;
}
inline void Torg12SellerTitleInfo::clear_has_supplyperformedby() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void Torg12SellerTitleInfo::clear_supplyperformedby() {
  if (supplyperformedby_ != NULL) supplyperformedby_->::Diadoc::Api::Proto::Invoicing::Official::Clear();
  clear_has_supplyperformedby();
}
inline const ::Diadoc::Api::Proto::Invoicing::Official& Torg12SellerTitleInfo::supplyperformedby() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.Torg12SellerTitleInfo.SupplyPerformedBy)
  return supplyperformedby_ != NULL ? *supplyperformedby_ : *default_instance_->supplyperformedby_;
}
inline ::Diadoc::Api::Proto::Invoicing::Official* Torg12SellerTitleInfo::mutable_supplyperformedby() {
  set_has_supplyperformedby();
  if (supplyperformedby_ == NULL) supplyperformedby_ = new ::Diadoc::Api::Proto::Invoicing::Official;
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.Torg12SellerTitleInfo.SupplyPerformedBy)
  return supplyperformedby_;
}
inline ::Diadoc::Api::Proto::Invoicing::Official* Torg12SellerTitleInfo::release_supplyperformedby() {
  clear_has_supplyperformedby();
  ::Diadoc::Api::Proto::Invoicing::Official* temp = supplyperformedby_;
  supplyperformedby_ = NULL;
  return temp;
}
inline void Torg12SellerTitleInfo::set_allocated_supplyperformedby(::Diadoc::Api::Proto::Invoicing::Official* supplyperformedby) {
  delete supplyperformedby_;
  supplyperformedby_ = supplyperformedby;
  if (supplyperformedby) {
    set_has_supplyperformedby();
  } else {
    clear_has_supplyperformedby();
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.Torg12SellerTitleInfo.SupplyPerformedBy)
}

// optional .Diadoc.Api.Proto.Invoicing.Official ChiefAccountant = 28;
inline bool Torg12SellerTitleInfo::has_chiefaccountant() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void Torg12SellerTitleInfo::set_has_chiefaccountant() {
  _has_bits_[0] |= 0x08000000u;
}
inline void Torg12SellerTitleInfo::clear_has_chiefaccountant() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void Torg12SellerTitleInfo::clear_chiefaccountant() {
  if (chiefaccountant_ != NULL) chiefaccountant_->::Diadoc::Api::Proto::Invoicing::Official::Clear();
  clear_has_chiefaccountant();
}
inline const ::Diadoc::Api::Proto::Invoicing::Official& Torg12SellerTitleInfo::chiefaccountant() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.Torg12SellerTitleInfo.ChiefAccountant)
  return chiefaccountant_ != NULL ? *chiefaccountant_ : *default_instance_->chiefaccountant_;
}
inline ::Diadoc::Api::Proto::Invoicing::Official* Torg12SellerTitleInfo::mutable_chiefaccountant() {
  set_has_chiefaccountant();
  if (chiefaccountant_ == NULL) chiefaccountant_ = new ::Diadoc::Api::Proto::Invoicing::Official;
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.Torg12SellerTitleInfo.ChiefAccountant)
  return chiefaccountant_;
}
inline ::Diadoc::Api::Proto::Invoicing::Official* Torg12SellerTitleInfo::release_chiefaccountant() {
  clear_has_chiefaccountant();
  ::Diadoc::Api::Proto::Invoicing::Official* temp = chiefaccountant_;
  chiefaccountant_ = NULL;
  return temp;
}
inline void Torg12SellerTitleInfo::set_allocated_chiefaccountant(::Diadoc::Api::Proto::Invoicing::Official* chiefaccountant) {
  delete chiefaccountant_;
  chiefaccountant_ = chiefaccountant;
  if (chiefaccountant) {
    set_has_chiefaccountant();
  } else {
    clear_has_chiefaccountant();
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.Torg12SellerTitleInfo.ChiefAccountant)
}

// required .Diadoc.Api.Proto.Invoicing.Signer Signer = 29;
inline bool Torg12SellerTitleInfo::has_signer() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void Torg12SellerTitleInfo::set_has_signer() {
  _has_bits_[0] |= 0x10000000u;
}
inline void Torg12SellerTitleInfo::clear_has_signer() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void Torg12SellerTitleInfo::clear_signer() {
  if (signer_ != NULL) signer_->::Diadoc::Api::Proto::Invoicing::Signer::Clear();
  clear_has_signer();
}
inline const ::Diadoc::Api::Proto::Invoicing::Signer& Torg12SellerTitleInfo::signer() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.Torg12SellerTitleInfo.Signer)
  return signer_ != NULL ? *signer_ : *default_instance_->signer_;
}
inline ::Diadoc::Api::Proto::Invoicing::Signer* Torg12SellerTitleInfo::mutable_signer() {
  set_has_signer();
  if (signer_ == NULL) signer_ = new ::Diadoc::Api::Proto::Invoicing::Signer;
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.Torg12SellerTitleInfo.Signer)
  return signer_;
}
inline ::Diadoc::Api::Proto::Invoicing::Signer* Torg12SellerTitleInfo::release_signer() {
  clear_has_signer();
  ::Diadoc::Api::Proto::Invoicing::Signer* temp = signer_;
  signer_ = NULL;
  return temp;
}
inline void Torg12SellerTitleInfo::set_allocated_signer(::Diadoc::Api::Proto::Invoicing::Signer* signer) {
  delete signer_;
  signer_ = signer;
  if (signer) {
    set_has_signer();
  } else {
    clear_has_signer();
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.Torg12SellerTitleInfo.Signer)
}

// optional string AdditionalInfo = 30;
inline bool Torg12SellerTitleInfo::has_additionalinfo() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void Torg12SellerTitleInfo::set_has_additionalinfo() {
  _has_bits_[0] |= 0x20000000u;
}
inline void Torg12SellerTitleInfo::clear_has_additionalinfo() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void Torg12SellerTitleInfo::clear_additionalinfo() {
  if (additionalinfo_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    additionalinfo_->clear();
  }
  clear_has_additionalinfo();
}
inline const ::std::string& Torg12SellerTitleInfo::additionalinfo() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.Torg12SellerTitleInfo.AdditionalInfo)
  return *additionalinfo_;
}
inline void Torg12SellerTitleInfo::set_additionalinfo(const ::std::string& value) {
  set_has_additionalinfo();
  if (additionalinfo_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    additionalinfo_ = new ::std::string;
  }
  additionalinfo_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.Torg12SellerTitleInfo.AdditionalInfo)
}
inline void Torg12SellerTitleInfo::set_additionalinfo(const char* value) {
  set_has_additionalinfo();
  if (additionalinfo_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    additionalinfo_ = new ::std::string;
  }
  additionalinfo_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.Torg12SellerTitleInfo.AdditionalInfo)
}
inline void Torg12SellerTitleInfo::set_additionalinfo(const char* value, size_t size) {
  set_has_additionalinfo();
  if (additionalinfo_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    additionalinfo_ = new ::std::string;
  }
  additionalinfo_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.Torg12SellerTitleInfo.AdditionalInfo)
}
inline ::std::string* Torg12SellerTitleInfo::mutable_additionalinfo() {
  set_has_additionalinfo();
  if (additionalinfo_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    additionalinfo_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.Torg12SellerTitleInfo.AdditionalInfo)
  return additionalinfo_;
}
inline ::std::string* Torg12SellerTitleInfo::release_additionalinfo() {
  clear_has_additionalinfo();
  if (additionalinfo_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = additionalinfo_;
    additionalinfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Torg12SellerTitleInfo::set_allocated_additionalinfo(::std::string* additionalinfo) {
  if (additionalinfo_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete additionalinfo_;
  }
  if (additionalinfo) {
    set_has_additionalinfo();
    additionalinfo_ = additionalinfo;
  } else {
    clear_has_additionalinfo();
    additionalinfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.Torg12SellerTitleInfo.AdditionalInfo)
}

// optional string AttachmentSheetsQuantity = 31;
inline bool Torg12SellerTitleInfo::has_attachmentsheetsquantity() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void Torg12SellerTitleInfo::set_has_attachmentsheetsquantity() {
  _has_bits_[0] |= 0x40000000u;
}
inline void Torg12SellerTitleInfo::clear_has_attachmentsheetsquantity() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void Torg12SellerTitleInfo::clear_attachmentsheetsquantity() {
  if (attachmentsheetsquantity_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attachmentsheetsquantity_->clear();
  }
  clear_has_attachmentsheetsquantity();
}
inline const ::std::string& Torg12SellerTitleInfo::attachmentsheetsquantity() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.Torg12SellerTitleInfo.AttachmentSheetsQuantity)
  return *attachmentsheetsquantity_;
}
inline void Torg12SellerTitleInfo::set_attachmentsheetsquantity(const ::std::string& value) {
  set_has_attachmentsheetsquantity();
  if (attachmentsheetsquantity_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attachmentsheetsquantity_ = new ::std::string;
  }
  attachmentsheetsquantity_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.Torg12SellerTitleInfo.AttachmentSheetsQuantity)
}
inline void Torg12SellerTitleInfo::set_attachmentsheetsquantity(const char* value) {
  set_has_attachmentsheetsquantity();
  if (attachmentsheetsquantity_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attachmentsheetsquantity_ = new ::std::string;
  }
  attachmentsheetsquantity_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.Torg12SellerTitleInfo.AttachmentSheetsQuantity)
}
inline void Torg12SellerTitleInfo::set_attachmentsheetsquantity(const char* value, size_t size) {
  set_has_attachmentsheetsquantity();
  if (attachmentsheetsquantity_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attachmentsheetsquantity_ = new ::std::string;
  }
  attachmentsheetsquantity_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.Torg12SellerTitleInfo.AttachmentSheetsQuantity)
}
inline ::std::string* Torg12SellerTitleInfo::mutable_attachmentsheetsquantity() {
  set_has_attachmentsheetsquantity();
  if (attachmentsheetsquantity_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attachmentsheetsquantity_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.Torg12SellerTitleInfo.AttachmentSheetsQuantity)
  return attachmentsheetsquantity_;
}
inline ::std::string* Torg12SellerTitleInfo::release_attachmentsheetsquantity() {
  clear_has_attachmentsheetsquantity();
  if (attachmentsheetsquantity_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attachmentsheetsquantity_;
    attachmentsheetsquantity_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Torg12SellerTitleInfo::set_allocated_attachmentsheetsquantity(::std::string* attachmentsheetsquantity) {
  if (attachmentsheetsquantity_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attachmentsheetsquantity_;
  }
  if (attachmentsheetsquantity) {
    set_has_attachmentsheetsquantity();
    attachmentsheetsquantity_ = attachmentsheetsquantity;
  } else {
    clear_has_attachmentsheetsquantity();
    attachmentsheetsquantity_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.Torg12SellerTitleInfo.AttachmentSheetsQuantity)
}

// -------------------------------------------------------------------

// Torg12BuyerTitleInfo

// required string ShipmentReceiptDate = 1;
inline bool Torg12BuyerTitleInfo::has_shipmentreceiptdate() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Torg12BuyerTitleInfo::set_has_shipmentreceiptdate() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Torg12BuyerTitleInfo::clear_has_shipmentreceiptdate() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Torg12BuyerTitleInfo::clear_shipmentreceiptdate() {
  if (shipmentreceiptdate_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    shipmentreceiptdate_->clear();
  }
  clear_has_shipmentreceiptdate();
}
inline const ::std::string& Torg12BuyerTitleInfo::shipmentreceiptdate() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.Torg12BuyerTitleInfo.ShipmentReceiptDate)
  return *shipmentreceiptdate_;
}
inline void Torg12BuyerTitleInfo::set_shipmentreceiptdate(const ::std::string& value) {
  set_has_shipmentreceiptdate();
  if (shipmentreceiptdate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    shipmentreceiptdate_ = new ::std::string;
  }
  shipmentreceiptdate_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.Torg12BuyerTitleInfo.ShipmentReceiptDate)
}
inline void Torg12BuyerTitleInfo::set_shipmentreceiptdate(const char* value) {
  set_has_shipmentreceiptdate();
  if (shipmentreceiptdate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    shipmentreceiptdate_ = new ::std::string;
  }
  shipmentreceiptdate_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.Torg12BuyerTitleInfo.ShipmentReceiptDate)
}
inline void Torg12BuyerTitleInfo::set_shipmentreceiptdate(const char* value, size_t size) {
  set_has_shipmentreceiptdate();
  if (shipmentreceiptdate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    shipmentreceiptdate_ = new ::std::string;
  }
  shipmentreceiptdate_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.Torg12BuyerTitleInfo.ShipmentReceiptDate)
}
inline ::std::string* Torg12BuyerTitleInfo::mutable_shipmentreceiptdate() {
  set_has_shipmentreceiptdate();
  if (shipmentreceiptdate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    shipmentreceiptdate_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.Torg12BuyerTitleInfo.ShipmentReceiptDate)
  return shipmentreceiptdate_;
}
inline ::std::string* Torg12BuyerTitleInfo::release_shipmentreceiptdate() {
  clear_has_shipmentreceiptdate();
  if (shipmentreceiptdate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = shipmentreceiptdate_;
    shipmentreceiptdate_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Torg12BuyerTitleInfo::set_allocated_shipmentreceiptdate(::std::string* shipmentreceiptdate) {
  if (shipmentreceiptdate_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete shipmentreceiptdate_;
  }
  if (shipmentreceiptdate) {
    set_has_shipmentreceiptdate();
    shipmentreceiptdate_ = shipmentreceiptdate;
  } else {
    clear_has_shipmentreceiptdate();
    shipmentreceiptdate_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.Torg12BuyerTitleInfo.ShipmentReceiptDate)
}

// optional .Diadoc.Api.Proto.Invoicing.Attorney Attorney = 2;
inline bool Torg12BuyerTitleInfo::has_attorney() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Torg12BuyerTitleInfo::set_has_attorney() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Torg12BuyerTitleInfo::clear_has_attorney() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Torg12BuyerTitleInfo::clear_attorney() {
  if (attorney_ != NULL) attorney_->::Diadoc::Api::Proto::Invoicing::Attorney::Clear();
  clear_has_attorney();
}
inline const ::Diadoc::Api::Proto::Invoicing::Attorney& Torg12BuyerTitleInfo::attorney() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.Torg12BuyerTitleInfo.Attorney)
  return attorney_ != NULL ? *attorney_ : *default_instance_->attorney_;
}
inline ::Diadoc::Api::Proto::Invoicing::Attorney* Torg12BuyerTitleInfo::mutable_attorney() {
  set_has_attorney();
  if (attorney_ == NULL) attorney_ = new ::Diadoc::Api::Proto::Invoicing::Attorney;
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.Torg12BuyerTitleInfo.Attorney)
  return attorney_;
}
inline ::Diadoc::Api::Proto::Invoicing::Attorney* Torg12BuyerTitleInfo::release_attorney() {
  clear_has_attorney();
  ::Diadoc::Api::Proto::Invoicing::Attorney* temp = attorney_;
  attorney_ = NULL;
  return temp;
}
inline void Torg12BuyerTitleInfo::set_allocated_attorney(::Diadoc::Api::Proto::Invoicing::Attorney* attorney) {
  delete attorney_;
  attorney_ = attorney;
  if (attorney) {
    set_has_attorney();
  } else {
    clear_has_attorney();
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.Torg12BuyerTitleInfo.Attorney)
}

// optional .Diadoc.Api.Proto.Invoicing.Official AcceptedBy = 3;
inline bool Torg12BuyerTitleInfo::has_acceptedby() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Torg12BuyerTitleInfo::set_has_acceptedby() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Torg12BuyerTitleInfo::clear_has_acceptedby() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Torg12BuyerTitleInfo::clear_acceptedby() {
  if (acceptedby_ != NULL) acceptedby_->::Diadoc::Api::Proto::Invoicing::Official::Clear();
  clear_has_acceptedby();
}
inline const ::Diadoc::Api::Proto::Invoicing::Official& Torg12BuyerTitleInfo::acceptedby() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.Torg12BuyerTitleInfo.AcceptedBy)
  return acceptedby_ != NULL ? *acceptedby_ : *default_instance_->acceptedby_;
}
inline ::Diadoc::Api::Proto::Invoicing::Official* Torg12BuyerTitleInfo::mutable_acceptedby() {
  set_has_acceptedby();
  if (acceptedby_ == NULL) acceptedby_ = new ::Diadoc::Api::Proto::Invoicing::Official;
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.Torg12BuyerTitleInfo.AcceptedBy)
  return acceptedby_;
}
inline ::Diadoc::Api::Proto::Invoicing::Official* Torg12BuyerTitleInfo::release_acceptedby() {
  clear_has_acceptedby();
  ::Diadoc::Api::Proto::Invoicing::Official* temp = acceptedby_;
  acceptedby_ = NULL;
  return temp;
}
inline void Torg12BuyerTitleInfo::set_allocated_acceptedby(::Diadoc::Api::Proto::Invoicing::Official* acceptedby) {
  delete acceptedby_;
  acceptedby_ = acceptedby;
  if (acceptedby) {
    set_has_acceptedby();
  } else {
    clear_has_acceptedby();
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.Torg12BuyerTitleInfo.AcceptedBy)
}

// optional .Diadoc.Api.Proto.Invoicing.Official ReceivedBy = 4;
inline bool Torg12BuyerTitleInfo::has_receivedby() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Torg12BuyerTitleInfo::set_has_receivedby() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Torg12BuyerTitleInfo::clear_has_receivedby() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Torg12BuyerTitleInfo::clear_receivedby() {
  if (receivedby_ != NULL) receivedby_->::Diadoc::Api::Proto::Invoicing::Official::Clear();
  clear_has_receivedby();
}
inline const ::Diadoc::Api::Proto::Invoicing::Official& Torg12BuyerTitleInfo::receivedby() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.Torg12BuyerTitleInfo.ReceivedBy)
  return receivedby_ != NULL ? *receivedby_ : *default_instance_->receivedby_;
}
inline ::Diadoc::Api::Proto::Invoicing::Official* Torg12BuyerTitleInfo::mutable_receivedby() {
  set_has_receivedby();
  if (receivedby_ == NULL) receivedby_ = new ::Diadoc::Api::Proto::Invoicing::Official;
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.Torg12BuyerTitleInfo.ReceivedBy)
  return receivedby_;
}
inline ::Diadoc::Api::Proto::Invoicing::Official* Torg12BuyerTitleInfo::release_receivedby() {
  clear_has_receivedby();
  ::Diadoc::Api::Proto::Invoicing::Official* temp = receivedby_;
  receivedby_ = NULL;
  return temp;
}
inline void Torg12BuyerTitleInfo::set_allocated_receivedby(::Diadoc::Api::Proto::Invoicing::Official* receivedby) {
  delete receivedby_;
  receivedby_ = receivedby;
  if (receivedby) {
    set_has_receivedby();
  } else {
    clear_has_receivedby();
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.Torg12BuyerTitleInfo.ReceivedBy)
}

// required .Diadoc.Api.Proto.Invoicing.Signer Signer = 5;
inline bool Torg12BuyerTitleInfo::has_signer() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Torg12BuyerTitleInfo::set_has_signer() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Torg12BuyerTitleInfo::clear_has_signer() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Torg12BuyerTitleInfo::clear_signer() {
  if (signer_ != NULL) signer_->::Diadoc::Api::Proto::Invoicing::Signer::Clear();
  clear_has_signer();
}
inline const ::Diadoc::Api::Proto::Invoicing::Signer& Torg12BuyerTitleInfo::signer() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.Torg12BuyerTitleInfo.Signer)
  return signer_ != NULL ? *signer_ : *default_instance_->signer_;
}
inline ::Diadoc::Api::Proto::Invoicing::Signer* Torg12BuyerTitleInfo::mutable_signer() {
  set_has_signer();
  if (signer_ == NULL) signer_ = new ::Diadoc::Api::Proto::Invoicing::Signer;
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.Torg12BuyerTitleInfo.Signer)
  return signer_;
}
inline ::Diadoc::Api::Proto::Invoicing::Signer* Torg12BuyerTitleInfo::release_signer() {
  clear_has_signer();
  ::Diadoc::Api::Proto::Invoicing::Signer* temp = signer_;
  signer_ = NULL;
  return temp;
}
inline void Torg12BuyerTitleInfo::set_allocated_signer(::Diadoc::Api::Proto::Invoicing::Signer* signer) {
  delete signer_;
  signer_ = signer;
  if (signer) {
    set_has_signer();
  } else {
    clear_has_signer();
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.Torg12BuyerTitleInfo.Signer)
}

// optional string AdditionalInfo = 6;
inline bool Torg12BuyerTitleInfo::has_additionalinfo() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Torg12BuyerTitleInfo::set_has_additionalinfo() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Torg12BuyerTitleInfo::clear_has_additionalinfo() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Torg12BuyerTitleInfo::clear_additionalinfo() {
  if (additionalinfo_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    additionalinfo_->clear();
  }
  clear_has_additionalinfo();
}
inline const ::std::string& Torg12BuyerTitleInfo::additionalinfo() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.Torg12BuyerTitleInfo.AdditionalInfo)
  return *additionalinfo_;
}
inline void Torg12BuyerTitleInfo::set_additionalinfo(const ::std::string& value) {
  set_has_additionalinfo();
  if (additionalinfo_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    additionalinfo_ = new ::std::string;
  }
  additionalinfo_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.Torg12BuyerTitleInfo.AdditionalInfo)
}
inline void Torg12BuyerTitleInfo::set_additionalinfo(const char* value) {
  set_has_additionalinfo();
  if (additionalinfo_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    additionalinfo_ = new ::std::string;
  }
  additionalinfo_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.Torg12BuyerTitleInfo.AdditionalInfo)
}
inline void Torg12BuyerTitleInfo::set_additionalinfo(const char* value, size_t size) {
  set_has_additionalinfo();
  if (additionalinfo_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    additionalinfo_ = new ::std::string;
  }
  additionalinfo_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.Torg12BuyerTitleInfo.AdditionalInfo)
}
inline ::std::string* Torg12BuyerTitleInfo::mutable_additionalinfo() {
  set_has_additionalinfo();
  if (additionalinfo_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    additionalinfo_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.Torg12BuyerTitleInfo.AdditionalInfo)
  return additionalinfo_;
}
inline ::std::string* Torg12BuyerTitleInfo::release_additionalinfo() {
  clear_has_additionalinfo();
  if (additionalinfo_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = additionalinfo_;
    additionalinfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Torg12BuyerTitleInfo::set_allocated_additionalinfo(::std::string* additionalinfo) {
  if (additionalinfo_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete additionalinfo_;
  }
  if (additionalinfo) {
    set_has_additionalinfo();
    additionalinfo_ = additionalinfo;
  } else {
    clear_has_additionalinfo();
    additionalinfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.Torg12BuyerTitleInfo.AdditionalInfo)
}

// -------------------------------------------------------------------

// Torg12Item

// required string Name = 1;
inline bool Torg12Item::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Torg12Item::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Torg12Item::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Torg12Item::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Torg12Item::name() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.Torg12Item.Name)
  return *name_;
}
inline void Torg12Item::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.Torg12Item.Name)
}
inline void Torg12Item::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.Torg12Item.Name)
}
inline void Torg12Item::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.Torg12Item.Name)
}
inline ::std::string* Torg12Item::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.Torg12Item.Name)
  return name_;
}
inline ::std::string* Torg12Item::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Torg12Item::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.Torg12Item.Name)
}

// optional string Feature = 2;
inline bool Torg12Item::has_feature() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Torg12Item::set_has_feature() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Torg12Item::clear_has_feature() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Torg12Item::clear_feature() {
  if (feature_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    feature_->clear();
  }
  clear_has_feature();
}
inline const ::std::string& Torg12Item::feature() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.Torg12Item.Feature)
  return *feature_;
}
inline void Torg12Item::set_feature(const ::std::string& value) {
  set_has_feature();
  if (feature_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    feature_ = new ::std::string;
  }
  feature_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.Torg12Item.Feature)
}
inline void Torg12Item::set_feature(const char* value) {
  set_has_feature();
  if (feature_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    feature_ = new ::std::string;
  }
  feature_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.Torg12Item.Feature)
}
inline void Torg12Item::set_feature(const char* value, size_t size) {
  set_has_feature();
  if (feature_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    feature_ = new ::std::string;
  }
  feature_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.Torg12Item.Feature)
}
inline ::std::string* Torg12Item::mutable_feature() {
  set_has_feature();
  if (feature_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    feature_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.Torg12Item.Feature)
  return feature_;
}
inline ::std::string* Torg12Item::release_feature() {
  clear_has_feature();
  if (feature_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = feature_;
    feature_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Torg12Item::set_allocated_feature(::std::string* feature) {
  if (feature_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete feature_;
  }
  if (feature) {
    set_has_feature();
    feature_ = feature;
  } else {
    clear_has_feature();
    feature_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.Torg12Item.Feature)
}

// optional string Sort = 3;
inline bool Torg12Item::has_sort() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Torg12Item::set_has_sort() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Torg12Item::clear_has_sort() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Torg12Item::clear_sort() {
  if (sort_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sort_->clear();
  }
  clear_has_sort();
}
inline const ::std::string& Torg12Item::sort() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.Torg12Item.Sort)
  return *sort_;
}
inline void Torg12Item::set_sort(const ::std::string& value) {
  set_has_sort();
  if (sort_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sort_ = new ::std::string;
  }
  sort_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.Torg12Item.Sort)
}
inline void Torg12Item::set_sort(const char* value) {
  set_has_sort();
  if (sort_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sort_ = new ::std::string;
  }
  sort_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.Torg12Item.Sort)
}
inline void Torg12Item::set_sort(const char* value, size_t size) {
  set_has_sort();
  if (sort_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sort_ = new ::std::string;
  }
  sort_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.Torg12Item.Sort)
}
inline ::std::string* Torg12Item::mutable_sort() {
  set_has_sort();
  if (sort_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sort_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.Torg12Item.Sort)
  return sort_;
}
inline ::std::string* Torg12Item::release_sort() {
  clear_has_sort();
  if (sort_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = sort_;
    sort_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Torg12Item::set_allocated_sort(::std::string* sort) {
  if (sort_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete sort_;
  }
  if (sort) {
    set_has_sort();
    sort_ = sort;
  } else {
    clear_has_sort();
    sort_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.Torg12Item.Sort)
}

// optional string NomenclatureArticle = 4;
inline bool Torg12Item::has_nomenclaturearticle() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Torg12Item::set_has_nomenclaturearticle() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Torg12Item::clear_has_nomenclaturearticle() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Torg12Item::clear_nomenclaturearticle() {
  if (nomenclaturearticle_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nomenclaturearticle_->clear();
  }
  clear_has_nomenclaturearticle();
}
inline const ::std::string& Torg12Item::nomenclaturearticle() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.Torg12Item.NomenclatureArticle)
  return *nomenclaturearticle_;
}
inline void Torg12Item::set_nomenclaturearticle(const ::std::string& value) {
  set_has_nomenclaturearticle();
  if (nomenclaturearticle_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nomenclaturearticle_ = new ::std::string;
  }
  nomenclaturearticle_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.Torg12Item.NomenclatureArticle)
}
inline void Torg12Item::set_nomenclaturearticle(const char* value) {
  set_has_nomenclaturearticle();
  if (nomenclaturearticle_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nomenclaturearticle_ = new ::std::string;
  }
  nomenclaturearticle_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.Torg12Item.NomenclatureArticle)
}
inline void Torg12Item::set_nomenclaturearticle(const char* value, size_t size) {
  set_has_nomenclaturearticle();
  if (nomenclaturearticle_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nomenclaturearticle_ = new ::std::string;
  }
  nomenclaturearticle_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.Torg12Item.NomenclatureArticle)
}
inline ::std::string* Torg12Item::mutable_nomenclaturearticle() {
  set_has_nomenclaturearticle();
  if (nomenclaturearticle_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nomenclaturearticle_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.Torg12Item.NomenclatureArticle)
  return nomenclaturearticle_;
}
inline ::std::string* Torg12Item::release_nomenclaturearticle() {
  clear_has_nomenclaturearticle();
  if (nomenclaturearticle_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = nomenclaturearticle_;
    nomenclaturearticle_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Torg12Item::set_allocated_nomenclaturearticle(::std::string* nomenclaturearticle) {
  if (nomenclaturearticle_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete nomenclaturearticle_;
  }
  if (nomenclaturearticle) {
    set_has_nomenclaturearticle();
    nomenclaturearticle_ = nomenclaturearticle;
  } else {
    clear_has_nomenclaturearticle();
    nomenclaturearticle_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.Torg12Item.NomenclatureArticle)
}

// optional string Code = 5;
inline bool Torg12Item::has_code() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Torg12Item::set_has_code() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Torg12Item::clear_has_code() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Torg12Item::clear_code() {
  if (code_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    code_->clear();
  }
  clear_has_code();
}
inline const ::std::string& Torg12Item::code() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.Torg12Item.Code)
  return *code_;
}
inline void Torg12Item::set_code(const ::std::string& value) {
  set_has_code();
  if (code_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    code_ = new ::std::string;
  }
  code_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.Torg12Item.Code)
}
inline void Torg12Item::set_code(const char* value) {
  set_has_code();
  if (code_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    code_ = new ::std::string;
  }
  code_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.Torg12Item.Code)
}
inline void Torg12Item::set_code(const char* value, size_t size) {
  set_has_code();
  if (code_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    code_ = new ::std::string;
  }
  code_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.Torg12Item.Code)
}
inline ::std::string* Torg12Item::mutable_code() {
  set_has_code();
  if (code_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    code_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.Torg12Item.Code)
  return code_;
}
inline ::std::string* Torg12Item::release_code() {
  clear_has_code();
  if (code_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = code_;
    code_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Torg12Item::set_allocated_code(::std::string* code) {
  if (code_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete code_;
  }
  if (code) {
    set_has_code();
    code_ = code;
  } else {
    clear_has_code();
    code_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.Torg12Item.Code)
}

// optional string UnitCode = 6;
inline bool Torg12Item::has_unitcode() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Torg12Item::set_has_unitcode() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Torg12Item::clear_has_unitcode() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Torg12Item::clear_unitcode() {
  if (unitcode_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    unitcode_->clear();
  }
  clear_has_unitcode();
}
inline const ::std::string& Torg12Item::unitcode() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.Torg12Item.UnitCode)
  return *unitcode_;
}
inline void Torg12Item::set_unitcode(const ::std::string& value) {
  set_has_unitcode();
  if (unitcode_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    unitcode_ = new ::std::string;
  }
  unitcode_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.Torg12Item.UnitCode)
}
inline void Torg12Item::set_unitcode(const char* value) {
  set_has_unitcode();
  if (unitcode_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    unitcode_ = new ::std::string;
  }
  unitcode_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.Torg12Item.UnitCode)
}
inline void Torg12Item::set_unitcode(const char* value, size_t size) {
  set_has_unitcode();
  if (unitcode_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    unitcode_ = new ::std::string;
  }
  unitcode_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.Torg12Item.UnitCode)
}
inline ::std::string* Torg12Item::mutable_unitcode() {
  set_has_unitcode();
  if (unitcode_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    unitcode_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.Torg12Item.UnitCode)
  return unitcode_;
}
inline ::std::string* Torg12Item::release_unitcode() {
  clear_has_unitcode();
  if (unitcode_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = unitcode_;
    unitcode_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Torg12Item::set_allocated_unitcode(::std::string* unitcode) {
  if (unitcode_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete unitcode_;
  }
  if (unitcode) {
    set_has_unitcode();
    unitcode_ = unitcode;
  } else {
    clear_has_unitcode();
    unitcode_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.Torg12Item.UnitCode)
}

// required string UnitName = 7;
inline bool Torg12Item::has_unitname() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Torg12Item::set_has_unitname() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Torg12Item::clear_has_unitname() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Torg12Item::clear_unitname() {
  if (unitname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    unitname_->clear();
  }
  clear_has_unitname();
}
inline const ::std::string& Torg12Item::unitname() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.Torg12Item.UnitName)
  return *unitname_;
}
inline void Torg12Item::set_unitname(const ::std::string& value) {
  set_has_unitname();
  if (unitname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    unitname_ = new ::std::string;
  }
  unitname_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.Torg12Item.UnitName)
}
inline void Torg12Item::set_unitname(const char* value) {
  set_has_unitname();
  if (unitname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    unitname_ = new ::std::string;
  }
  unitname_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.Torg12Item.UnitName)
}
inline void Torg12Item::set_unitname(const char* value, size_t size) {
  set_has_unitname();
  if (unitname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    unitname_ = new ::std::string;
  }
  unitname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.Torg12Item.UnitName)
}
inline ::std::string* Torg12Item::mutable_unitname() {
  set_has_unitname();
  if (unitname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    unitname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.Torg12Item.UnitName)
  return unitname_;
}
inline ::std::string* Torg12Item::release_unitname() {
  clear_has_unitname();
  if (unitname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = unitname_;
    unitname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Torg12Item::set_allocated_unitname(::std::string* unitname) {
  if (unitname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete unitname_;
  }
  if (unitname) {
    set_has_unitname();
    unitname_ = unitname;
  } else {
    clear_has_unitname();
    unitname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.Torg12Item.UnitName)
}

// optional string ParcelType = 8;
inline bool Torg12Item::has_parceltype() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Torg12Item::set_has_parceltype() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Torg12Item::clear_has_parceltype() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Torg12Item::clear_parceltype() {
  if (parceltype_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    parceltype_->clear();
  }
  clear_has_parceltype();
}
inline const ::std::string& Torg12Item::parceltype() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.Torg12Item.ParcelType)
  return *parceltype_;
}
inline void Torg12Item::set_parceltype(const ::std::string& value) {
  set_has_parceltype();
  if (parceltype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    parceltype_ = new ::std::string;
  }
  parceltype_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.Torg12Item.ParcelType)
}
inline void Torg12Item::set_parceltype(const char* value) {
  set_has_parceltype();
  if (parceltype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    parceltype_ = new ::std::string;
  }
  parceltype_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.Torg12Item.ParcelType)
}
inline void Torg12Item::set_parceltype(const char* value, size_t size) {
  set_has_parceltype();
  if (parceltype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    parceltype_ = new ::std::string;
  }
  parceltype_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.Torg12Item.ParcelType)
}
inline ::std::string* Torg12Item::mutable_parceltype() {
  set_has_parceltype();
  if (parceltype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    parceltype_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.Torg12Item.ParcelType)
  return parceltype_;
}
inline ::std::string* Torg12Item::release_parceltype() {
  clear_has_parceltype();
  if (parceltype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = parceltype_;
    parceltype_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Torg12Item::set_allocated_parceltype(::std::string* parceltype) {
  if (parceltype_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete parceltype_;
  }
  if (parceltype) {
    set_has_parceltype();
    parceltype_ = parceltype;
  } else {
    clear_has_parceltype();
    parceltype_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.Torg12Item.ParcelType)
}

// optional string ParcelCapacity = 9;
inline bool Torg12Item::has_parcelcapacity() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Torg12Item::set_has_parcelcapacity() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Torg12Item::clear_has_parcelcapacity() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Torg12Item::clear_parcelcapacity() {
  if (parcelcapacity_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    parcelcapacity_->clear();
  }
  clear_has_parcelcapacity();
}
inline const ::std::string& Torg12Item::parcelcapacity() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.Torg12Item.ParcelCapacity)
  return *parcelcapacity_;
}
inline void Torg12Item::set_parcelcapacity(const ::std::string& value) {
  set_has_parcelcapacity();
  if (parcelcapacity_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    parcelcapacity_ = new ::std::string;
  }
  parcelcapacity_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.Torg12Item.ParcelCapacity)
}
inline void Torg12Item::set_parcelcapacity(const char* value) {
  set_has_parcelcapacity();
  if (parcelcapacity_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    parcelcapacity_ = new ::std::string;
  }
  parcelcapacity_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.Torg12Item.ParcelCapacity)
}
inline void Torg12Item::set_parcelcapacity(const char* value, size_t size) {
  set_has_parcelcapacity();
  if (parcelcapacity_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    parcelcapacity_ = new ::std::string;
  }
  parcelcapacity_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.Torg12Item.ParcelCapacity)
}
inline ::std::string* Torg12Item::mutable_parcelcapacity() {
  set_has_parcelcapacity();
  if (parcelcapacity_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    parcelcapacity_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.Torg12Item.ParcelCapacity)
  return parcelcapacity_;
}
inline ::std::string* Torg12Item::release_parcelcapacity() {
  clear_has_parcelcapacity();
  if (parcelcapacity_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = parcelcapacity_;
    parcelcapacity_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Torg12Item::set_allocated_parcelcapacity(::std::string* parcelcapacity) {
  if (parcelcapacity_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete parcelcapacity_;
  }
  if (parcelcapacity) {
    set_has_parcelcapacity();
    parcelcapacity_ = parcelcapacity;
  } else {
    clear_has_parcelcapacity();
    parcelcapacity_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.Torg12Item.ParcelCapacity)
}

// optional string ParcelsQuantity = 10;
inline bool Torg12Item::has_parcelsquantity() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Torg12Item::set_has_parcelsquantity() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Torg12Item::clear_has_parcelsquantity() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Torg12Item::clear_parcelsquantity() {
  if (parcelsquantity_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    parcelsquantity_->clear();
  }
  clear_has_parcelsquantity();
}
inline const ::std::string& Torg12Item::parcelsquantity() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.Torg12Item.ParcelsQuantity)
  return *parcelsquantity_;
}
inline void Torg12Item::set_parcelsquantity(const ::std::string& value) {
  set_has_parcelsquantity();
  if (parcelsquantity_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    parcelsquantity_ = new ::std::string;
  }
  parcelsquantity_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.Torg12Item.ParcelsQuantity)
}
inline void Torg12Item::set_parcelsquantity(const char* value) {
  set_has_parcelsquantity();
  if (parcelsquantity_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    parcelsquantity_ = new ::std::string;
  }
  parcelsquantity_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.Torg12Item.ParcelsQuantity)
}
inline void Torg12Item::set_parcelsquantity(const char* value, size_t size) {
  set_has_parcelsquantity();
  if (parcelsquantity_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    parcelsquantity_ = new ::std::string;
  }
  parcelsquantity_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.Torg12Item.ParcelsQuantity)
}
inline ::std::string* Torg12Item::mutable_parcelsquantity() {
  set_has_parcelsquantity();
  if (parcelsquantity_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    parcelsquantity_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.Torg12Item.ParcelsQuantity)
  return parcelsquantity_;
}
inline ::std::string* Torg12Item::release_parcelsquantity() {
  clear_has_parcelsquantity();
  if (parcelsquantity_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = parcelsquantity_;
    parcelsquantity_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Torg12Item::set_allocated_parcelsquantity(::std::string* parcelsquantity) {
  if (parcelsquantity_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete parcelsquantity_;
  }
  if (parcelsquantity) {
    set_has_parcelsquantity();
    parcelsquantity_ = parcelsquantity;
  } else {
    clear_has_parcelsquantity();
    parcelsquantity_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.Torg12Item.ParcelsQuantity)
}

// optional string GrossQuantity = 11;
inline bool Torg12Item::has_grossquantity() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Torg12Item::set_has_grossquantity() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Torg12Item::clear_has_grossquantity() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Torg12Item::clear_grossquantity() {
  if (grossquantity_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    grossquantity_->clear();
  }
  clear_has_grossquantity();
}
inline const ::std::string& Torg12Item::grossquantity() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.Torg12Item.GrossQuantity)
  return *grossquantity_;
}
inline void Torg12Item::set_grossquantity(const ::std::string& value) {
  set_has_grossquantity();
  if (grossquantity_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    grossquantity_ = new ::std::string;
  }
  grossquantity_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.Torg12Item.GrossQuantity)
}
inline void Torg12Item::set_grossquantity(const char* value) {
  set_has_grossquantity();
  if (grossquantity_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    grossquantity_ = new ::std::string;
  }
  grossquantity_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.Torg12Item.GrossQuantity)
}
inline void Torg12Item::set_grossquantity(const char* value, size_t size) {
  set_has_grossquantity();
  if (grossquantity_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    grossquantity_ = new ::std::string;
  }
  grossquantity_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.Torg12Item.GrossQuantity)
}
inline ::std::string* Torg12Item::mutable_grossquantity() {
  set_has_grossquantity();
  if (grossquantity_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    grossquantity_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.Torg12Item.GrossQuantity)
  return grossquantity_;
}
inline ::std::string* Torg12Item::release_grossquantity() {
  clear_has_grossquantity();
  if (grossquantity_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = grossquantity_;
    grossquantity_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Torg12Item::set_allocated_grossquantity(::std::string* grossquantity) {
  if (grossquantity_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete grossquantity_;
  }
  if (grossquantity) {
    set_has_grossquantity();
    grossquantity_ = grossquantity;
  } else {
    clear_has_grossquantity();
    grossquantity_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.Torg12Item.GrossQuantity)
}

// required string Quantity = 12;
inline bool Torg12Item::has_quantity() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Torg12Item::set_has_quantity() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Torg12Item::clear_has_quantity() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Torg12Item::clear_quantity() {
  if (quantity_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    quantity_->clear();
  }
  clear_has_quantity();
}
inline const ::std::string& Torg12Item::quantity() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.Torg12Item.Quantity)
  return *quantity_;
}
inline void Torg12Item::set_quantity(const ::std::string& value) {
  set_has_quantity();
  if (quantity_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    quantity_ = new ::std::string;
  }
  quantity_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.Torg12Item.Quantity)
}
inline void Torg12Item::set_quantity(const char* value) {
  set_has_quantity();
  if (quantity_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    quantity_ = new ::std::string;
  }
  quantity_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.Torg12Item.Quantity)
}
inline void Torg12Item::set_quantity(const char* value, size_t size) {
  set_has_quantity();
  if (quantity_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    quantity_ = new ::std::string;
  }
  quantity_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.Torg12Item.Quantity)
}
inline ::std::string* Torg12Item::mutable_quantity() {
  set_has_quantity();
  if (quantity_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    quantity_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.Torg12Item.Quantity)
  return quantity_;
}
inline ::std::string* Torg12Item::release_quantity() {
  clear_has_quantity();
  if (quantity_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = quantity_;
    quantity_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Torg12Item::set_allocated_quantity(::std::string* quantity) {
  if (quantity_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete quantity_;
  }
  if (quantity) {
    set_has_quantity();
    quantity_ = quantity;
  } else {
    clear_has_quantity();
    quantity_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.Torg12Item.Quantity)
}

// optional string Price = 13;
inline bool Torg12Item::has_price() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Torg12Item::set_has_price() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Torg12Item::clear_has_price() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Torg12Item::clear_price() {
  if (price_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    price_->clear();
  }
  clear_has_price();
}
inline const ::std::string& Torg12Item::price() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.Torg12Item.Price)
  return *price_;
}
inline void Torg12Item::set_price(const ::std::string& value) {
  set_has_price();
  if (price_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    price_ = new ::std::string;
  }
  price_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.Torg12Item.Price)
}
inline void Torg12Item::set_price(const char* value) {
  set_has_price();
  if (price_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    price_ = new ::std::string;
  }
  price_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.Torg12Item.Price)
}
inline void Torg12Item::set_price(const char* value, size_t size) {
  set_has_price();
  if (price_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    price_ = new ::std::string;
  }
  price_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.Torg12Item.Price)
}
inline ::std::string* Torg12Item::mutable_price() {
  set_has_price();
  if (price_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    price_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.Torg12Item.Price)
  return price_;
}
inline ::std::string* Torg12Item::release_price() {
  clear_has_price();
  if (price_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = price_;
    price_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Torg12Item::set_allocated_price(::std::string* price) {
  if (price_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete price_;
  }
  if (price) {
    set_has_price();
    price_ = price;
  } else {
    clear_has_price();
    price_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.Torg12Item.Price)
}

// required string TaxRate = 14;
inline bool Torg12Item::has_taxrate() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Torg12Item::set_has_taxrate() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Torg12Item::clear_has_taxrate() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Torg12Item::clear_taxrate() {
  if (taxrate_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    taxrate_->clear();
  }
  clear_has_taxrate();
}
inline const ::std::string& Torg12Item::taxrate() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.Torg12Item.TaxRate)
  return *taxrate_;
}
inline void Torg12Item::set_taxrate(const ::std::string& value) {
  set_has_taxrate();
  if (taxrate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    taxrate_ = new ::std::string;
  }
  taxrate_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.Torg12Item.TaxRate)
}
inline void Torg12Item::set_taxrate(const char* value) {
  set_has_taxrate();
  if (taxrate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    taxrate_ = new ::std::string;
  }
  taxrate_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.Torg12Item.TaxRate)
}
inline void Torg12Item::set_taxrate(const char* value, size_t size) {
  set_has_taxrate();
  if (taxrate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    taxrate_ = new ::std::string;
  }
  taxrate_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.Torg12Item.TaxRate)
}
inline ::std::string* Torg12Item::mutable_taxrate() {
  set_has_taxrate();
  if (taxrate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    taxrate_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.Torg12Item.TaxRate)
  return taxrate_;
}
inline ::std::string* Torg12Item::release_taxrate() {
  clear_has_taxrate();
  if (taxrate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = taxrate_;
    taxrate_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Torg12Item::set_allocated_taxrate(::std::string* taxrate) {
  if (taxrate_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete taxrate_;
  }
  if (taxrate) {
    set_has_taxrate();
    taxrate_ = taxrate;
  } else {
    clear_has_taxrate();
    taxrate_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.Torg12Item.TaxRate)
}

// optional string SubtotalWithVatExcluded = 15;
inline bool Torg12Item::has_subtotalwithvatexcluded() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Torg12Item::set_has_subtotalwithvatexcluded() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Torg12Item::clear_has_subtotalwithvatexcluded() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void Torg12Item::clear_subtotalwithvatexcluded() {
  if (subtotalwithvatexcluded_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    subtotalwithvatexcluded_->clear();
  }
  clear_has_subtotalwithvatexcluded();
}
inline const ::std::string& Torg12Item::subtotalwithvatexcluded() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.Torg12Item.SubtotalWithVatExcluded)
  return *subtotalwithvatexcluded_;
}
inline void Torg12Item::set_subtotalwithvatexcluded(const ::std::string& value) {
  set_has_subtotalwithvatexcluded();
  if (subtotalwithvatexcluded_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    subtotalwithvatexcluded_ = new ::std::string;
  }
  subtotalwithvatexcluded_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.Torg12Item.SubtotalWithVatExcluded)
}
inline void Torg12Item::set_subtotalwithvatexcluded(const char* value) {
  set_has_subtotalwithvatexcluded();
  if (subtotalwithvatexcluded_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    subtotalwithvatexcluded_ = new ::std::string;
  }
  subtotalwithvatexcluded_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.Torg12Item.SubtotalWithVatExcluded)
}
inline void Torg12Item::set_subtotalwithvatexcluded(const char* value, size_t size) {
  set_has_subtotalwithvatexcluded();
  if (subtotalwithvatexcluded_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    subtotalwithvatexcluded_ = new ::std::string;
  }
  subtotalwithvatexcluded_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.Torg12Item.SubtotalWithVatExcluded)
}
inline ::std::string* Torg12Item::mutable_subtotalwithvatexcluded() {
  set_has_subtotalwithvatexcluded();
  if (subtotalwithvatexcluded_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    subtotalwithvatexcluded_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.Torg12Item.SubtotalWithVatExcluded)
  return subtotalwithvatexcluded_;
}
inline ::std::string* Torg12Item::release_subtotalwithvatexcluded() {
  clear_has_subtotalwithvatexcluded();
  if (subtotalwithvatexcluded_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = subtotalwithvatexcluded_;
    subtotalwithvatexcluded_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Torg12Item::set_allocated_subtotalwithvatexcluded(::std::string* subtotalwithvatexcluded) {
  if (subtotalwithvatexcluded_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete subtotalwithvatexcluded_;
  }
  if (subtotalwithvatexcluded) {
    set_has_subtotalwithvatexcluded();
    subtotalwithvatexcluded_ = subtotalwithvatexcluded;
  } else {
    clear_has_subtotalwithvatexcluded();
    subtotalwithvatexcluded_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.Torg12Item.SubtotalWithVatExcluded)
}

// optional string Vat = 16;
inline bool Torg12Item::has_vat() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void Torg12Item::set_has_vat() {
  _has_bits_[0] |= 0x00008000u;
}
inline void Torg12Item::clear_has_vat() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void Torg12Item::clear_vat() {
  if (vat_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vat_->clear();
  }
  clear_has_vat();
}
inline const ::std::string& Torg12Item::vat() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.Torg12Item.Vat)
  return *vat_;
}
inline void Torg12Item::set_vat(const ::std::string& value) {
  set_has_vat();
  if (vat_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vat_ = new ::std::string;
  }
  vat_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.Torg12Item.Vat)
}
inline void Torg12Item::set_vat(const char* value) {
  set_has_vat();
  if (vat_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vat_ = new ::std::string;
  }
  vat_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.Torg12Item.Vat)
}
inline void Torg12Item::set_vat(const char* value, size_t size) {
  set_has_vat();
  if (vat_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vat_ = new ::std::string;
  }
  vat_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.Torg12Item.Vat)
}
inline ::std::string* Torg12Item::mutable_vat() {
  set_has_vat();
  if (vat_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vat_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.Torg12Item.Vat)
  return vat_;
}
inline ::std::string* Torg12Item::release_vat() {
  clear_has_vat();
  if (vat_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = vat_;
    vat_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Torg12Item::set_allocated_vat(::std::string* vat) {
  if (vat_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete vat_;
  }
  if (vat) {
    set_has_vat();
    vat_ = vat;
  } else {
    clear_has_vat();
    vat_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.Torg12Item.Vat)
}

// required string Subtotal = 17;
inline bool Torg12Item::has_subtotal() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void Torg12Item::set_has_subtotal() {
  _has_bits_[0] |= 0x00010000u;
}
inline void Torg12Item::clear_has_subtotal() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void Torg12Item::clear_subtotal() {
  if (subtotal_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    subtotal_->clear();
  }
  clear_has_subtotal();
}
inline const ::std::string& Torg12Item::subtotal() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.Torg12Item.Subtotal)
  return *subtotal_;
}
inline void Torg12Item::set_subtotal(const ::std::string& value) {
  set_has_subtotal();
  if (subtotal_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    subtotal_ = new ::std::string;
  }
  subtotal_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.Torg12Item.Subtotal)
}
inline void Torg12Item::set_subtotal(const char* value) {
  set_has_subtotal();
  if (subtotal_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    subtotal_ = new ::std::string;
  }
  subtotal_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.Torg12Item.Subtotal)
}
inline void Torg12Item::set_subtotal(const char* value, size_t size) {
  set_has_subtotal();
  if (subtotal_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    subtotal_ = new ::std::string;
  }
  subtotal_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.Torg12Item.Subtotal)
}
inline ::std::string* Torg12Item::mutable_subtotal() {
  set_has_subtotal();
  if (subtotal_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    subtotal_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.Torg12Item.Subtotal)
  return subtotal_;
}
inline ::std::string* Torg12Item::release_subtotal() {
  clear_has_subtotal();
  if (subtotal_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = subtotal_;
    subtotal_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Torg12Item::set_allocated_subtotal(::std::string* subtotal) {
  if (subtotal_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete subtotal_;
  }
  if (subtotal) {
    set_has_subtotal();
    subtotal_ = subtotal;
  } else {
    clear_has_subtotal();
    subtotal_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.Torg12Item.Subtotal)
}

// optional string AdditionalInfo = 18;
inline bool Torg12Item::has_additionalinfo() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void Torg12Item::set_has_additionalinfo() {
  _has_bits_[0] |= 0x00020000u;
}
inline void Torg12Item::clear_has_additionalinfo() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void Torg12Item::clear_additionalinfo() {
  if (additionalinfo_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    additionalinfo_->clear();
  }
  clear_has_additionalinfo();
}
inline const ::std::string& Torg12Item::additionalinfo() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.Torg12Item.AdditionalInfo)
  return *additionalinfo_;
}
inline void Torg12Item::set_additionalinfo(const ::std::string& value) {
  set_has_additionalinfo();
  if (additionalinfo_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    additionalinfo_ = new ::std::string;
  }
  additionalinfo_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.Torg12Item.AdditionalInfo)
}
inline void Torg12Item::set_additionalinfo(const char* value) {
  set_has_additionalinfo();
  if (additionalinfo_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    additionalinfo_ = new ::std::string;
  }
  additionalinfo_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.Torg12Item.AdditionalInfo)
}
inline void Torg12Item::set_additionalinfo(const char* value, size_t size) {
  set_has_additionalinfo();
  if (additionalinfo_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    additionalinfo_ = new ::std::string;
  }
  additionalinfo_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.Torg12Item.AdditionalInfo)
}
inline ::std::string* Torg12Item::mutable_additionalinfo() {
  set_has_additionalinfo();
  if (additionalinfo_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    additionalinfo_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.Torg12Item.AdditionalInfo)
  return additionalinfo_;
}
inline ::std::string* Torg12Item::release_additionalinfo() {
  clear_has_additionalinfo();
  if (additionalinfo_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = additionalinfo_;
    additionalinfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Torg12Item::set_allocated_additionalinfo(::std::string* additionalinfo) {
  if (additionalinfo_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete additionalinfo_;
  }
  if (additionalinfo) {
    set_has_additionalinfo();
    additionalinfo_ = additionalinfo;
  } else {
    clear_has_additionalinfo();
    additionalinfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.Torg12Item.AdditionalInfo)
}

// -------------------------------------------------------------------

// Grounds

// optional string DocumentName = 1;
inline bool Grounds::has_documentname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Grounds::set_has_documentname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Grounds::clear_has_documentname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Grounds::clear_documentname() {
  if (documentname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    documentname_->clear();
  }
  clear_has_documentname();
}
inline const ::std::string& Grounds::documentname() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.Grounds.DocumentName)
  return *documentname_;
}
inline void Grounds::set_documentname(const ::std::string& value) {
  set_has_documentname();
  if (documentname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    documentname_ = new ::std::string;
  }
  documentname_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.Grounds.DocumentName)
}
inline void Grounds::set_documentname(const char* value) {
  set_has_documentname();
  if (documentname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    documentname_ = new ::std::string;
  }
  documentname_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.Grounds.DocumentName)
}
inline void Grounds::set_documentname(const char* value, size_t size) {
  set_has_documentname();
  if (documentname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    documentname_ = new ::std::string;
  }
  documentname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.Grounds.DocumentName)
}
inline ::std::string* Grounds::mutable_documentname() {
  set_has_documentname();
  if (documentname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    documentname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.Grounds.DocumentName)
  return documentname_;
}
inline ::std::string* Grounds::release_documentname() {
  clear_has_documentname();
  if (documentname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = documentname_;
    documentname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Grounds::set_allocated_documentname(::std::string* documentname) {
  if (documentname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete documentname_;
  }
  if (documentname) {
    set_has_documentname();
    documentname_ = documentname;
  } else {
    clear_has_documentname();
    documentname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.Grounds.DocumentName)
}

// optional string DocumentNumber = 2;
inline bool Grounds::has_documentnumber() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Grounds::set_has_documentnumber() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Grounds::clear_has_documentnumber() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Grounds::clear_documentnumber() {
  if (documentnumber_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    documentnumber_->clear();
  }
  clear_has_documentnumber();
}
inline const ::std::string& Grounds::documentnumber() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.Grounds.DocumentNumber)
  return *documentnumber_;
}
inline void Grounds::set_documentnumber(const ::std::string& value) {
  set_has_documentnumber();
  if (documentnumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    documentnumber_ = new ::std::string;
  }
  documentnumber_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.Grounds.DocumentNumber)
}
inline void Grounds::set_documentnumber(const char* value) {
  set_has_documentnumber();
  if (documentnumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    documentnumber_ = new ::std::string;
  }
  documentnumber_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.Grounds.DocumentNumber)
}
inline void Grounds::set_documentnumber(const char* value, size_t size) {
  set_has_documentnumber();
  if (documentnumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    documentnumber_ = new ::std::string;
  }
  documentnumber_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.Grounds.DocumentNumber)
}
inline ::std::string* Grounds::mutable_documentnumber() {
  set_has_documentnumber();
  if (documentnumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    documentnumber_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.Grounds.DocumentNumber)
  return documentnumber_;
}
inline ::std::string* Grounds::release_documentnumber() {
  clear_has_documentnumber();
  if (documentnumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = documentnumber_;
    documentnumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Grounds::set_allocated_documentnumber(::std::string* documentnumber) {
  if (documentnumber_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete documentnumber_;
  }
  if (documentnumber) {
    set_has_documentnumber();
    documentnumber_ = documentnumber;
  } else {
    clear_has_documentnumber();
    documentnumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.Grounds.DocumentNumber)
}

// optional string DocumentDate = 3;
inline bool Grounds::has_documentdate() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Grounds::set_has_documentdate() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Grounds::clear_has_documentdate() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Grounds::clear_documentdate() {
  if (documentdate_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    documentdate_->clear();
  }
  clear_has_documentdate();
}
inline const ::std::string& Grounds::documentdate() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.Grounds.DocumentDate)
  return *documentdate_;
}
inline void Grounds::set_documentdate(const ::std::string& value) {
  set_has_documentdate();
  if (documentdate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    documentdate_ = new ::std::string;
  }
  documentdate_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.Grounds.DocumentDate)
}
inline void Grounds::set_documentdate(const char* value) {
  set_has_documentdate();
  if (documentdate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    documentdate_ = new ::std::string;
  }
  documentdate_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.Grounds.DocumentDate)
}
inline void Grounds::set_documentdate(const char* value, size_t size) {
  set_has_documentdate();
  if (documentdate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    documentdate_ = new ::std::string;
  }
  documentdate_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.Grounds.DocumentDate)
}
inline ::std::string* Grounds::mutable_documentdate() {
  set_has_documentdate();
  if (documentdate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    documentdate_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.Grounds.DocumentDate)
  return documentdate_;
}
inline ::std::string* Grounds::release_documentdate() {
  clear_has_documentdate();
  if (documentdate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = documentdate_;
    documentdate_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Grounds::set_allocated_documentdate(::std::string* documentdate) {
  if (documentdate_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete documentdate_;
  }
  if (documentdate) {
    set_has_documentdate();
    documentdate_ = documentdate;
  } else {
    clear_has_documentdate();
    documentdate_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.Grounds.DocumentDate)
}

// optional string AdditionalInfo = 4;
inline bool Grounds::has_additionalinfo() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Grounds::set_has_additionalinfo() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Grounds::clear_has_additionalinfo() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Grounds::clear_additionalinfo() {
  if (additionalinfo_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    additionalinfo_->clear();
  }
  clear_has_additionalinfo();
}
inline const ::std::string& Grounds::additionalinfo() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.Grounds.AdditionalInfo)
  return *additionalinfo_;
}
inline void Grounds::set_additionalinfo(const ::std::string& value) {
  set_has_additionalinfo();
  if (additionalinfo_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    additionalinfo_ = new ::std::string;
  }
  additionalinfo_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.Grounds.AdditionalInfo)
}
inline void Grounds::set_additionalinfo(const char* value) {
  set_has_additionalinfo();
  if (additionalinfo_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    additionalinfo_ = new ::std::string;
  }
  additionalinfo_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.Grounds.AdditionalInfo)
}
inline void Grounds::set_additionalinfo(const char* value, size_t size) {
  set_has_additionalinfo();
  if (additionalinfo_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    additionalinfo_ = new ::std::string;
  }
  additionalinfo_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.Grounds.AdditionalInfo)
}
inline ::std::string* Grounds::mutable_additionalinfo() {
  set_has_additionalinfo();
  if (additionalinfo_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    additionalinfo_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.Grounds.AdditionalInfo)
  return additionalinfo_;
}
inline ::std::string* Grounds::release_additionalinfo() {
  clear_has_additionalinfo();
  if (additionalinfo_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = additionalinfo_;
    additionalinfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Grounds::set_allocated_additionalinfo(::std::string* additionalinfo) {
  if (additionalinfo_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete additionalinfo_;
  }
  if (additionalinfo) {
    set_has_additionalinfo();
    additionalinfo_ = additionalinfo;
  } else {
    clear_has_additionalinfo();
    additionalinfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.Grounds.AdditionalInfo)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace Invoicing
}  // namespace Proto
}  // namespace Api
}  // namespace Diadoc

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_Invoicing_2fTorg12Info_2eproto__INCLUDED
