// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Invoicing/UniversalTransferDocumentInfo.proto

#ifndef PROTOBUF_Invoicing_2fUniversalTransferDocumentInfo_2eproto__INCLUDED
#define PROTOBUF_Invoicing_2fUniversalTransferDocumentInfo_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "Invoicing/InvoiceInfo.pb.h"
#include "Invoicing/ExtendedSigner.pb.h"
#include "Invoicing/ExtendedOrganizationInfo.pb.h"
// @@protoc_insertion_point(includes)

namespace Diadoc {
namespace Api {
namespace Proto {
namespace Invoicing {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_Invoicing_2fUniversalTransferDocumentInfo_2eproto();
void protobuf_AssignDesc_Invoicing_2fUniversalTransferDocumentInfo_2eproto();
void protobuf_ShutdownFile_Invoicing_2fUniversalTransferDocumentInfo_2eproto();

class UniversalTransferDocumentSellerTitleInfo;
class Shipper;
class InvoiceTable;
class ExtendedInvoiceItem;
class TransferInfo;
class TransferBase;
class Waybill;
class Employee;
class OtherIssuer;
class AdditionalInfoId;
class UniversalTransferDocumentBuyerTitleInfo;
class UniversalCorrectionDocumentSellerTitleInfo;
class InvoiceForCorrectionInfo;
class InvoiceRevisionInfo;
class EventContent;
class CorrectionBase;
class InvoiceCorrectionTable;
class ExtendedInvoiceCorrectionItem;

enum FunctionType {
  Invoice = 0,
  Basic = 1,
  InvoiceAndBasic = 2
};
bool FunctionType_IsValid(int value);
const FunctionType FunctionType_MIN = Invoice;
const FunctionType FunctionType_MAX = InvoiceAndBasic;
const int FunctionType_ARRAYSIZE = FunctionType_MAX + 1;

const ::google::protobuf::EnumDescriptor* FunctionType_descriptor();
inline const ::std::string& FunctionType_Name(FunctionType value) {
  return ::google::protobuf::internal::NameOfEnum(
    FunctionType_descriptor(), value);
}
inline bool FunctionType_Parse(
    const ::std::string& name, FunctionType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<FunctionType>(
    FunctionType_descriptor(), name, value);
}
enum ItemMark {
  NotSpecified = 0,
  Property = 1,
  Job = 2,
  Service = 3,
  PropertyRights = 4,
  Other = 5
};
bool ItemMark_IsValid(int value);
const ItemMark ItemMark_MIN = NotSpecified;
const ItemMark ItemMark_MAX = Other;
const int ItemMark_ARRAYSIZE = ItemMark_MAX + 1;

const ::google::protobuf::EnumDescriptor* ItemMark_descriptor();
inline const ::std::string& ItemMark_Name(ItemMark value) {
  return ::google::protobuf::internal::NameOfEnum(
    ItemMark_descriptor(), value);
}
inline bool ItemMark_Parse(
    const ::std::string& name, ItemMark* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ItemMark>(
    ItemMark_descriptor(), name, value);
}
// ===================================================================

class UniversalTransferDocumentSellerTitleInfo : public ::google::protobuf::Message {
 public:
  UniversalTransferDocumentSellerTitleInfo();
  virtual ~UniversalTransferDocumentSellerTitleInfo();

  UniversalTransferDocumentSellerTitleInfo(const UniversalTransferDocumentSellerTitleInfo& from);

  inline UniversalTransferDocumentSellerTitleInfo& operator=(const UniversalTransferDocumentSellerTitleInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UniversalTransferDocumentSellerTitleInfo& default_instance();

  void Swap(UniversalTransferDocumentSellerTitleInfo* other);

  // implements Message ----------------------------------------------

  UniversalTransferDocumentSellerTitleInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UniversalTransferDocumentSellerTitleInfo& from);
  void MergeFrom(const UniversalTransferDocumentSellerTitleInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Diadoc.Api.Proto.Invoicing.FunctionType Function = 1;
  inline bool has_function() const;
  inline void clear_function();
  static const int kFunctionFieldNumber = 1;
  inline ::Diadoc::Api::Proto::Invoicing::FunctionType function() const;
  inline void set_function(::Diadoc::Api::Proto::Invoicing::FunctionType value);

  // optional string DocumentName = 2;
  inline bool has_documentname() const;
  inline void clear_documentname();
  static const int kDocumentNameFieldNumber = 2;
  inline const ::std::string& documentname() const;
  inline void set_documentname(const ::std::string& value);
  inline void set_documentname(const char* value);
  inline void set_documentname(const char* value, size_t size);
  inline ::std::string* mutable_documentname();
  inline ::std::string* release_documentname();
  inline void set_allocated_documentname(::std::string* documentname);

  // required string DocumentDate = 3;
  inline bool has_documentdate() const;
  inline void clear_documentdate();
  static const int kDocumentDateFieldNumber = 3;
  inline const ::std::string& documentdate() const;
  inline void set_documentdate(const ::std::string& value);
  inline void set_documentdate(const char* value);
  inline void set_documentdate(const char* value, size_t size);
  inline ::std::string* mutable_documentdate();
  inline ::std::string* release_documentdate();
  inline void set_allocated_documentdate(::std::string* documentdate);

  // required string DocumentNumber = 4;
  inline bool has_documentnumber() const;
  inline void clear_documentnumber();
  static const int kDocumentNumberFieldNumber = 4;
  inline const ::std::string& documentnumber() const;
  inline void set_documentnumber(const ::std::string& value);
  inline void set_documentnumber(const char* value);
  inline void set_documentnumber(const char* value, size_t size);
  inline ::std::string* mutable_documentnumber();
  inline ::std::string* release_documentnumber();
  inline void set_allocated_documentnumber(::std::string* documentnumber);

  // required .Diadoc.Api.Proto.Invoicing.Organizations.ExtendedOrganizationInfo Seller = 5;
  inline bool has_seller() const;
  inline void clear_seller();
  static const int kSellerFieldNumber = 5;
  inline const ::Diadoc::Api::Proto::Invoicing::Organizations::ExtendedOrganizationInfo& seller() const;
  inline ::Diadoc::Api::Proto::Invoicing::Organizations::ExtendedOrganizationInfo* mutable_seller();
  inline ::Diadoc::Api::Proto::Invoicing::Organizations::ExtendedOrganizationInfo* release_seller();
  inline void set_allocated_seller(::Diadoc::Api::Proto::Invoicing::Organizations::ExtendedOrganizationInfo* seller);

  // required .Diadoc.Api.Proto.Invoicing.Organizations.ExtendedOrganizationInfo Buyer = 6;
  inline bool has_buyer() const;
  inline void clear_buyer();
  static const int kBuyerFieldNumber = 6;
  inline const ::Diadoc::Api::Proto::Invoicing::Organizations::ExtendedOrganizationInfo& buyer() const;
  inline ::Diadoc::Api::Proto::Invoicing::Organizations::ExtendedOrganizationInfo* mutable_buyer();
  inline ::Diadoc::Api::Proto::Invoicing::Organizations::ExtendedOrganizationInfo* release_buyer();
  inline void set_allocated_buyer(::Diadoc::Api::Proto::Invoicing::Organizations::ExtendedOrganizationInfo* buyer);

  // optional .Diadoc.Api.Proto.Invoicing.Shipper Shipper = 7;
  inline bool has_shipper() const;
  inline void clear_shipper();
  static const int kShipperFieldNumber = 7;
  inline const ::Diadoc::Api::Proto::Invoicing::Shipper& shipper() const;
  inline ::Diadoc::Api::Proto::Invoicing::Shipper* mutable_shipper();
  inline ::Diadoc::Api::Proto::Invoicing::Shipper* release_shipper();
  inline void set_allocated_shipper(::Diadoc::Api::Proto::Invoicing::Shipper* shipper);

  // optional .Diadoc.Api.Proto.Invoicing.Organizations.ExtendedOrganizationInfo Consignee = 8;
  inline bool has_consignee() const;
  inline void clear_consignee();
  static const int kConsigneeFieldNumber = 8;
  inline const ::Diadoc::Api::Proto::Invoicing::Organizations::ExtendedOrganizationInfo& consignee() const;
  inline ::Diadoc::Api::Proto::Invoicing::Organizations::ExtendedOrganizationInfo* mutable_consignee();
  inline ::Diadoc::Api::Proto::Invoicing::Organizations::ExtendedOrganizationInfo* release_consignee();
  inline void set_allocated_consignee(::Diadoc::Api::Proto::Invoicing::Organizations::ExtendedOrganizationInfo* consignee);

  // repeated .Diadoc.Api.Proto.Invoicing.Signers.ExtendedSigner Signers = 9;
  inline int signers_size() const;
  inline void clear_signers();
  static const int kSignersFieldNumber = 9;
  inline const ::Diadoc::Api::Proto::Invoicing::Signers::ExtendedSigner& signers(int index) const;
  inline ::Diadoc::Api::Proto::Invoicing::Signers::ExtendedSigner* mutable_signers(int index);
  inline ::Diadoc::Api::Proto::Invoicing::Signers::ExtendedSigner* add_signers();
  inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::Signers::ExtendedSigner >&
      signers() const;
  inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::Signers::ExtendedSigner >*
      mutable_signers();

  // repeated .Diadoc.Api.Proto.Invoicing.PaymentDocumentInfo PaymentDocuments = 10;
  inline int paymentdocuments_size() const;
  inline void clear_paymentdocuments();
  static const int kPaymentDocumentsFieldNumber = 10;
  inline const ::Diadoc::Api::Proto::Invoicing::PaymentDocumentInfo& paymentdocuments(int index) const;
  inline ::Diadoc::Api::Proto::Invoicing::PaymentDocumentInfo* mutable_paymentdocuments(int index);
  inline ::Diadoc::Api::Proto::Invoicing::PaymentDocumentInfo* add_paymentdocuments();
  inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::PaymentDocumentInfo >&
      paymentdocuments() const;
  inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::PaymentDocumentInfo >*
      mutable_paymentdocuments();

  // optional .Diadoc.Api.Proto.Invoicing.InvoiceTable InvoiceTable = 11;
  inline bool has_invoicetable() const;
  inline void clear_invoicetable();
  static const int kInvoiceTableFieldNumber = 11;
  inline const ::Diadoc::Api::Proto::Invoicing::InvoiceTable& invoicetable() const;
  inline ::Diadoc::Api::Proto::Invoicing::InvoiceTable* mutable_invoicetable();
  inline ::Diadoc::Api::Proto::Invoicing::InvoiceTable* release_invoicetable();
  inline void set_allocated_invoicetable(::Diadoc::Api::Proto::Invoicing::InvoiceTable* invoicetable);

  // required string Currency = 12;
  inline bool has_currency() const;
  inline void clear_currency();
  static const int kCurrencyFieldNumber = 12;
  inline const ::std::string& currency() const;
  inline void set_currency(const ::std::string& value);
  inline void set_currency(const char* value);
  inline void set_currency(const char* value, size_t size);
  inline ::std::string* mutable_currency();
  inline ::std::string* release_currency();
  inline void set_allocated_currency(::std::string* currency);

  // optional string CurrencyRate = 13;
  inline bool has_currencyrate() const;
  inline void clear_currencyrate();
  static const int kCurrencyRateFieldNumber = 13;
  inline const ::std::string& currencyrate() const;
  inline void set_currencyrate(const ::std::string& value);
  inline void set_currencyrate(const char* value);
  inline void set_currencyrate(const char* value, size_t size);
  inline ::std::string* mutable_currencyrate();
  inline ::std::string* release_currencyrate();
  inline void set_allocated_currencyrate(::std::string* currencyrate);

  // optional string RevisionDate = 14;
  inline bool has_revisiondate() const;
  inline void clear_revisiondate();
  static const int kRevisionDateFieldNumber = 14;
  inline const ::std::string& revisiondate() const;
  inline void set_revisiondate(const ::std::string& value);
  inline void set_revisiondate(const char* value);
  inline void set_revisiondate(const char* value, size_t size);
  inline ::std::string* mutable_revisiondate();
  inline ::std::string* release_revisiondate();
  inline void set_allocated_revisiondate(::std::string* revisiondate);

  // optional string RevisionNumber = 15;
  inline bool has_revisionnumber() const;
  inline void clear_revisionnumber();
  static const int kRevisionNumberFieldNumber = 15;
  inline const ::std::string& revisionnumber() const;
  inline void set_revisionnumber(const ::std::string& value);
  inline void set_revisionnumber(const char* value);
  inline void set_revisionnumber(const char* value, size_t size);
  inline ::std::string* mutable_revisionnumber();
  inline ::std::string* release_revisionnumber();
  inline void set_allocated_revisionnumber(::std::string* revisionnumber);

  // optional .Diadoc.Api.Proto.Invoicing.AdditionalInfoId AdditionalInfoId = 16;
  inline bool has_additionalinfoid() const;
  inline void clear_additionalinfoid();
  static const int kAdditionalInfoIdFieldNumber = 16;
  inline const ::Diadoc::Api::Proto::Invoicing::AdditionalInfoId& additionalinfoid() const;
  inline ::Diadoc::Api::Proto::Invoicing::AdditionalInfoId* mutable_additionalinfoid();
  inline ::Diadoc::Api::Proto::Invoicing::AdditionalInfoId* release_additionalinfoid();
  inline void set_allocated_additionalinfoid(::Diadoc::Api::Proto::Invoicing::AdditionalInfoId* additionalinfoid);

  // optional .Diadoc.Api.Proto.Invoicing.TransferInfo TransferInfo = 17;
  inline bool has_transferinfo() const;
  inline void clear_transferinfo();
  static const int kTransferInfoFieldNumber = 17;
  inline const ::Diadoc::Api::Proto::Invoicing::TransferInfo& transferinfo() const;
  inline ::Diadoc::Api::Proto::Invoicing::TransferInfo* mutable_transferinfo();
  inline ::Diadoc::Api::Proto::Invoicing::TransferInfo* release_transferinfo();
  inline void set_allocated_transferinfo(::Diadoc::Api::Proto::Invoicing::TransferInfo* transferinfo);

  // required string DocumentCreator = 18;
  inline bool has_documentcreator() const;
  inline void clear_documentcreator();
  static const int kDocumentCreatorFieldNumber = 18;
  inline const ::std::string& documentcreator() const;
  inline void set_documentcreator(const ::std::string& value);
  inline void set_documentcreator(const char* value);
  inline void set_documentcreator(const char* value, size_t size);
  inline ::std::string* mutable_documentcreator();
  inline ::std::string* release_documentcreator();
  inline void set_allocated_documentcreator(::std::string* documentcreator);

  // optional string DocumentCreatorBase = 19;
  inline bool has_documentcreatorbase() const;
  inline void clear_documentcreatorbase();
  static const int kDocumentCreatorBaseFieldNumber = 19;
  inline const ::std::string& documentcreatorbase() const;
  inline void set_documentcreatorbase(const ::std::string& value);
  inline void set_documentcreatorbase(const char* value);
  inline void set_documentcreatorbase(const char* value, size_t size);
  inline ::std::string* mutable_documentcreatorbase();
  inline ::std::string* release_documentcreatorbase();
  inline void set_allocated_documentcreatorbase(::std::string* documentcreatorbase);

  // optional string GovernmentContractInfo = 20;
  inline bool has_governmentcontractinfo() const;
  inline void clear_governmentcontractinfo();
  static const int kGovernmentContractInfoFieldNumber = 20;
  inline const ::std::string& governmentcontractinfo() const;
  inline void set_governmentcontractinfo(const ::std::string& value);
  inline void set_governmentcontractinfo(const char* value);
  inline void set_governmentcontractinfo(const char* value, size_t size);
  inline ::std::string* mutable_governmentcontractinfo();
  inline ::std::string* release_governmentcontractinfo();
  inline void set_allocated_governmentcontractinfo(::std::string* governmentcontractinfo);

  // @@protoc_insertion_point(class_scope:Diadoc.Api.Proto.Invoicing.UniversalTransferDocumentSellerTitleInfo)
 private:
  inline void set_has_function();
  inline void clear_has_function();
  inline void set_has_documentname();
  inline void clear_has_documentname();
  inline void set_has_documentdate();
  inline void clear_has_documentdate();
  inline void set_has_documentnumber();
  inline void clear_has_documentnumber();
  inline void set_has_seller();
  inline void clear_has_seller();
  inline void set_has_buyer();
  inline void clear_has_buyer();
  inline void set_has_shipper();
  inline void clear_has_shipper();
  inline void set_has_consignee();
  inline void clear_has_consignee();
  inline void set_has_invoicetable();
  inline void clear_has_invoicetable();
  inline void set_has_currency();
  inline void clear_has_currency();
  inline void set_has_currencyrate();
  inline void clear_has_currencyrate();
  inline void set_has_revisiondate();
  inline void clear_has_revisiondate();
  inline void set_has_revisionnumber();
  inline void clear_has_revisionnumber();
  inline void set_has_additionalinfoid();
  inline void clear_has_additionalinfoid();
  inline void set_has_transferinfo();
  inline void clear_has_transferinfo();
  inline void set_has_documentcreator();
  inline void clear_has_documentcreator();
  inline void set_has_documentcreatorbase();
  inline void clear_has_documentcreatorbase();
  inline void set_has_governmentcontractinfo();
  inline void clear_has_governmentcontractinfo();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* documentname_;
  ::std::string* documentdate_;
  ::std::string* documentnumber_;
  ::Diadoc::Api::Proto::Invoicing::Organizations::ExtendedOrganizationInfo* seller_;
  ::Diadoc::Api::Proto::Invoicing::Organizations::ExtendedOrganizationInfo* buyer_;
  ::Diadoc::Api::Proto::Invoicing::Shipper* shipper_;
  ::Diadoc::Api::Proto::Invoicing::Organizations::ExtendedOrganizationInfo* consignee_;
  ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::Signers::ExtendedSigner > signers_;
  ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::PaymentDocumentInfo > paymentdocuments_;
  ::Diadoc::Api::Proto::Invoicing::InvoiceTable* invoicetable_;
  ::std::string* currency_;
  ::std::string* currencyrate_;
  ::std::string* revisiondate_;
  ::std::string* revisionnumber_;
  ::Diadoc::Api::Proto::Invoicing::AdditionalInfoId* additionalinfoid_;
  ::Diadoc::Api::Proto::Invoicing::TransferInfo* transferinfo_;
  ::std::string* documentcreator_;
  ::std::string* documentcreatorbase_;
  ::std::string* governmentcontractinfo_;
  int function_;
  friend void  protobuf_AddDesc_Invoicing_2fUniversalTransferDocumentInfo_2eproto();
  friend void protobuf_AssignDesc_Invoicing_2fUniversalTransferDocumentInfo_2eproto();
  friend void protobuf_ShutdownFile_Invoicing_2fUniversalTransferDocumentInfo_2eproto();

  void InitAsDefaultInstance();
  static UniversalTransferDocumentSellerTitleInfo* default_instance_;
};
// -------------------------------------------------------------------

class Shipper : public ::google::protobuf::Message {
 public:
  Shipper();
  virtual ~Shipper();

  Shipper(const Shipper& from);

  inline Shipper& operator=(const Shipper& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Shipper& default_instance();

  void Swap(Shipper* other);

  // implements Message ----------------------------------------------

  Shipper* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Shipper& from);
  void MergeFrom(const Shipper& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool SameAsSeller = 1;
  inline bool has_sameasseller() const;
  inline void clear_sameasseller();
  static const int kSameAsSellerFieldNumber = 1;
  inline bool sameasseller() const;
  inline void set_sameasseller(bool value);

  // optional .Diadoc.Api.Proto.Invoicing.Organizations.ExtendedOrganizationInfo OrgInfo = 2;
  inline bool has_orginfo() const;
  inline void clear_orginfo();
  static const int kOrgInfoFieldNumber = 2;
  inline const ::Diadoc::Api::Proto::Invoicing::Organizations::ExtendedOrganizationInfo& orginfo() const;
  inline ::Diadoc::Api::Proto::Invoicing::Organizations::ExtendedOrganizationInfo* mutable_orginfo();
  inline ::Diadoc::Api::Proto::Invoicing::Organizations::ExtendedOrganizationInfo* release_orginfo();
  inline void set_allocated_orginfo(::Diadoc::Api::Proto::Invoicing::Organizations::ExtendedOrganizationInfo* orginfo);

  // @@protoc_insertion_point(class_scope:Diadoc.Api.Proto.Invoicing.Shipper)
 private:
  inline void set_has_sameasseller();
  inline void clear_has_sameasseller();
  inline void set_has_orginfo();
  inline void clear_has_orginfo();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::Diadoc::Api::Proto::Invoicing::Organizations::ExtendedOrganizationInfo* orginfo_;
  bool sameasseller_;
  friend void  protobuf_AddDesc_Invoicing_2fUniversalTransferDocumentInfo_2eproto();
  friend void protobuf_AssignDesc_Invoicing_2fUniversalTransferDocumentInfo_2eproto();
  friend void protobuf_ShutdownFile_Invoicing_2fUniversalTransferDocumentInfo_2eproto();

  void InitAsDefaultInstance();
  static Shipper* default_instance_;
};
// -------------------------------------------------------------------

class InvoiceTable : public ::google::protobuf::Message {
 public:
  InvoiceTable();
  virtual ~InvoiceTable();

  InvoiceTable(const InvoiceTable& from);

  inline InvoiceTable& operator=(const InvoiceTable& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InvoiceTable& default_instance();

  void Swap(InvoiceTable* other);

  // implements Message ----------------------------------------------

  InvoiceTable* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InvoiceTable& from);
  void MergeFrom(const InvoiceTable& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Diadoc.Api.Proto.Invoicing.ExtendedInvoiceItem Items = 1;
  inline int items_size() const;
  inline void clear_items();
  static const int kItemsFieldNumber = 1;
  inline const ::Diadoc::Api::Proto::Invoicing::ExtendedInvoiceItem& items(int index) const;
  inline ::Diadoc::Api::Proto::Invoicing::ExtendedInvoiceItem* mutable_items(int index);
  inline ::Diadoc::Api::Proto::Invoicing::ExtendedInvoiceItem* add_items();
  inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::ExtendedInvoiceItem >&
      items() const;
  inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::ExtendedInvoiceItem >*
      mutable_items();

  // optional string TotalWithVatExcluded = 2;
  inline bool has_totalwithvatexcluded() const;
  inline void clear_totalwithvatexcluded();
  static const int kTotalWithVatExcludedFieldNumber = 2;
  inline const ::std::string& totalwithvatexcluded() const;
  inline void set_totalwithvatexcluded(const ::std::string& value);
  inline void set_totalwithvatexcluded(const char* value);
  inline void set_totalwithvatexcluded(const char* value, size_t size);
  inline ::std::string* mutable_totalwithvatexcluded();
  inline ::std::string* release_totalwithvatexcluded();
  inline void set_allocated_totalwithvatexcluded(::std::string* totalwithvatexcluded);

  // required string Vat = 3;
  inline bool has_vat() const;
  inline void clear_vat();
  static const int kVatFieldNumber = 3;
  inline const ::std::string& vat() const;
  inline void set_vat(const ::std::string& value);
  inline void set_vat(const char* value);
  inline void set_vat(const char* value, size_t size);
  inline ::std::string* mutable_vat();
  inline ::std::string* release_vat();
  inline void set_allocated_vat(::std::string* vat);

  // required string Total = 4;
  inline bool has_total() const;
  inline void clear_total();
  static const int kTotalFieldNumber = 4;
  inline const ::std::string& total() const;
  inline void set_total(const ::std::string& value);
  inline void set_total(const char* value);
  inline void set_total(const char* value, size_t size);
  inline ::std::string* mutable_total();
  inline ::std::string* release_total();
  inline void set_allocated_total(::std::string* total);

  // optional string TotalNet = 5;
  inline bool has_totalnet() const;
  inline void clear_totalnet();
  static const int kTotalNetFieldNumber = 5;
  inline const ::std::string& totalnet() const;
  inline void set_totalnet(const ::std::string& value);
  inline void set_totalnet(const char* value);
  inline void set_totalnet(const char* value, size_t size);
  inline ::std::string* mutable_totalnet();
  inline ::std::string* release_totalnet();
  inline void set_allocated_totalnet(::std::string* totalnet);

  // @@protoc_insertion_point(class_scope:Diadoc.Api.Proto.Invoicing.InvoiceTable)
 private:
  inline void set_has_totalwithvatexcluded();
  inline void clear_has_totalwithvatexcluded();
  inline void set_has_vat();
  inline void clear_has_vat();
  inline void set_has_total();
  inline void clear_has_total();
  inline void set_has_totalnet();
  inline void clear_has_totalnet();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::ExtendedInvoiceItem > items_;
  ::std::string* totalwithvatexcluded_;
  ::std::string* vat_;
  ::std::string* total_;
  ::std::string* totalnet_;
  friend void  protobuf_AddDesc_Invoicing_2fUniversalTransferDocumentInfo_2eproto();
  friend void protobuf_AssignDesc_Invoicing_2fUniversalTransferDocumentInfo_2eproto();
  friend void protobuf_ShutdownFile_Invoicing_2fUniversalTransferDocumentInfo_2eproto();

  void InitAsDefaultInstance();
  static InvoiceTable* default_instance_;
};
// -------------------------------------------------------------------

class ExtendedInvoiceItem : public ::google::protobuf::Message {
 public:
  ExtendedInvoiceItem();
  virtual ~ExtendedInvoiceItem();

  ExtendedInvoiceItem(const ExtendedInvoiceItem& from);

  inline ExtendedInvoiceItem& operator=(const ExtendedInvoiceItem& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ExtendedInvoiceItem& default_instance();

  void Swap(ExtendedInvoiceItem* other);

  // implements Message ----------------------------------------------

  ExtendedInvoiceItem* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ExtendedInvoiceItem& from);
  void MergeFrom(const ExtendedInvoiceItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string Product = 1;
  inline bool has_product() const;
  inline void clear_product();
  static const int kProductFieldNumber = 1;
  inline const ::std::string& product() const;
  inline void set_product(const ::std::string& value);
  inline void set_product(const char* value);
  inline void set_product(const char* value, size_t size);
  inline ::std::string* mutable_product();
  inline ::std::string* release_product();
  inline void set_allocated_product(::std::string* product);

  // optional string Unit = 2;
  inline bool has_unit() const;
  inline void clear_unit();
  static const int kUnitFieldNumber = 2;
  inline const ::std::string& unit() const;
  inline void set_unit(const ::std::string& value);
  inline void set_unit(const char* value);
  inline void set_unit(const char* value, size_t size);
  inline ::std::string* mutable_unit();
  inline ::std::string* release_unit();
  inline void set_allocated_unit(::std::string* unit);

  // optional string UnitName = 3;
  inline bool has_unitname() const;
  inline void clear_unitname();
  static const int kUnitNameFieldNumber = 3;
  inline const ::std::string& unitname() const;
  inline void set_unitname(const ::std::string& value);
  inline void set_unitname(const char* value);
  inline void set_unitname(const char* value, size_t size);
  inline ::std::string* mutable_unitname();
  inline ::std::string* release_unitname();
  inline void set_allocated_unitname(::std::string* unitname);

  // optional string Quantity = 4;
  inline bool has_quantity() const;
  inline void clear_quantity();
  static const int kQuantityFieldNumber = 4;
  inline const ::std::string& quantity() const;
  inline void set_quantity(const ::std::string& value);
  inline void set_quantity(const char* value);
  inline void set_quantity(const char* value, size_t size);
  inline ::std::string* mutable_quantity();
  inline ::std::string* release_quantity();
  inline void set_allocated_quantity(::std::string* quantity);

  // optional string Price = 5;
  inline bool has_price() const;
  inline void clear_price();
  static const int kPriceFieldNumber = 5;
  inline const ::std::string& price() const;
  inline void set_price(const ::std::string& value);
  inline void set_price(const char* value);
  inline void set_price(const char* value, size_t size);
  inline ::std::string* mutable_price();
  inline ::std::string* release_price();
  inline void set_allocated_price(::std::string* price);

  // optional string Excise = 6;
  inline bool has_excise() const;
  inline void clear_excise();
  static const int kExciseFieldNumber = 6;
  inline const ::std::string& excise() const;
  inline void set_excise(const ::std::string& value);
  inline void set_excise(const char* value);
  inline void set_excise(const char* value, size_t size);
  inline ::std::string* mutable_excise();
  inline ::std::string* release_excise();
  inline void set_allocated_excise(::std::string* excise);

  // required .Diadoc.Api.Proto.Invoicing.TaxRate TaxRate = 7;
  inline bool has_taxrate() const;
  inline void clear_taxrate();
  static const int kTaxRateFieldNumber = 7;
  inline ::Diadoc::Api::Proto::Invoicing::TaxRate taxrate() const;
  inline void set_taxrate(::Diadoc::Api::Proto::Invoicing::TaxRate value);

  // optional string SubtotalWithVatExcluded = 8;
  inline bool has_subtotalwithvatexcluded() const;
  inline void clear_subtotalwithvatexcluded();
  static const int kSubtotalWithVatExcludedFieldNumber = 8;
  inline const ::std::string& subtotalwithvatexcluded() const;
  inline void set_subtotalwithvatexcluded(const ::std::string& value);
  inline void set_subtotalwithvatexcluded(const char* value);
  inline void set_subtotalwithvatexcluded(const char* value, size_t size);
  inline ::std::string* mutable_subtotalwithvatexcluded();
  inline ::std::string* release_subtotalwithvatexcluded();
  inline void set_allocated_subtotalwithvatexcluded(::std::string* subtotalwithvatexcluded);

  // optional string Vat = 9;
  inline bool has_vat() const;
  inline void clear_vat();
  static const int kVatFieldNumber = 9;
  inline const ::std::string& vat() const;
  inline void set_vat(const ::std::string& value);
  inline void set_vat(const char* value);
  inline void set_vat(const char* value, size_t size);
  inline ::std::string* mutable_vat();
  inline ::std::string* release_vat();
  inline void set_allocated_vat(::std::string* vat);

  // required string Subtotal = 10;
  inline bool has_subtotal() const;
  inline void clear_subtotal();
  static const int kSubtotalFieldNumber = 10;
  inline const ::std::string& subtotal() const;
  inline void set_subtotal(const ::std::string& value);
  inline void set_subtotal(const char* value);
  inline void set_subtotal(const char* value, size_t size);
  inline ::std::string* mutable_subtotal();
  inline ::std::string* release_subtotal();
  inline void set_allocated_subtotal(::std::string* subtotal);

  // repeated .Diadoc.Api.Proto.Invoicing.CustomsDeclaration CustomsDeclarations = 11;
  inline int customsdeclarations_size() const;
  inline void clear_customsdeclarations();
  static const int kCustomsDeclarationsFieldNumber = 11;
  inline const ::Diadoc::Api::Proto::Invoicing::CustomsDeclaration& customsdeclarations(int index) const;
  inline ::Diadoc::Api::Proto::Invoicing::CustomsDeclaration* mutable_customsdeclarations(int index);
  inline ::Diadoc::Api::Proto::Invoicing::CustomsDeclaration* add_customsdeclarations();
  inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::CustomsDeclaration >&
      customsdeclarations() const;
  inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::CustomsDeclaration >*
      mutable_customsdeclarations();

  // optional .Diadoc.Api.Proto.Invoicing.ItemMark ItemMark = 12;
  inline bool has_itemmark() const;
  inline void clear_itemmark();
  static const int kItemMarkFieldNumber = 12;
  inline ::Diadoc::Api::Proto::Invoicing::ItemMark itemmark() const;
  inline void set_itemmark(::Diadoc::Api::Proto::Invoicing::ItemMark value);

  // optional string AdditionalProperty = 13;
  inline bool has_additionalproperty() const;
  inline void clear_additionalproperty();
  static const int kAdditionalPropertyFieldNumber = 13;
  inline const ::std::string& additionalproperty() const;
  inline void set_additionalproperty(const ::std::string& value);
  inline void set_additionalproperty(const char* value);
  inline void set_additionalproperty(const char* value, size_t size);
  inline ::std::string* mutable_additionalproperty();
  inline ::std::string* release_additionalproperty();
  inline void set_allocated_additionalproperty(::std::string* additionalproperty);

  // optional string ItemVendorCode = 14;
  inline bool has_itemvendorcode() const;
  inline void clear_itemvendorcode();
  static const int kItemVendorCodeFieldNumber = 14;
  inline const ::std::string& itemvendorcode() const;
  inline void set_itemvendorcode(const ::std::string& value);
  inline void set_itemvendorcode(const char* value);
  inline void set_itemvendorcode(const char* value, size_t size);
  inline ::std::string* mutable_itemvendorcode();
  inline ::std::string* release_itemvendorcode();
  inline void set_allocated_itemvendorcode(::std::string* itemvendorcode);

  // optional string ItemToRelease = 15;
  inline bool has_itemtorelease() const;
  inline void clear_itemtorelease();
  static const int kItemToReleaseFieldNumber = 15;
  inline const ::std::string& itemtorelease() const;
  inline void set_itemtorelease(const ::std::string& value);
  inline void set_itemtorelease(const char* value);
  inline void set_itemtorelease(const char* value, size_t size);
  inline ::std::string* mutable_itemtorelease();
  inline ::std::string* release_itemtorelease();
  inline void set_allocated_itemtorelease(::std::string* itemtorelease);

  // optional string ItemAccountDebit = 16;
  inline bool has_itemaccountdebit() const;
  inline void clear_itemaccountdebit();
  static const int kItemAccountDebitFieldNumber = 16;
  inline const ::std::string& itemaccountdebit() const;
  inline void set_itemaccountdebit(const ::std::string& value);
  inline void set_itemaccountdebit(const char* value);
  inline void set_itemaccountdebit(const char* value, size_t size);
  inline ::std::string* mutable_itemaccountdebit();
  inline ::std::string* release_itemaccountdebit();
  inline void set_allocated_itemaccountdebit(::std::string* itemaccountdebit);

  // optional string ItemAccountCredit = 17;
  inline bool has_itemaccountcredit() const;
  inline void clear_itemaccountcredit();
  static const int kItemAccountCreditFieldNumber = 17;
  inline const ::std::string& itemaccountcredit() const;
  inline void set_itemaccountcredit(const ::std::string& value);
  inline void set_itemaccountcredit(const char* value);
  inline void set_itemaccountcredit(const char* value, size_t size);
  inline ::std::string* mutable_itemaccountcredit();
  inline ::std::string* release_itemaccountcredit();
  inline void set_allocated_itemaccountcredit(::std::string* itemaccountcredit);

  // repeated .Diadoc.Api.Proto.Invoicing.AdditionalInfo AdditionalInfo = 18;
  inline int additionalinfo_size() const;
  inline void clear_additionalinfo();
  static const int kAdditionalInfoFieldNumber = 18;
  inline const ::Diadoc::Api::Proto::Invoicing::AdditionalInfo& additionalinfo(int index) const;
  inline ::Diadoc::Api::Proto::Invoicing::AdditionalInfo* mutable_additionalinfo(int index);
  inline ::Diadoc::Api::Proto::Invoicing::AdditionalInfo* add_additionalinfo();
  inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::AdditionalInfo >&
      additionalinfo() const;
  inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::AdditionalInfo >*
      mutable_additionalinfo();

  // @@protoc_insertion_point(class_scope:Diadoc.Api.Proto.Invoicing.ExtendedInvoiceItem)
 private:
  inline void set_has_product();
  inline void clear_has_product();
  inline void set_has_unit();
  inline void clear_has_unit();
  inline void set_has_unitname();
  inline void clear_has_unitname();
  inline void set_has_quantity();
  inline void clear_has_quantity();
  inline void set_has_price();
  inline void clear_has_price();
  inline void set_has_excise();
  inline void clear_has_excise();
  inline void set_has_taxrate();
  inline void clear_has_taxrate();
  inline void set_has_subtotalwithvatexcluded();
  inline void clear_has_subtotalwithvatexcluded();
  inline void set_has_vat();
  inline void clear_has_vat();
  inline void set_has_subtotal();
  inline void clear_has_subtotal();
  inline void set_has_itemmark();
  inline void clear_has_itemmark();
  inline void set_has_additionalproperty();
  inline void clear_has_additionalproperty();
  inline void set_has_itemvendorcode();
  inline void clear_has_itemvendorcode();
  inline void set_has_itemtorelease();
  inline void clear_has_itemtorelease();
  inline void set_has_itemaccountdebit();
  inline void clear_has_itemaccountdebit();
  inline void set_has_itemaccountcredit();
  inline void clear_has_itemaccountcredit();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* product_;
  ::std::string* unit_;
  ::std::string* unitname_;
  ::std::string* quantity_;
  ::std::string* price_;
  ::std::string* excise_;
  ::std::string* subtotalwithvatexcluded_;
  ::std::string* vat_;
  int taxrate_;
  int itemmark_;
  ::std::string* subtotal_;
  ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::CustomsDeclaration > customsdeclarations_;
  ::std::string* additionalproperty_;
  ::std::string* itemvendorcode_;
  ::std::string* itemtorelease_;
  ::std::string* itemaccountdebit_;
  ::std::string* itemaccountcredit_;
  ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::AdditionalInfo > additionalinfo_;
  friend void  protobuf_AddDesc_Invoicing_2fUniversalTransferDocumentInfo_2eproto();
  friend void protobuf_AssignDesc_Invoicing_2fUniversalTransferDocumentInfo_2eproto();
  friend void protobuf_ShutdownFile_Invoicing_2fUniversalTransferDocumentInfo_2eproto();

  void InitAsDefaultInstance();
  static ExtendedInvoiceItem* default_instance_;
};
// -------------------------------------------------------------------

class TransferInfo : public ::google::protobuf::Message {
 public:
  TransferInfo();
  virtual ~TransferInfo();

  TransferInfo(const TransferInfo& from);

  inline TransferInfo& operator=(const TransferInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TransferInfo& default_instance();

  void Swap(TransferInfo* other);

  // implements Message ----------------------------------------------

  TransferInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TransferInfo& from);
  void MergeFrom(const TransferInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string OperationInfo = 1;
  inline bool has_operationinfo() const;
  inline void clear_operationinfo();
  static const int kOperationInfoFieldNumber = 1;
  inline const ::std::string& operationinfo() const;
  inline void set_operationinfo(const ::std::string& value);
  inline void set_operationinfo(const char* value);
  inline void set_operationinfo(const char* value, size_t size);
  inline ::std::string* mutable_operationinfo();
  inline ::std::string* release_operationinfo();
  inline void set_allocated_operationinfo(::std::string* operationinfo);

  // optional string OperationType = 2;
  inline bool has_operationtype() const;
  inline void clear_operationtype();
  static const int kOperationTypeFieldNumber = 2;
  inline const ::std::string& operationtype() const;
  inline void set_operationtype(const ::std::string& value);
  inline void set_operationtype(const char* value);
  inline void set_operationtype(const char* value, size_t size);
  inline ::std::string* mutable_operationtype();
  inline ::std::string* release_operationtype();
  inline void set_allocated_operationtype(::std::string* operationtype);

  // optional string TransferDate = 3;
  inline bool has_transferdate() const;
  inline void clear_transferdate();
  static const int kTransferDateFieldNumber = 3;
  inline const ::std::string& transferdate() const;
  inline void set_transferdate(const ::std::string& value);
  inline void set_transferdate(const char* value);
  inline void set_transferdate(const char* value, size_t size);
  inline ::std::string* mutable_transferdate();
  inline ::std::string* release_transferdate();
  inline void set_allocated_transferdate(::std::string* transferdate);

  // repeated .Diadoc.Api.Proto.Invoicing.TransferBase TransferBase = 4;
  inline int transferbase_size() const;
  inline void clear_transferbase();
  static const int kTransferBaseFieldNumber = 4;
  inline const ::Diadoc::Api::Proto::Invoicing::TransferBase& transferbase(int index) const;
  inline ::Diadoc::Api::Proto::Invoicing::TransferBase* mutable_transferbase(int index);
  inline ::Diadoc::Api::Proto::Invoicing::TransferBase* add_transferbase();
  inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::TransferBase >&
      transferbase() const;
  inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::TransferBase >*
      mutable_transferbase();

  // optional string TransferTextInfo = 5;
  inline bool has_transfertextinfo() const;
  inline void clear_transfertextinfo();
  static const int kTransferTextInfoFieldNumber = 5;
  inline const ::std::string& transfertextinfo() const;
  inline void set_transfertextinfo(const ::std::string& value);
  inline void set_transfertextinfo(const char* value);
  inline void set_transfertextinfo(const char* value, size_t size);
  inline ::std::string* mutable_transfertextinfo();
  inline ::std::string* release_transfertextinfo();
  inline void set_allocated_transfertextinfo(::std::string* transfertextinfo);

  // repeated .Diadoc.Api.Proto.Invoicing.Waybill Waybill = 6;
  inline int waybill_size() const;
  inline void clear_waybill();
  static const int kWaybillFieldNumber = 6;
  inline const ::Diadoc::Api::Proto::Invoicing::Waybill& waybill(int index) const;
  inline ::Diadoc::Api::Proto::Invoicing::Waybill* mutable_waybill(int index);
  inline ::Diadoc::Api::Proto::Invoicing::Waybill* add_waybill();
  inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::Waybill >&
      waybill() const;
  inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::Waybill >*
      mutable_waybill();

  // optional .Diadoc.Api.Proto.Invoicing.Organizations.ExtendedOrganizationInfo Carrier = 7;
  inline bool has_carrier() const;
  inline void clear_carrier();
  static const int kCarrierFieldNumber = 7;
  inline const ::Diadoc::Api::Proto::Invoicing::Organizations::ExtendedOrganizationInfo& carrier() const;
  inline ::Diadoc::Api::Proto::Invoicing::Organizations::ExtendedOrganizationInfo* mutable_carrier();
  inline ::Diadoc::Api::Proto::Invoicing::Organizations::ExtendedOrganizationInfo* release_carrier();
  inline void set_allocated_carrier(::Diadoc::Api::Proto::Invoicing::Organizations::ExtendedOrganizationInfo* carrier);

  // optional .Diadoc.Api.Proto.Invoicing.Employee Employee = 8;
  inline bool has_employee() const;
  inline void clear_employee();
  static const int kEmployeeFieldNumber = 8;
  inline const ::Diadoc::Api::Proto::Invoicing::Employee& employee() const;
  inline ::Diadoc::Api::Proto::Invoicing::Employee* mutable_employee();
  inline ::Diadoc::Api::Proto::Invoicing::Employee* release_employee();
  inline void set_allocated_employee(::Diadoc::Api::Proto::Invoicing::Employee* employee);

  // optional .Diadoc.Api.Proto.Invoicing.OtherIssuer OtherIssuer = 9;
  inline bool has_otherissuer() const;
  inline void clear_otherissuer();
  static const int kOtherIssuerFieldNumber = 9;
  inline const ::Diadoc::Api::Proto::Invoicing::OtherIssuer& otherissuer() const;
  inline ::Diadoc::Api::Proto::Invoicing::OtherIssuer* mutable_otherissuer();
  inline ::Diadoc::Api::Proto::Invoicing::OtherIssuer* release_otherissuer();
  inline void set_allocated_otherissuer(::Diadoc::Api::Proto::Invoicing::OtherIssuer* otherissuer);

  // optional string CreatedThingTransferDate = 10;
  inline bool has_createdthingtransferdate() const;
  inline void clear_createdthingtransferdate();
  static const int kCreatedThingTransferDateFieldNumber = 10;
  inline const ::std::string& createdthingtransferdate() const;
  inline void set_createdthingtransferdate(const ::std::string& value);
  inline void set_createdthingtransferdate(const char* value);
  inline void set_createdthingtransferdate(const char* value, size_t size);
  inline ::std::string* mutable_createdthingtransferdate();
  inline ::std::string* release_createdthingtransferdate();
  inline void set_allocated_createdthingtransferdate(::std::string* createdthingtransferdate);

  // optional string CreatedThingInfo = 11;
  inline bool has_createdthinginfo() const;
  inline void clear_createdthinginfo();
  static const int kCreatedThingInfoFieldNumber = 11;
  inline const ::std::string& createdthinginfo() const;
  inline void set_createdthinginfo(const ::std::string& value);
  inline void set_createdthinginfo(const char* value);
  inline void set_createdthinginfo(const char* value, size_t size);
  inline ::std::string* mutable_createdthinginfo();
  inline ::std::string* release_createdthinginfo();
  inline void set_allocated_createdthinginfo(::std::string* createdthinginfo);

  // optional .Diadoc.Api.Proto.Invoicing.AdditionalInfoId AdditionalInfoId = 12;
  inline bool has_additionalinfoid() const;
  inline void clear_additionalinfoid();
  static const int kAdditionalInfoIdFieldNumber = 12;
  inline const ::Diadoc::Api::Proto::Invoicing::AdditionalInfoId& additionalinfoid() const;
  inline ::Diadoc::Api::Proto::Invoicing::AdditionalInfoId* mutable_additionalinfoid();
  inline ::Diadoc::Api::Proto::Invoicing::AdditionalInfoId* release_additionalinfoid();
  inline void set_allocated_additionalinfoid(::Diadoc::Api::Proto::Invoicing::AdditionalInfoId* additionalinfoid);

  // @@protoc_insertion_point(class_scope:Diadoc.Api.Proto.Invoicing.TransferInfo)
 private:
  inline void set_has_operationinfo();
  inline void clear_has_operationinfo();
  inline void set_has_operationtype();
  inline void clear_has_operationtype();
  inline void set_has_transferdate();
  inline void clear_has_transferdate();
  inline void set_has_transfertextinfo();
  inline void clear_has_transfertextinfo();
  inline void set_has_carrier();
  inline void clear_has_carrier();
  inline void set_has_employee();
  inline void clear_has_employee();
  inline void set_has_otherissuer();
  inline void clear_has_otherissuer();
  inline void set_has_createdthingtransferdate();
  inline void clear_has_createdthingtransferdate();
  inline void set_has_createdthinginfo();
  inline void clear_has_createdthinginfo();
  inline void set_has_additionalinfoid();
  inline void clear_has_additionalinfoid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* operationinfo_;
  ::std::string* operationtype_;
  ::std::string* transferdate_;
  ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::TransferBase > transferbase_;
  ::std::string* transfertextinfo_;
  ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::Waybill > waybill_;
  ::Diadoc::Api::Proto::Invoicing::Organizations::ExtendedOrganizationInfo* carrier_;
  ::Diadoc::Api::Proto::Invoicing::Employee* employee_;
  ::Diadoc::Api::Proto::Invoicing::OtherIssuer* otherissuer_;
  ::std::string* createdthingtransferdate_;
  ::std::string* createdthinginfo_;
  ::Diadoc::Api::Proto::Invoicing::AdditionalInfoId* additionalinfoid_;
  friend void  protobuf_AddDesc_Invoicing_2fUniversalTransferDocumentInfo_2eproto();
  friend void protobuf_AssignDesc_Invoicing_2fUniversalTransferDocumentInfo_2eproto();
  friend void protobuf_ShutdownFile_Invoicing_2fUniversalTransferDocumentInfo_2eproto();

  void InitAsDefaultInstance();
  static TransferInfo* default_instance_;
};
// -------------------------------------------------------------------

class TransferBase : public ::google::protobuf::Message {
 public:
  TransferBase();
  virtual ~TransferBase();

  TransferBase(const TransferBase& from);

  inline TransferBase& operator=(const TransferBase& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TransferBase& default_instance();

  void Swap(TransferBase* other);

  // implements Message ----------------------------------------------

  TransferBase* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TransferBase& from);
  void MergeFrom(const TransferBase& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string BaseDocumentName = 1;
  inline bool has_basedocumentname() const;
  inline void clear_basedocumentname();
  static const int kBaseDocumentNameFieldNumber = 1;
  inline const ::std::string& basedocumentname() const;
  inline void set_basedocumentname(const ::std::string& value);
  inline void set_basedocumentname(const char* value);
  inline void set_basedocumentname(const char* value, size_t size);
  inline ::std::string* mutable_basedocumentname();
  inline ::std::string* release_basedocumentname();
  inline void set_allocated_basedocumentname(::std::string* basedocumentname);

  // optional string BaseDocumentNumber = 2;
  inline bool has_basedocumentnumber() const;
  inline void clear_basedocumentnumber();
  static const int kBaseDocumentNumberFieldNumber = 2;
  inline const ::std::string& basedocumentnumber() const;
  inline void set_basedocumentnumber(const ::std::string& value);
  inline void set_basedocumentnumber(const char* value);
  inline void set_basedocumentnumber(const char* value, size_t size);
  inline ::std::string* mutable_basedocumentnumber();
  inline ::std::string* release_basedocumentnumber();
  inline void set_allocated_basedocumentnumber(::std::string* basedocumentnumber);

  // optional string BaseDocumentDate = 3;
  inline bool has_basedocumentdate() const;
  inline void clear_basedocumentdate();
  static const int kBaseDocumentDateFieldNumber = 3;
  inline const ::std::string& basedocumentdate() const;
  inline void set_basedocumentdate(const ::std::string& value);
  inline void set_basedocumentdate(const char* value);
  inline void set_basedocumentdate(const char* value, size_t size);
  inline ::std::string* mutable_basedocumentdate();
  inline ::std::string* release_basedocumentdate();
  inline void set_allocated_basedocumentdate(::std::string* basedocumentdate);

  // optional string BaseDocumentInfo = 4;
  inline bool has_basedocumentinfo() const;
  inline void clear_basedocumentinfo();
  static const int kBaseDocumentInfoFieldNumber = 4;
  inline const ::std::string& basedocumentinfo() const;
  inline void set_basedocumentinfo(const ::std::string& value);
  inline void set_basedocumentinfo(const char* value);
  inline void set_basedocumentinfo(const char* value, size_t size);
  inline ::std::string* mutable_basedocumentinfo();
  inline ::std::string* release_basedocumentinfo();
  inline void set_allocated_basedocumentinfo(::std::string* basedocumentinfo);

  // @@protoc_insertion_point(class_scope:Diadoc.Api.Proto.Invoicing.TransferBase)
 private:
  inline void set_has_basedocumentname();
  inline void clear_has_basedocumentname();
  inline void set_has_basedocumentnumber();
  inline void clear_has_basedocumentnumber();
  inline void set_has_basedocumentdate();
  inline void clear_has_basedocumentdate();
  inline void set_has_basedocumentinfo();
  inline void clear_has_basedocumentinfo();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* basedocumentname_;
  ::std::string* basedocumentnumber_;
  ::std::string* basedocumentdate_;
  ::std::string* basedocumentinfo_;
  friend void  protobuf_AddDesc_Invoicing_2fUniversalTransferDocumentInfo_2eproto();
  friend void protobuf_AssignDesc_Invoicing_2fUniversalTransferDocumentInfo_2eproto();
  friend void protobuf_ShutdownFile_Invoicing_2fUniversalTransferDocumentInfo_2eproto();

  void InitAsDefaultInstance();
  static TransferBase* default_instance_;
};
// -------------------------------------------------------------------

class Waybill : public ::google::protobuf::Message {
 public:
  Waybill();
  virtual ~Waybill();

  Waybill(const Waybill& from);

  inline Waybill& operator=(const Waybill& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Waybill& default_instance();

  void Swap(Waybill* other);

  // implements Message ----------------------------------------------

  Waybill* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Waybill& from);
  void MergeFrom(const Waybill& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string TransferDocumentNumber = 1;
  inline bool has_transferdocumentnumber() const;
  inline void clear_transferdocumentnumber();
  static const int kTransferDocumentNumberFieldNumber = 1;
  inline const ::std::string& transferdocumentnumber() const;
  inline void set_transferdocumentnumber(const ::std::string& value);
  inline void set_transferdocumentnumber(const char* value);
  inline void set_transferdocumentnumber(const char* value, size_t size);
  inline ::std::string* mutable_transferdocumentnumber();
  inline ::std::string* release_transferdocumentnumber();
  inline void set_allocated_transferdocumentnumber(::std::string* transferdocumentnumber);

  // required string TransferDocumentDate = 2;
  inline bool has_transferdocumentdate() const;
  inline void clear_transferdocumentdate();
  static const int kTransferDocumentDateFieldNumber = 2;
  inline const ::std::string& transferdocumentdate() const;
  inline void set_transferdocumentdate(const ::std::string& value);
  inline void set_transferdocumentdate(const char* value);
  inline void set_transferdocumentdate(const char* value, size_t size);
  inline ::std::string* mutable_transferdocumentdate();
  inline ::std::string* release_transferdocumentdate();
  inline void set_allocated_transferdocumentdate(::std::string* transferdocumentdate);

  // @@protoc_insertion_point(class_scope:Diadoc.Api.Proto.Invoicing.Waybill)
 private:
  inline void set_has_transferdocumentnumber();
  inline void clear_has_transferdocumentnumber();
  inline void set_has_transferdocumentdate();
  inline void clear_has_transferdocumentdate();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* transferdocumentnumber_;
  ::std::string* transferdocumentdate_;
  friend void  protobuf_AddDesc_Invoicing_2fUniversalTransferDocumentInfo_2eproto();
  friend void protobuf_AssignDesc_Invoicing_2fUniversalTransferDocumentInfo_2eproto();
  friend void protobuf_ShutdownFile_Invoicing_2fUniversalTransferDocumentInfo_2eproto();

  void InitAsDefaultInstance();
  static Waybill* default_instance_;
};
// -------------------------------------------------------------------

class Employee : public ::google::protobuf::Message {
 public:
  Employee();
  virtual ~Employee();

  Employee(const Employee& from);

  inline Employee& operator=(const Employee& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Employee& default_instance();

  void Swap(Employee* other);

  // implements Message ----------------------------------------------

  Employee* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Employee& from);
  void MergeFrom(const Employee& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string EmployeePosition = 1;
  inline bool has_employeeposition() const;
  inline void clear_employeeposition();
  static const int kEmployeePositionFieldNumber = 1;
  inline const ::std::string& employeeposition() const;
  inline void set_employeeposition(const ::std::string& value);
  inline void set_employeeposition(const char* value);
  inline void set_employeeposition(const char* value, size_t size);
  inline ::std::string* mutable_employeeposition();
  inline ::std::string* release_employeeposition();
  inline void set_allocated_employeeposition(::std::string* employeeposition);

  // optional string EmployeeInfo = 2;
  inline bool has_employeeinfo() const;
  inline void clear_employeeinfo();
  static const int kEmployeeInfoFieldNumber = 2;
  inline const ::std::string& employeeinfo() const;
  inline void set_employeeinfo(const ::std::string& value);
  inline void set_employeeinfo(const char* value);
  inline void set_employeeinfo(const char* value, size_t size);
  inline ::std::string* mutable_employeeinfo();
  inline ::std::string* release_employeeinfo();
  inline void set_allocated_employeeinfo(::std::string* employeeinfo);

  // optional string EmployeeBase = 3;
  inline bool has_employeebase() const;
  inline void clear_employeebase();
  static const int kEmployeeBaseFieldNumber = 3;
  inline const ::std::string& employeebase() const;
  inline void set_employeebase(const ::std::string& value);
  inline void set_employeebase(const char* value);
  inline void set_employeebase(const char* value, size_t size);
  inline ::std::string* mutable_employeebase();
  inline ::std::string* release_employeebase();
  inline void set_allocated_employeebase(::std::string* employeebase);

  // required string TransferSurname = 4;
  inline bool has_transfersurname() const;
  inline void clear_transfersurname();
  static const int kTransferSurnameFieldNumber = 4;
  inline const ::std::string& transfersurname() const;
  inline void set_transfersurname(const ::std::string& value);
  inline void set_transfersurname(const char* value);
  inline void set_transfersurname(const char* value, size_t size);
  inline ::std::string* mutable_transfersurname();
  inline ::std::string* release_transfersurname();
  inline void set_allocated_transfersurname(::std::string* transfersurname);

  // required string TransferFirstName = 5;
  inline bool has_transferfirstname() const;
  inline void clear_transferfirstname();
  static const int kTransferFirstNameFieldNumber = 5;
  inline const ::std::string& transferfirstname() const;
  inline void set_transferfirstname(const ::std::string& value);
  inline void set_transferfirstname(const char* value);
  inline void set_transferfirstname(const char* value, size_t size);
  inline ::std::string* mutable_transferfirstname();
  inline ::std::string* release_transferfirstname();
  inline void set_allocated_transferfirstname(::std::string* transferfirstname);

  // optional string TransferPatronymic = 6;
  inline bool has_transferpatronymic() const;
  inline void clear_transferpatronymic();
  static const int kTransferPatronymicFieldNumber = 6;
  inline const ::std::string& transferpatronymic() const;
  inline void set_transferpatronymic(const ::std::string& value);
  inline void set_transferpatronymic(const char* value);
  inline void set_transferpatronymic(const char* value, size_t size);
  inline ::std::string* mutable_transferpatronymic();
  inline ::std::string* release_transferpatronymic();
  inline void set_allocated_transferpatronymic(::std::string* transferpatronymic);

  // @@protoc_insertion_point(class_scope:Diadoc.Api.Proto.Invoicing.Employee)
 private:
  inline void set_has_employeeposition();
  inline void clear_has_employeeposition();
  inline void set_has_employeeinfo();
  inline void clear_has_employeeinfo();
  inline void set_has_employeebase();
  inline void clear_has_employeebase();
  inline void set_has_transfersurname();
  inline void clear_has_transfersurname();
  inline void set_has_transferfirstname();
  inline void clear_has_transferfirstname();
  inline void set_has_transferpatronymic();
  inline void clear_has_transferpatronymic();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* employeeposition_;
  ::std::string* employeeinfo_;
  ::std::string* employeebase_;
  ::std::string* transfersurname_;
  ::std::string* transferfirstname_;
  ::std::string* transferpatronymic_;
  friend void  protobuf_AddDesc_Invoicing_2fUniversalTransferDocumentInfo_2eproto();
  friend void protobuf_AssignDesc_Invoicing_2fUniversalTransferDocumentInfo_2eproto();
  friend void protobuf_ShutdownFile_Invoicing_2fUniversalTransferDocumentInfo_2eproto();

  void InitAsDefaultInstance();
  static Employee* default_instance_;
};
// -------------------------------------------------------------------

class OtherIssuer : public ::google::protobuf::Message {
 public:
  OtherIssuer();
  virtual ~OtherIssuer();

  OtherIssuer(const OtherIssuer& from);

  inline OtherIssuer& operator=(const OtherIssuer& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OtherIssuer& default_instance();

  void Swap(OtherIssuer* other);

  // implements Message ----------------------------------------------

  OtherIssuer* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OtherIssuer& from);
  void MergeFrom(const OtherIssuer& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string TransferEmployeePosition = 1;
  inline bool has_transferemployeeposition() const;
  inline void clear_transferemployeeposition();
  static const int kTransferEmployeePositionFieldNumber = 1;
  inline const ::std::string& transferemployeeposition() const;
  inline void set_transferemployeeposition(const ::std::string& value);
  inline void set_transferemployeeposition(const char* value);
  inline void set_transferemployeeposition(const char* value, size_t size);
  inline ::std::string* mutable_transferemployeeposition();
  inline ::std::string* release_transferemployeeposition();
  inline void set_allocated_transferemployeeposition(::std::string* transferemployeeposition);

  // optional string TransferEmployeeInfo = 2;
  inline bool has_transferemployeeinfo() const;
  inline void clear_transferemployeeinfo();
  static const int kTransferEmployeeInfoFieldNumber = 2;
  inline const ::std::string& transferemployeeinfo() const;
  inline void set_transferemployeeinfo(const ::std::string& value);
  inline void set_transferemployeeinfo(const char* value);
  inline void set_transferemployeeinfo(const char* value, size_t size);
  inline ::std::string* mutable_transferemployeeinfo();
  inline ::std::string* release_transferemployeeinfo();
  inline void set_allocated_transferemployeeinfo(::std::string* transferemployeeinfo);

  // optional string TransferOrganizationName = 3;
  inline bool has_transferorganizationname() const;
  inline void clear_transferorganizationname();
  static const int kTransferOrganizationNameFieldNumber = 3;
  inline const ::std::string& transferorganizationname() const;
  inline void set_transferorganizationname(const ::std::string& value);
  inline void set_transferorganizationname(const char* value);
  inline void set_transferorganizationname(const char* value, size_t size);
  inline ::std::string* mutable_transferorganizationname();
  inline ::std::string* release_transferorganizationname();
  inline void set_allocated_transferorganizationname(::std::string* transferorganizationname);

  // optional string TransferOrganizationBase = 4;
  inline bool has_transferorganizationbase() const;
  inline void clear_transferorganizationbase();
  static const int kTransferOrganizationBaseFieldNumber = 4;
  inline const ::std::string& transferorganizationbase() const;
  inline void set_transferorganizationbase(const ::std::string& value);
  inline void set_transferorganizationbase(const char* value);
  inline void set_transferorganizationbase(const char* value, size_t size);
  inline ::std::string* mutable_transferorganizationbase();
  inline ::std::string* release_transferorganizationbase();
  inline void set_allocated_transferorganizationbase(::std::string* transferorganizationbase);

  // optional string TransferEmployeeBase = 5;
  inline bool has_transferemployeebase() const;
  inline void clear_transferemployeebase();
  static const int kTransferEmployeeBaseFieldNumber = 5;
  inline const ::std::string& transferemployeebase() const;
  inline void set_transferemployeebase(const ::std::string& value);
  inline void set_transferemployeebase(const char* value);
  inline void set_transferemployeebase(const char* value, size_t size);
  inline ::std::string* mutable_transferemployeebase();
  inline ::std::string* release_transferemployeebase();
  inline void set_allocated_transferemployeebase(::std::string* transferemployeebase);

  // required string TransferSurname = 6;
  inline bool has_transfersurname() const;
  inline void clear_transfersurname();
  static const int kTransferSurnameFieldNumber = 6;
  inline const ::std::string& transfersurname() const;
  inline void set_transfersurname(const ::std::string& value);
  inline void set_transfersurname(const char* value);
  inline void set_transfersurname(const char* value, size_t size);
  inline ::std::string* mutable_transfersurname();
  inline ::std::string* release_transfersurname();
  inline void set_allocated_transfersurname(::std::string* transfersurname);

  // required string TransferFirstName = 7;
  inline bool has_transferfirstname() const;
  inline void clear_transferfirstname();
  static const int kTransferFirstNameFieldNumber = 7;
  inline const ::std::string& transferfirstname() const;
  inline void set_transferfirstname(const ::std::string& value);
  inline void set_transferfirstname(const char* value);
  inline void set_transferfirstname(const char* value, size_t size);
  inline ::std::string* mutable_transferfirstname();
  inline ::std::string* release_transferfirstname();
  inline void set_allocated_transferfirstname(::std::string* transferfirstname);

  // optional string TransferPatronymic = 8;
  inline bool has_transferpatronymic() const;
  inline void clear_transferpatronymic();
  static const int kTransferPatronymicFieldNumber = 8;
  inline const ::std::string& transferpatronymic() const;
  inline void set_transferpatronymic(const ::std::string& value);
  inline void set_transferpatronymic(const char* value);
  inline void set_transferpatronymic(const char* value, size_t size);
  inline ::std::string* mutable_transferpatronymic();
  inline ::std::string* release_transferpatronymic();
  inline void set_allocated_transferpatronymic(::std::string* transferpatronymic);

  // @@protoc_insertion_point(class_scope:Diadoc.Api.Proto.Invoicing.OtherIssuer)
 private:
  inline void set_has_transferemployeeposition();
  inline void clear_has_transferemployeeposition();
  inline void set_has_transferemployeeinfo();
  inline void clear_has_transferemployeeinfo();
  inline void set_has_transferorganizationname();
  inline void clear_has_transferorganizationname();
  inline void set_has_transferorganizationbase();
  inline void clear_has_transferorganizationbase();
  inline void set_has_transferemployeebase();
  inline void clear_has_transferemployeebase();
  inline void set_has_transfersurname();
  inline void clear_has_transfersurname();
  inline void set_has_transferfirstname();
  inline void clear_has_transferfirstname();
  inline void set_has_transferpatronymic();
  inline void clear_has_transferpatronymic();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* transferemployeeposition_;
  ::std::string* transferemployeeinfo_;
  ::std::string* transferorganizationname_;
  ::std::string* transferorganizationbase_;
  ::std::string* transferemployeebase_;
  ::std::string* transfersurname_;
  ::std::string* transferfirstname_;
  ::std::string* transferpatronymic_;
  friend void  protobuf_AddDesc_Invoicing_2fUniversalTransferDocumentInfo_2eproto();
  friend void protobuf_AssignDesc_Invoicing_2fUniversalTransferDocumentInfo_2eproto();
  friend void protobuf_ShutdownFile_Invoicing_2fUniversalTransferDocumentInfo_2eproto();

  void InitAsDefaultInstance();
  static OtherIssuer* default_instance_;
};
// -------------------------------------------------------------------

class AdditionalInfoId : public ::google::protobuf::Message {
 public:
  AdditionalInfoId();
  virtual ~AdditionalInfoId();

  AdditionalInfoId(const AdditionalInfoId& from);

  inline AdditionalInfoId& operator=(const AdditionalInfoId& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AdditionalInfoId& default_instance();

  void Swap(AdditionalInfoId* other);

  // implements Message ----------------------------------------------

  AdditionalInfoId* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AdditionalInfoId& from);
  void MergeFrom(const AdditionalInfoId& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string InfoFileId = 1;
  inline bool has_infofileid() const;
  inline void clear_infofileid();
  static const int kInfoFileIdFieldNumber = 1;
  inline const ::std::string& infofileid() const;
  inline void set_infofileid(const ::std::string& value);
  inline void set_infofileid(const char* value);
  inline void set_infofileid(const char* value, size_t size);
  inline ::std::string* mutable_infofileid();
  inline ::std::string* release_infofileid();
  inline void set_allocated_infofileid(::std::string* infofileid);

  // repeated .Diadoc.Api.Proto.Invoicing.AdditionalInfo AdditionalInfo = 2;
  inline int additionalinfo_size() const;
  inline void clear_additionalinfo();
  static const int kAdditionalInfoFieldNumber = 2;
  inline const ::Diadoc::Api::Proto::Invoicing::AdditionalInfo& additionalinfo(int index) const;
  inline ::Diadoc::Api::Proto::Invoicing::AdditionalInfo* mutable_additionalinfo(int index);
  inline ::Diadoc::Api::Proto::Invoicing::AdditionalInfo* add_additionalinfo();
  inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::AdditionalInfo >&
      additionalinfo() const;
  inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::AdditionalInfo >*
      mutable_additionalinfo();

  // @@protoc_insertion_point(class_scope:Diadoc.Api.Proto.Invoicing.AdditionalInfoId)
 private:
  inline void set_has_infofileid();
  inline void clear_has_infofileid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* infofileid_;
  ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::AdditionalInfo > additionalinfo_;
  friend void  protobuf_AddDesc_Invoicing_2fUniversalTransferDocumentInfo_2eproto();
  friend void protobuf_AssignDesc_Invoicing_2fUniversalTransferDocumentInfo_2eproto();
  friend void protobuf_ShutdownFile_Invoicing_2fUniversalTransferDocumentInfo_2eproto();

  void InitAsDefaultInstance();
  static AdditionalInfoId* default_instance_;
};
// -------------------------------------------------------------------

class UniversalTransferDocumentBuyerTitleInfo : public ::google::protobuf::Message {
 public:
  UniversalTransferDocumentBuyerTitleInfo();
  virtual ~UniversalTransferDocumentBuyerTitleInfo();

  UniversalTransferDocumentBuyerTitleInfo(const UniversalTransferDocumentBuyerTitleInfo& from);

  inline UniversalTransferDocumentBuyerTitleInfo& operator=(const UniversalTransferDocumentBuyerTitleInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UniversalTransferDocumentBuyerTitleInfo& default_instance();

  void Swap(UniversalTransferDocumentBuyerTitleInfo* other);

  // implements Message ----------------------------------------------

  UniversalTransferDocumentBuyerTitleInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UniversalTransferDocumentBuyerTitleInfo& from);
  void MergeFrom(const UniversalTransferDocumentBuyerTitleInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string DocumentCreator = 1;
  inline bool has_documentcreator() const;
  inline void clear_documentcreator();
  static const int kDocumentCreatorFieldNumber = 1;
  inline const ::std::string& documentcreator() const;
  inline void set_documentcreator(const ::std::string& value);
  inline void set_documentcreator(const char* value);
  inline void set_documentcreator(const char* value, size_t size);
  inline ::std::string* mutable_documentcreator();
  inline ::std::string* release_documentcreator();
  inline void set_allocated_documentcreator(::std::string* documentcreator);

  // optional string DocumentCreatorBase = 2;
  inline bool has_documentcreatorbase() const;
  inline void clear_documentcreatorbase();
  static const int kDocumentCreatorBaseFieldNumber = 2;
  inline const ::std::string& documentcreatorbase() const;
  inline void set_documentcreatorbase(const ::std::string& value);
  inline void set_documentcreatorbase(const char* value);
  inline void set_documentcreatorbase(const char* value, size_t size);
  inline ::std::string* mutable_documentcreatorbase();
  inline ::std::string* release_documentcreatorbase();
  inline void set_allocated_documentcreatorbase(::std::string* documentcreatorbase);

  // optional string OperationCode = 3;
  inline bool has_operationcode() const;
  inline void clear_operationcode();
  static const int kOperationCodeFieldNumber = 3;
  inline const ::std::string& operationcode() const;
  inline void set_operationcode(const ::std::string& value);
  inline void set_operationcode(const char* value);
  inline void set_operationcode(const char* value, size_t size);
  inline ::std::string* mutable_operationcode();
  inline ::std::string* release_operationcode();
  inline void set_allocated_operationcode(::std::string* operationcode);

  // required string OperationContent = 4;
  inline bool has_operationcontent() const;
  inline void clear_operationcontent();
  static const int kOperationContentFieldNumber = 4;
  inline const ::std::string& operationcontent() const;
  inline void set_operationcontent(const ::std::string& value);
  inline void set_operationcontent(const char* value);
  inline void set_operationcontent(const char* value, size_t size);
  inline ::std::string* mutable_operationcontent();
  inline ::std::string* release_operationcontent();
  inline void set_allocated_operationcontent(::std::string* operationcontent);

  // optional string AcceptanceDate = 5;
  inline bool has_acceptancedate() const;
  inline void clear_acceptancedate();
  static const int kAcceptanceDateFieldNumber = 5;
  inline const ::std::string& acceptancedate() const;
  inline void set_acceptancedate(const ::std::string& value);
  inline void set_acceptancedate(const char* value);
  inline void set_acceptancedate(const char* value, size_t size);
  inline ::std::string* mutable_acceptancedate();
  inline ::std::string* release_acceptancedate();
  inline void set_allocated_acceptancedate(::std::string* acceptancedate);

  // optional .Diadoc.Api.Proto.Invoicing.Employee Employee = 6;
  inline bool has_employee() const;
  inline void clear_employee();
  static const int kEmployeeFieldNumber = 6;
  inline const ::Diadoc::Api::Proto::Invoicing::Employee& employee() const;
  inline ::Diadoc::Api::Proto::Invoicing::Employee* mutable_employee();
  inline ::Diadoc::Api::Proto::Invoicing::Employee* release_employee();
  inline void set_allocated_employee(::Diadoc::Api::Proto::Invoicing::Employee* employee);

  // optional .Diadoc.Api.Proto.Invoicing.OtherIssuer OtherIssuer = 7;
  inline bool has_otherissuer() const;
  inline void clear_otherissuer();
  static const int kOtherIssuerFieldNumber = 7;
  inline const ::Diadoc::Api::Proto::Invoicing::OtherIssuer& otherissuer() const;
  inline ::Diadoc::Api::Proto::Invoicing::OtherIssuer* mutable_otherissuer();
  inline ::Diadoc::Api::Proto::Invoicing::OtherIssuer* release_otherissuer();
  inline void set_allocated_otherissuer(::Diadoc::Api::Proto::Invoicing::OtherIssuer* otherissuer);

  // optional .Diadoc.Api.Proto.Invoicing.AdditionalInfoId AdditionalInfoId = 8;
  inline bool has_additionalinfoid() const;
  inline void clear_additionalinfoid();
  static const int kAdditionalInfoIdFieldNumber = 8;
  inline const ::Diadoc::Api::Proto::Invoicing::AdditionalInfoId& additionalinfoid() const;
  inline ::Diadoc::Api::Proto::Invoicing::AdditionalInfoId* mutable_additionalinfoid();
  inline ::Diadoc::Api::Proto::Invoicing::AdditionalInfoId* release_additionalinfoid();
  inline void set_allocated_additionalinfoid(::Diadoc::Api::Proto::Invoicing::AdditionalInfoId* additionalinfoid);

  // repeated .Diadoc.Api.Proto.Invoicing.Signers.ExtendedSigner Signers = 9;
  inline int signers_size() const;
  inline void clear_signers();
  static const int kSignersFieldNumber = 9;
  inline const ::Diadoc::Api::Proto::Invoicing::Signers::ExtendedSigner& signers(int index) const;
  inline ::Diadoc::Api::Proto::Invoicing::Signers::ExtendedSigner* mutable_signers(int index);
  inline ::Diadoc::Api::Proto::Invoicing::Signers::ExtendedSigner* add_signers();
  inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::Signers::ExtendedSigner >&
      signers() const;
  inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::Signers::ExtendedSigner >*
      mutable_signers();

  // @@protoc_insertion_point(class_scope:Diadoc.Api.Proto.Invoicing.UniversalTransferDocumentBuyerTitleInfo)
 private:
  inline void set_has_documentcreator();
  inline void clear_has_documentcreator();
  inline void set_has_documentcreatorbase();
  inline void clear_has_documentcreatorbase();
  inline void set_has_operationcode();
  inline void clear_has_operationcode();
  inline void set_has_operationcontent();
  inline void clear_has_operationcontent();
  inline void set_has_acceptancedate();
  inline void clear_has_acceptancedate();
  inline void set_has_employee();
  inline void clear_has_employee();
  inline void set_has_otherissuer();
  inline void clear_has_otherissuer();
  inline void set_has_additionalinfoid();
  inline void clear_has_additionalinfoid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* documentcreator_;
  ::std::string* documentcreatorbase_;
  ::std::string* operationcode_;
  ::std::string* operationcontent_;
  ::std::string* acceptancedate_;
  ::Diadoc::Api::Proto::Invoicing::Employee* employee_;
  ::Diadoc::Api::Proto::Invoicing::OtherIssuer* otherissuer_;
  ::Diadoc::Api::Proto::Invoicing::AdditionalInfoId* additionalinfoid_;
  ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::Signers::ExtendedSigner > signers_;
  friend void  protobuf_AddDesc_Invoicing_2fUniversalTransferDocumentInfo_2eproto();
  friend void protobuf_AssignDesc_Invoicing_2fUniversalTransferDocumentInfo_2eproto();
  friend void protobuf_ShutdownFile_Invoicing_2fUniversalTransferDocumentInfo_2eproto();

  void InitAsDefaultInstance();
  static UniversalTransferDocumentBuyerTitleInfo* default_instance_;
};
// -------------------------------------------------------------------

class UniversalCorrectionDocumentSellerTitleInfo : public ::google::protobuf::Message {
 public:
  UniversalCorrectionDocumentSellerTitleInfo();
  virtual ~UniversalCorrectionDocumentSellerTitleInfo();

  UniversalCorrectionDocumentSellerTitleInfo(const UniversalCorrectionDocumentSellerTitleInfo& from);

  inline UniversalCorrectionDocumentSellerTitleInfo& operator=(const UniversalCorrectionDocumentSellerTitleInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UniversalCorrectionDocumentSellerTitleInfo& default_instance();

  void Swap(UniversalCorrectionDocumentSellerTitleInfo* other);

  // implements Message ----------------------------------------------

  UniversalCorrectionDocumentSellerTitleInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UniversalCorrectionDocumentSellerTitleInfo& from);
  void MergeFrom(const UniversalCorrectionDocumentSellerTitleInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Diadoc.Api.Proto.Invoicing.FunctionType Function = 1;
  inline bool has_function() const;
  inline void clear_function();
  static const int kFunctionFieldNumber = 1;
  inline ::Diadoc::Api::Proto::Invoicing::FunctionType function() const;
  inline void set_function(::Diadoc::Api::Proto::Invoicing::FunctionType value);

  // optional string DocumentName = 2;
  inline bool has_documentname() const;
  inline void clear_documentname();
  static const int kDocumentNameFieldNumber = 2;
  inline const ::std::string& documentname() const;
  inline void set_documentname(const ::std::string& value);
  inline void set_documentname(const char* value);
  inline void set_documentname(const char* value, size_t size);
  inline ::std::string* mutable_documentname();
  inline ::std::string* release_documentname();
  inline void set_allocated_documentname(::std::string* documentname);

  // required string DocumentDate = 3;
  inline bool has_documentdate() const;
  inline void clear_documentdate();
  static const int kDocumentDateFieldNumber = 3;
  inline const ::std::string& documentdate() const;
  inline void set_documentdate(const ::std::string& value);
  inline void set_documentdate(const char* value);
  inline void set_documentdate(const char* value, size_t size);
  inline ::std::string* mutable_documentdate();
  inline ::std::string* release_documentdate();
  inline void set_allocated_documentdate(::std::string* documentdate);

  // required string DocumentNumber = 4;
  inline bool has_documentnumber() const;
  inline void clear_documentnumber();
  static const int kDocumentNumberFieldNumber = 4;
  inline const ::std::string& documentnumber() const;
  inline void set_documentnumber(const ::std::string& value);
  inline void set_documentnumber(const char* value);
  inline void set_documentnumber(const char* value, size_t size);
  inline ::std::string* mutable_documentnumber();
  inline ::std::string* release_documentnumber();
  inline void set_allocated_documentnumber(::std::string* documentnumber);

  // repeated .Diadoc.Api.Proto.Invoicing.InvoiceForCorrectionInfo Invoices = 5;
  inline int invoices_size() const;
  inline void clear_invoices();
  static const int kInvoicesFieldNumber = 5;
  inline const ::Diadoc::Api::Proto::Invoicing::InvoiceForCorrectionInfo& invoices(int index) const;
  inline ::Diadoc::Api::Proto::Invoicing::InvoiceForCorrectionInfo* mutable_invoices(int index);
  inline ::Diadoc::Api::Proto::Invoicing::InvoiceForCorrectionInfo* add_invoices();
  inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::InvoiceForCorrectionInfo >&
      invoices() const;
  inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::InvoiceForCorrectionInfo >*
      mutable_invoices();

  // required .Diadoc.Api.Proto.Invoicing.Organizations.ExtendedOrganizationInfo Seller = 6;
  inline bool has_seller() const;
  inline void clear_seller();
  static const int kSellerFieldNumber = 6;
  inline const ::Diadoc::Api::Proto::Invoicing::Organizations::ExtendedOrganizationInfo& seller() const;
  inline ::Diadoc::Api::Proto::Invoicing::Organizations::ExtendedOrganizationInfo* mutable_seller();
  inline ::Diadoc::Api::Proto::Invoicing::Organizations::ExtendedOrganizationInfo* release_seller();
  inline void set_allocated_seller(::Diadoc::Api::Proto::Invoicing::Organizations::ExtendedOrganizationInfo* seller);

  // required .Diadoc.Api.Proto.Invoicing.Organizations.ExtendedOrganizationInfo Buyer = 7;
  inline bool has_buyer() const;
  inline void clear_buyer();
  static const int kBuyerFieldNumber = 7;
  inline const ::Diadoc::Api::Proto::Invoicing::Organizations::ExtendedOrganizationInfo& buyer() const;
  inline ::Diadoc::Api::Proto::Invoicing::Organizations::ExtendedOrganizationInfo* mutable_buyer();
  inline ::Diadoc::Api::Proto::Invoicing::Organizations::ExtendedOrganizationInfo* release_buyer();
  inline void set_allocated_buyer(::Diadoc::Api::Proto::Invoicing::Organizations::ExtendedOrganizationInfo* buyer);

  // repeated .Diadoc.Api.Proto.Invoicing.Signers.ExtendedSigner Signers = 8;
  inline int signers_size() const;
  inline void clear_signers();
  static const int kSignersFieldNumber = 8;
  inline const ::Diadoc::Api::Proto::Invoicing::Signers::ExtendedSigner& signers(int index) const;
  inline ::Diadoc::Api::Proto::Invoicing::Signers::ExtendedSigner* mutable_signers(int index);
  inline ::Diadoc::Api::Proto::Invoicing::Signers::ExtendedSigner* add_signers();
  inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::Signers::ExtendedSigner >&
      signers() const;
  inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::Signers::ExtendedSigner >*
      mutable_signers();

  // required .Diadoc.Api.Proto.Invoicing.EventContent EventContent = 9;
  inline bool has_eventcontent() const;
  inline void clear_eventcontent();
  static const int kEventContentFieldNumber = 9;
  inline const ::Diadoc::Api::Proto::Invoicing::EventContent& eventcontent() const;
  inline ::Diadoc::Api::Proto::Invoicing::EventContent* mutable_eventcontent();
  inline ::Diadoc::Api::Proto::Invoicing::EventContent* release_eventcontent();
  inline void set_allocated_eventcontent(::Diadoc::Api::Proto::Invoicing::EventContent* eventcontent);

  // required .Diadoc.Api.Proto.Invoicing.InvoiceCorrectionTable InvoiceCorrectionTable = 10;
  inline bool has_invoicecorrectiontable() const;
  inline void clear_invoicecorrectiontable();
  static const int kInvoiceCorrectionTableFieldNumber = 10;
  inline const ::Diadoc::Api::Proto::Invoicing::InvoiceCorrectionTable& invoicecorrectiontable() const;
  inline ::Diadoc::Api::Proto::Invoicing::InvoiceCorrectionTable* mutable_invoicecorrectiontable();
  inline ::Diadoc::Api::Proto::Invoicing::InvoiceCorrectionTable* release_invoicecorrectiontable();
  inline void set_allocated_invoicecorrectiontable(::Diadoc::Api::Proto::Invoicing::InvoiceCorrectionTable* invoicecorrectiontable);

  // required string Currency = 11;
  inline bool has_currency() const;
  inline void clear_currency();
  static const int kCurrencyFieldNumber = 11;
  inline const ::std::string& currency() const;
  inline void set_currency(const ::std::string& value);
  inline void set_currency(const char* value);
  inline void set_currency(const char* value, size_t size);
  inline ::std::string* mutable_currency();
  inline ::std::string* release_currency();
  inline void set_allocated_currency(::std::string* currency);

  // optional string CurrencyRate = 12;
  inline bool has_currencyrate() const;
  inline void clear_currencyrate();
  static const int kCurrencyRateFieldNumber = 12;
  inline const ::std::string& currencyrate() const;
  inline void set_currencyrate(const ::std::string& value);
  inline void set_currencyrate(const char* value);
  inline void set_currencyrate(const char* value, size_t size);
  inline ::std::string* mutable_currencyrate();
  inline ::std::string* release_currencyrate();
  inline void set_allocated_currencyrate(::std::string* currencyrate);

  // optional string CorrectionRevisionDate = 13;
  inline bool has_correctionrevisiondate() const;
  inline void clear_correctionrevisiondate();
  static const int kCorrectionRevisionDateFieldNumber = 13;
  inline const ::std::string& correctionrevisiondate() const;
  inline void set_correctionrevisiondate(const ::std::string& value);
  inline void set_correctionrevisiondate(const char* value);
  inline void set_correctionrevisiondate(const char* value, size_t size);
  inline ::std::string* mutable_correctionrevisiondate();
  inline ::std::string* release_correctionrevisiondate();
  inline void set_allocated_correctionrevisiondate(::std::string* correctionrevisiondate);

  // optional string CorrectionRevisionNumber = 14;
  inline bool has_correctionrevisionnumber() const;
  inline void clear_correctionrevisionnumber();
  static const int kCorrectionRevisionNumberFieldNumber = 14;
  inline const ::std::string& correctionrevisionnumber() const;
  inline void set_correctionrevisionnumber(const ::std::string& value);
  inline void set_correctionrevisionnumber(const char* value);
  inline void set_correctionrevisionnumber(const char* value, size_t size);
  inline ::std::string* mutable_correctionrevisionnumber();
  inline ::std::string* release_correctionrevisionnumber();
  inline void set_allocated_correctionrevisionnumber(::std::string* correctionrevisionnumber);

  // optional .Diadoc.Api.Proto.Invoicing.AdditionalInfoId AdditionalInfoId = 15;
  inline bool has_additionalinfoid() const;
  inline void clear_additionalinfoid();
  static const int kAdditionalInfoIdFieldNumber = 15;
  inline const ::Diadoc::Api::Proto::Invoicing::AdditionalInfoId& additionalinfoid() const;
  inline ::Diadoc::Api::Proto::Invoicing::AdditionalInfoId* mutable_additionalinfoid();
  inline ::Diadoc::Api::Proto::Invoicing::AdditionalInfoId* release_additionalinfoid();
  inline void set_allocated_additionalinfoid(::Diadoc::Api::Proto::Invoicing::AdditionalInfoId* additionalinfoid);

  // required string DocumentCreator = 16;
  inline bool has_documentcreator() const;
  inline void clear_documentcreator();
  static const int kDocumentCreatorFieldNumber = 16;
  inline const ::std::string& documentcreator() const;
  inline void set_documentcreator(const ::std::string& value);
  inline void set_documentcreator(const char* value);
  inline void set_documentcreator(const char* value, size_t size);
  inline ::std::string* mutable_documentcreator();
  inline ::std::string* release_documentcreator();
  inline void set_allocated_documentcreator(::std::string* documentcreator);

  // optional string DocumentCreatorBase = 17;
  inline bool has_documentcreatorbase() const;
  inline void clear_documentcreatorbase();
  static const int kDocumentCreatorBaseFieldNumber = 17;
  inline const ::std::string& documentcreatorbase() const;
  inline void set_documentcreatorbase(const ::std::string& value);
  inline void set_documentcreatorbase(const char* value);
  inline void set_documentcreatorbase(const char* value, size_t size);
  inline ::std::string* mutable_documentcreatorbase();
  inline ::std::string* release_documentcreatorbase();
  inline void set_allocated_documentcreatorbase(::std::string* documentcreatorbase);

  // optional string GovernmentContractInfo = 18;
  inline bool has_governmentcontractinfo() const;
  inline void clear_governmentcontractinfo();
  static const int kGovernmentContractInfoFieldNumber = 18;
  inline const ::std::string& governmentcontractinfo() const;
  inline void set_governmentcontractinfo(const ::std::string& value);
  inline void set_governmentcontractinfo(const char* value);
  inline void set_governmentcontractinfo(const char* value, size_t size);
  inline ::std::string* mutable_governmentcontractinfo();
  inline ::std::string* release_governmentcontractinfo();
  inline void set_allocated_governmentcontractinfo(::std::string* governmentcontractinfo);

  // @@protoc_insertion_point(class_scope:Diadoc.Api.Proto.Invoicing.UniversalCorrectionDocumentSellerTitleInfo)
 private:
  inline void set_has_function();
  inline void clear_has_function();
  inline void set_has_documentname();
  inline void clear_has_documentname();
  inline void set_has_documentdate();
  inline void clear_has_documentdate();
  inline void set_has_documentnumber();
  inline void clear_has_documentnumber();
  inline void set_has_seller();
  inline void clear_has_seller();
  inline void set_has_buyer();
  inline void clear_has_buyer();
  inline void set_has_eventcontent();
  inline void clear_has_eventcontent();
  inline void set_has_invoicecorrectiontable();
  inline void clear_has_invoicecorrectiontable();
  inline void set_has_currency();
  inline void clear_has_currency();
  inline void set_has_currencyrate();
  inline void clear_has_currencyrate();
  inline void set_has_correctionrevisiondate();
  inline void clear_has_correctionrevisiondate();
  inline void set_has_correctionrevisionnumber();
  inline void clear_has_correctionrevisionnumber();
  inline void set_has_additionalinfoid();
  inline void clear_has_additionalinfoid();
  inline void set_has_documentcreator();
  inline void clear_has_documentcreator();
  inline void set_has_documentcreatorbase();
  inline void clear_has_documentcreatorbase();
  inline void set_has_governmentcontractinfo();
  inline void clear_has_governmentcontractinfo();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* documentname_;
  ::std::string* documentdate_;
  ::std::string* documentnumber_;
  ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::InvoiceForCorrectionInfo > invoices_;
  ::Diadoc::Api::Proto::Invoicing::Organizations::ExtendedOrganizationInfo* seller_;
  ::Diadoc::Api::Proto::Invoicing::Organizations::ExtendedOrganizationInfo* buyer_;
  ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::Signers::ExtendedSigner > signers_;
  ::Diadoc::Api::Proto::Invoicing::EventContent* eventcontent_;
  ::Diadoc::Api::Proto::Invoicing::InvoiceCorrectionTable* invoicecorrectiontable_;
  ::std::string* currency_;
  ::std::string* currencyrate_;
  ::std::string* correctionrevisiondate_;
  ::std::string* correctionrevisionnumber_;
  ::Diadoc::Api::Proto::Invoicing::AdditionalInfoId* additionalinfoid_;
  ::std::string* documentcreator_;
  ::std::string* documentcreatorbase_;
  ::std::string* governmentcontractinfo_;
  int function_;
  friend void  protobuf_AddDesc_Invoicing_2fUniversalTransferDocumentInfo_2eproto();
  friend void protobuf_AssignDesc_Invoicing_2fUniversalTransferDocumentInfo_2eproto();
  friend void protobuf_ShutdownFile_Invoicing_2fUniversalTransferDocumentInfo_2eproto();

  void InitAsDefaultInstance();
  static UniversalCorrectionDocumentSellerTitleInfo* default_instance_;
};
// -------------------------------------------------------------------

class InvoiceForCorrectionInfo : public ::google::protobuf::Message {
 public:
  InvoiceForCorrectionInfo();
  virtual ~InvoiceForCorrectionInfo();

  InvoiceForCorrectionInfo(const InvoiceForCorrectionInfo& from);

  inline InvoiceForCorrectionInfo& operator=(const InvoiceForCorrectionInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InvoiceForCorrectionInfo& default_instance();

  void Swap(InvoiceForCorrectionInfo* other);

  // implements Message ----------------------------------------------

  InvoiceForCorrectionInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InvoiceForCorrectionInfo& from);
  void MergeFrom(const InvoiceForCorrectionInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string InvoiceDate = 1;
  inline bool has_invoicedate() const;
  inline void clear_invoicedate();
  static const int kInvoiceDateFieldNumber = 1;
  inline const ::std::string& invoicedate() const;
  inline void set_invoicedate(const ::std::string& value);
  inline void set_invoicedate(const char* value);
  inline void set_invoicedate(const char* value, size_t size);
  inline ::std::string* mutable_invoicedate();
  inline ::std::string* release_invoicedate();
  inline void set_allocated_invoicedate(::std::string* invoicedate);

  // required string InvoiceNumber = 2;
  inline bool has_invoicenumber() const;
  inline void clear_invoicenumber();
  static const int kInvoiceNumberFieldNumber = 2;
  inline const ::std::string& invoicenumber() const;
  inline void set_invoicenumber(const ::std::string& value);
  inline void set_invoicenumber(const char* value);
  inline void set_invoicenumber(const char* value, size_t size);
  inline ::std::string* mutable_invoicenumber();
  inline ::std::string* release_invoicenumber();
  inline void set_allocated_invoicenumber(::std::string* invoicenumber);

  // repeated .Diadoc.Api.Proto.Invoicing.InvoiceRevisionInfo InvoiceRevisions = 3;
  inline int invoicerevisions_size() const;
  inline void clear_invoicerevisions();
  static const int kInvoiceRevisionsFieldNumber = 3;
  inline const ::Diadoc::Api::Proto::Invoicing::InvoiceRevisionInfo& invoicerevisions(int index) const;
  inline ::Diadoc::Api::Proto::Invoicing::InvoiceRevisionInfo* mutable_invoicerevisions(int index);
  inline ::Diadoc::Api::Proto::Invoicing::InvoiceRevisionInfo* add_invoicerevisions();
  inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::InvoiceRevisionInfo >&
      invoicerevisions() const;
  inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::InvoiceRevisionInfo >*
      mutable_invoicerevisions();

  // @@protoc_insertion_point(class_scope:Diadoc.Api.Proto.Invoicing.InvoiceForCorrectionInfo)
 private:
  inline void set_has_invoicedate();
  inline void clear_has_invoicedate();
  inline void set_has_invoicenumber();
  inline void clear_has_invoicenumber();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* invoicedate_;
  ::std::string* invoicenumber_;
  ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::InvoiceRevisionInfo > invoicerevisions_;
  friend void  protobuf_AddDesc_Invoicing_2fUniversalTransferDocumentInfo_2eproto();
  friend void protobuf_AssignDesc_Invoicing_2fUniversalTransferDocumentInfo_2eproto();
  friend void protobuf_ShutdownFile_Invoicing_2fUniversalTransferDocumentInfo_2eproto();

  void InitAsDefaultInstance();
  static InvoiceForCorrectionInfo* default_instance_;
};
// -------------------------------------------------------------------

class InvoiceRevisionInfo : public ::google::protobuf::Message {
 public:
  InvoiceRevisionInfo();
  virtual ~InvoiceRevisionInfo();

  InvoiceRevisionInfo(const InvoiceRevisionInfo& from);

  inline InvoiceRevisionInfo& operator=(const InvoiceRevisionInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InvoiceRevisionInfo& default_instance();

  void Swap(InvoiceRevisionInfo* other);

  // implements Message ----------------------------------------------

  InvoiceRevisionInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InvoiceRevisionInfo& from);
  void MergeFrom(const InvoiceRevisionInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string InvoiceRevisionDate = 1;
  inline bool has_invoicerevisiondate() const;
  inline void clear_invoicerevisiondate();
  static const int kInvoiceRevisionDateFieldNumber = 1;
  inline const ::std::string& invoicerevisiondate() const;
  inline void set_invoicerevisiondate(const ::std::string& value);
  inline void set_invoicerevisiondate(const char* value);
  inline void set_invoicerevisiondate(const char* value, size_t size);
  inline ::std::string* mutable_invoicerevisiondate();
  inline ::std::string* release_invoicerevisiondate();
  inline void set_allocated_invoicerevisiondate(::std::string* invoicerevisiondate);

  // required string InvoiceRevisionNumber = 2;
  inline bool has_invoicerevisionnumber() const;
  inline void clear_invoicerevisionnumber();
  static const int kInvoiceRevisionNumberFieldNumber = 2;
  inline const ::std::string& invoicerevisionnumber() const;
  inline void set_invoicerevisionnumber(const ::std::string& value);
  inline void set_invoicerevisionnumber(const char* value);
  inline void set_invoicerevisionnumber(const char* value, size_t size);
  inline ::std::string* mutable_invoicerevisionnumber();
  inline ::std::string* release_invoicerevisionnumber();
  inline void set_allocated_invoicerevisionnumber(::std::string* invoicerevisionnumber);

  // @@protoc_insertion_point(class_scope:Diadoc.Api.Proto.Invoicing.InvoiceRevisionInfo)
 private:
  inline void set_has_invoicerevisiondate();
  inline void clear_has_invoicerevisiondate();
  inline void set_has_invoicerevisionnumber();
  inline void clear_has_invoicerevisionnumber();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* invoicerevisiondate_;
  ::std::string* invoicerevisionnumber_;
  friend void  protobuf_AddDesc_Invoicing_2fUniversalTransferDocumentInfo_2eproto();
  friend void protobuf_AssignDesc_Invoicing_2fUniversalTransferDocumentInfo_2eproto();
  friend void protobuf_ShutdownFile_Invoicing_2fUniversalTransferDocumentInfo_2eproto();

  void InitAsDefaultInstance();
  static InvoiceRevisionInfo* default_instance_;
};
// -------------------------------------------------------------------

class EventContent : public ::google::protobuf::Message {
 public:
  EventContent();
  virtual ~EventContent();

  EventContent(const EventContent& from);

  inline EventContent& operator=(const EventContent& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EventContent& default_instance();

  void Swap(EventContent* other);

  // implements Message ----------------------------------------------

  EventContent* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EventContent& from);
  void MergeFrom(const EventContent& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string CostChangeInfo = 1;
  inline bool has_costchangeinfo() const;
  inline void clear_costchangeinfo();
  static const int kCostChangeInfoFieldNumber = 1;
  inline const ::std::string& costchangeinfo() const;
  inline void set_costchangeinfo(const ::std::string& value);
  inline void set_costchangeinfo(const char* value);
  inline void set_costchangeinfo(const char* value, size_t size);
  inline ::std::string* mutable_costchangeinfo();
  inline ::std::string* release_costchangeinfo();
  inline void set_allocated_costchangeinfo(::std::string* costchangeinfo);

  // optional string TransferDocDetails = 2;
  inline bool has_transferdocdetails() const;
  inline void clear_transferdocdetails();
  static const int kTransferDocDetailsFieldNumber = 2;
  inline const ::std::string& transferdocdetails() const;
  inline void set_transferdocdetails(const ::std::string& value);
  inline void set_transferdocdetails(const char* value);
  inline void set_transferdocdetails(const char* value, size_t size);
  inline ::std::string* mutable_transferdocdetails();
  inline ::std::string* release_transferdocdetails();
  inline void set_allocated_transferdocdetails(::std::string* transferdocdetails);

  // required string OperationContent = 3;
  inline bool has_operationcontent() const;
  inline void clear_operationcontent();
  static const int kOperationContentFieldNumber = 3;
  inline const ::std::string& operationcontent() const;
  inline void set_operationcontent(const ::std::string& value);
  inline void set_operationcontent(const char* value);
  inline void set_operationcontent(const char* value, size_t size);
  inline ::std::string* mutable_operationcontent();
  inline ::std::string* release_operationcontent();
  inline void set_allocated_operationcontent(::std::string* operationcontent);

  // optional string NotificationDate = 4;
  inline bool has_notificationdate() const;
  inline void clear_notificationdate();
  static const int kNotificationDateFieldNumber = 4;
  inline const ::std::string& notificationdate() const;
  inline void set_notificationdate(const ::std::string& value);
  inline void set_notificationdate(const char* value);
  inline void set_notificationdate(const char* value, size_t size);
  inline ::std::string* mutable_notificationdate();
  inline ::std::string* release_notificationdate();
  inline void set_allocated_notificationdate(::std::string* notificationdate);

  // repeated .Diadoc.Api.Proto.Invoicing.CorrectionBase CorrectionBase = 5;
  inline int correctionbase_size() const;
  inline void clear_correctionbase();
  static const int kCorrectionBaseFieldNumber = 5;
  inline const ::Diadoc::Api::Proto::Invoicing::CorrectionBase& correctionbase(int index) const;
  inline ::Diadoc::Api::Proto::Invoicing::CorrectionBase* mutable_correctionbase(int index);
  inline ::Diadoc::Api::Proto::Invoicing::CorrectionBase* add_correctionbase();
  inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::CorrectionBase >&
      correctionbase() const;
  inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::CorrectionBase >*
      mutable_correctionbase();

  // @@protoc_insertion_point(class_scope:Diadoc.Api.Proto.Invoicing.EventContent)
 private:
  inline void set_has_costchangeinfo();
  inline void clear_has_costchangeinfo();
  inline void set_has_transferdocdetails();
  inline void clear_has_transferdocdetails();
  inline void set_has_operationcontent();
  inline void clear_has_operationcontent();
  inline void set_has_notificationdate();
  inline void clear_has_notificationdate();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* costchangeinfo_;
  ::std::string* transferdocdetails_;
  ::std::string* operationcontent_;
  ::std::string* notificationdate_;
  ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::CorrectionBase > correctionbase_;
  friend void  protobuf_AddDesc_Invoicing_2fUniversalTransferDocumentInfo_2eproto();
  friend void protobuf_AssignDesc_Invoicing_2fUniversalTransferDocumentInfo_2eproto();
  friend void protobuf_ShutdownFile_Invoicing_2fUniversalTransferDocumentInfo_2eproto();

  void InitAsDefaultInstance();
  static EventContent* default_instance_;
};
// -------------------------------------------------------------------

class CorrectionBase : public ::google::protobuf::Message {
 public:
  CorrectionBase();
  virtual ~CorrectionBase();

  CorrectionBase(const CorrectionBase& from);

  inline CorrectionBase& operator=(const CorrectionBase& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CorrectionBase& default_instance();

  void Swap(CorrectionBase* other);

  // implements Message ----------------------------------------------

  CorrectionBase* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CorrectionBase& from);
  void MergeFrom(const CorrectionBase& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string BaseDocumentName = 1;
  inline bool has_basedocumentname() const;
  inline void clear_basedocumentname();
  static const int kBaseDocumentNameFieldNumber = 1;
  inline const ::std::string& basedocumentname() const;
  inline void set_basedocumentname(const ::std::string& value);
  inline void set_basedocumentname(const char* value);
  inline void set_basedocumentname(const char* value, size_t size);
  inline ::std::string* mutable_basedocumentname();
  inline ::std::string* release_basedocumentname();
  inline void set_allocated_basedocumentname(::std::string* basedocumentname);

  // optional string BaseDocumentNumber = 2;
  inline bool has_basedocumentnumber() const;
  inline void clear_basedocumentnumber();
  static const int kBaseDocumentNumberFieldNumber = 2;
  inline const ::std::string& basedocumentnumber() const;
  inline void set_basedocumentnumber(const ::std::string& value);
  inline void set_basedocumentnumber(const char* value);
  inline void set_basedocumentnumber(const char* value, size_t size);
  inline ::std::string* mutable_basedocumentnumber();
  inline ::std::string* release_basedocumentnumber();
  inline void set_allocated_basedocumentnumber(::std::string* basedocumentnumber);

  // optional string BaseDocumentDate = 3;
  inline bool has_basedocumentdate() const;
  inline void clear_basedocumentdate();
  static const int kBaseDocumentDateFieldNumber = 3;
  inline const ::std::string& basedocumentdate() const;
  inline void set_basedocumentdate(const ::std::string& value);
  inline void set_basedocumentdate(const char* value);
  inline void set_basedocumentdate(const char* value, size_t size);
  inline ::std::string* mutable_basedocumentdate();
  inline ::std::string* release_basedocumentdate();
  inline void set_allocated_basedocumentdate(::std::string* basedocumentdate);

  // optional string AdditionalInfo = 4;
  inline bool has_additionalinfo() const;
  inline void clear_additionalinfo();
  static const int kAdditionalInfoFieldNumber = 4;
  inline const ::std::string& additionalinfo() const;
  inline void set_additionalinfo(const ::std::string& value);
  inline void set_additionalinfo(const char* value);
  inline void set_additionalinfo(const char* value, size_t size);
  inline ::std::string* mutable_additionalinfo();
  inline ::std::string* release_additionalinfo();
  inline void set_allocated_additionalinfo(::std::string* additionalinfo);

  // @@protoc_insertion_point(class_scope:Diadoc.Api.Proto.Invoicing.CorrectionBase)
 private:
  inline void set_has_basedocumentname();
  inline void clear_has_basedocumentname();
  inline void set_has_basedocumentnumber();
  inline void clear_has_basedocumentnumber();
  inline void set_has_basedocumentdate();
  inline void clear_has_basedocumentdate();
  inline void set_has_additionalinfo();
  inline void clear_has_additionalinfo();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* basedocumentname_;
  ::std::string* basedocumentnumber_;
  ::std::string* basedocumentdate_;
  ::std::string* additionalinfo_;
  friend void  protobuf_AddDesc_Invoicing_2fUniversalTransferDocumentInfo_2eproto();
  friend void protobuf_AssignDesc_Invoicing_2fUniversalTransferDocumentInfo_2eproto();
  friend void protobuf_ShutdownFile_Invoicing_2fUniversalTransferDocumentInfo_2eproto();

  void InitAsDefaultInstance();
  static CorrectionBase* default_instance_;
};
// -------------------------------------------------------------------

class InvoiceCorrectionTable : public ::google::protobuf::Message {
 public:
  InvoiceCorrectionTable();
  virtual ~InvoiceCorrectionTable();

  InvoiceCorrectionTable(const InvoiceCorrectionTable& from);

  inline InvoiceCorrectionTable& operator=(const InvoiceCorrectionTable& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InvoiceCorrectionTable& default_instance();

  void Swap(InvoiceCorrectionTable* other);

  // implements Message ----------------------------------------------

  InvoiceCorrectionTable* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InvoiceCorrectionTable& from);
  void MergeFrom(const InvoiceCorrectionTable& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Diadoc.Api.Proto.Invoicing.ExtendedInvoiceCorrectionItem Items = 1;
  inline int items_size() const;
  inline void clear_items();
  static const int kItemsFieldNumber = 1;
  inline const ::Diadoc::Api::Proto::Invoicing::ExtendedInvoiceCorrectionItem& items(int index) const;
  inline ::Diadoc::Api::Proto::Invoicing::ExtendedInvoiceCorrectionItem* mutable_items(int index);
  inline ::Diadoc::Api::Proto::Invoicing::ExtendedInvoiceCorrectionItem* add_items();
  inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::ExtendedInvoiceCorrectionItem >&
      items() const;
  inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::ExtendedInvoiceCorrectionItem >*
      mutable_items();

  // optional .Diadoc.Api.Proto.Invoicing.InvoiceTotalsDiff TotalsInc = 2;
  inline bool has_totalsinc() const;
  inline void clear_totalsinc();
  static const int kTotalsIncFieldNumber = 2;
  inline const ::Diadoc::Api::Proto::Invoicing::InvoiceTotalsDiff& totalsinc() const;
  inline ::Diadoc::Api::Proto::Invoicing::InvoiceTotalsDiff* mutable_totalsinc();
  inline ::Diadoc::Api::Proto::Invoicing::InvoiceTotalsDiff* release_totalsinc();
  inline void set_allocated_totalsinc(::Diadoc::Api::Proto::Invoicing::InvoiceTotalsDiff* totalsinc);

  // optional .Diadoc.Api.Proto.Invoicing.InvoiceTotalsDiff TotalsDec = 3;
  inline bool has_totalsdec() const;
  inline void clear_totalsdec();
  static const int kTotalsDecFieldNumber = 3;
  inline const ::Diadoc::Api::Proto::Invoicing::InvoiceTotalsDiff& totalsdec() const;
  inline ::Diadoc::Api::Proto::Invoicing::InvoiceTotalsDiff* mutable_totalsdec();
  inline ::Diadoc::Api::Proto::Invoicing::InvoiceTotalsDiff* release_totalsdec();
  inline void set_allocated_totalsdec(::Diadoc::Api::Proto::Invoicing::InvoiceTotalsDiff* totalsdec);

  // @@protoc_insertion_point(class_scope:Diadoc.Api.Proto.Invoicing.InvoiceCorrectionTable)
 private:
  inline void set_has_totalsinc();
  inline void clear_has_totalsinc();
  inline void set_has_totalsdec();
  inline void clear_has_totalsdec();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::ExtendedInvoiceCorrectionItem > items_;
  ::Diadoc::Api::Proto::Invoicing::InvoiceTotalsDiff* totalsinc_;
  ::Diadoc::Api::Proto::Invoicing::InvoiceTotalsDiff* totalsdec_;
  friend void  protobuf_AddDesc_Invoicing_2fUniversalTransferDocumentInfo_2eproto();
  friend void protobuf_AssignDesc_Invoicing_2fUniversalTransferDocumentInfo_2eproto();
  friend void protobuf_ShutdownFile_Invoicing_2fUniversalTransferDocumentInfo_2eproto();

  void InitAsDefaultInstance();
  static InvoiceCorrectionTable* default_instance_;
};
// -------------------------------------------------------------------

class ExtendedInvoiceCorrectionItem : public ::google::protobuf::Message {
 public:
  ExtendedInvoiceCorrectionItem();
  virtual ~ExtendedInvoiceCorrectionItem();

  ExtendedInvoiceCorrectionItem(const ExtendedInvoiceCorrectionItem& from);

  inline ExtendedInvoiceCorrectionItem& operator=(const ExtendedInvoiceCorrectionItem& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ExtendedInvoiceCorrectionItem& default_instance();

  void Swap(ExtendedInvoiceCorrectionItem* other);

  // implements Message ----------------------------------------------

  ExtendedInvoiceCorrectionItem* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ExtendedInvoiceCorrectionItem& from);
  void MergeFrom(const ExtendedInvoiceCorrectionItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string Product = 1;
  inline bool has_product() const;
  inline void clear_product();
  static const int kProductFieldNumber = 1;
  inline const ::std::string& product() const;
  inline void set_product(const ::std::string& value);
  inline void set_product(const char* value);
  inline void set_product(const char* value, size_t size);
  inline ::std::string* mutable_product();
  inline ::std::string* release_product();
  inline void set_allocated_product(::std::string* product);

  // required .Diadoc.Api.Proto.Invoicing.CorrectableInvoiceItemFields OriginalValues = 2;
  inline bool has_originalvalues() const;
  inline void clear_originalvalues();
  static const int kOriginalValuesFieldNumber = 2;
  inline const ::Diadoc::Api::Proto::Invoicing::CorrectableInvoiceItemFields& originalvalues() const;
  inline ::Diadoc::Api::Proto::Invoicing::CorrectableInvoiceItemFields* mutable_originalvalues();
  inline ::Diadoc::Api::Proto::Invoicing::CorrectableInvoiceItemFields* release_originalvalues();
  inline void set_allocated_originalvalues(::Diadoc::Api::Proto::Invoicing::CorrectableInvoiceItemFields* originalvalues);

  // required .Diadoc.Api.Proto.Invoicing.CorrectableInvoiceItemFields CorrectedValues = 3;
  inline bool has_correctedvalues() const;
  inline void clear_correctedvalues();
  static const int kCorrectedValuesFieldNumber = 3;
  inline const ::Diadoc::Api::Proto::Invoicing::CorrectableInvoiceItemFields& correctedvalues() const;
  inline ::Diadoc::Api::Proto::Invoicing::CorrectableInvoiceItemFields* mutable_correctedvalues();
  inline ::Diadoc::Api::Proto::Invoicing::CorrectableInvoiceItemFields* release_correctedvalues();
  inline void set_allocated_correctedvalues(::Diadoc::Api::Proto::Invoicing::CorrectableInvoiceItemFields* correctedvalues);

  // optional .Diadoc.Api.Proto.Invoicing.InvoiceItemAmountsDiff AmountsInc = 4;
  inline bool has_amountsinc() const;
  inline void clear_amountsinc();
  static const int kAmountsIncFieldNumber = 4;
  inline const ::Diadoc::Api::Proto::Invoicing::InvoiceItemAmountsDiff& amountsinc() const;
  inline ::Diadoc::Api::Proto::Invoicing::InvoiceItemAmountsDiff* mutable_amountsinc();
  inline ::Diadoc::Api::Proto::Invoicing::InvoiceItemAmountsDiff* release_amountsinc();
  inline void set_allocated_amountsinc(::Diadoc::Api::Proto::Invoicing::InvoiceItemAmountsDiff* amountsinc);

  // optional .Diadoc.Api.Proto.Invoicing.InvoiceItemAmountsDiff AmountsDec = 5;
  inline bool has_amountsdec() const;
  inline void clear_amountsdec();
  static const int kAmountsDecFieldNumber = 5;
  inline const ::Diadoc::Api::Proto::Invoicing::InvoiceItemAmountsDiff& amountsdec() const;
  inline ::Diadoc::Api::Proto::Invoicing::InvoiceItemAmountsDiff* mutable_amountsdec();
  inline ::Diadoc::Api::Proto::Invoicing::InvoiceItemAmountsDiff* release_amountsdec();
  inline void set_allocated_amountsdec(::Diadoc::Api::Proto::Invoicing::InvoiceItemAmountsDiff* amountsdec);

  // optional string ItemAccountDebit = 6;
  inline bool has_itemaccountdebit() const;
  inline void clear_itemaccountdebit();
  static const int kItemAccountDebitFieldNumber = 6;
  inline const ::std::string& itemaccountdebit() const;
  inline void set_itemaccountdebit(const ::std::string& value);
  inline void set_itemaccountdebit(const char* value);
  inline void set_itemaccountdebit(const char* value, size_t size);
  inline ::std::string* mutable_itemaccountdebit();
  inline ::std::string* release_itemaccountdebit();
  inline void set_allocated_itemaccountdebit(::std::string* itemaccountdebit);

  // optional string ItemAccountCredit = 7;
  inline bool has_itemaccountcredit() const;
  inline void clear_itemaccountcredit();
  static const int kItemAccountCreditFieldNumber = 7;
  inline const ::std::string& itemaccountcredit() const;
  inline void set_itemaccountcredit(const ::std::string& value);
  inline void set_itemaccountcredit(const char* value);
  inline void set_itemaccountcredit(const char* value, size_t size);
  inline ::std::string* mutable_itemaccountcredit();
  inline ::std::string* release_itemaccountcredit();
  inline void set_allocated_itemaccountcredit(::std::string* itemaccountcredit);

  // repeated .Diadoc.Api.Proto.Invoicing.AdditionalInfo AdditionalInfo = 8;
  inline int additionalinfo_size() const;
  inline void clear_additionalinfo();
  static const int kAdditionalInfoFieldNumber = 8;
  inline const ::Diadoc::Api::Proto::Invoicing::AdditionalInfo& additionalinfo(int index) const;
  inline ::Diadoc::Api::Proto::Invoicing::AdditionalInfo* mutable_additionalinfo(int index);
  inline ::Diadoc::Api::Proto::Invoicing::AdditionalInfo* add_additionalinfo();
  inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::AdditionalInfo >&
      additionalinfo() const;
  inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::AdditionalInfo >*
      mutable_additionalinfo();

  // @@protoc_insertion_point(class_scope:Diadoc.Api.Proto.Invoicing.ExtendedInvoiceCorrectionItem)
 private:
  inline void set_has_product();
  inline void clear_has_product();
  inline void set_has_originalvalues();
  inline void clear_has_originalvalues();
  inline void set_has_correctedvalues();
  inline void clear_has_correctedvalues();
  inline void set_has_amountsinc();
  inline void clear_has_amountsinc();
  inline void set_has_amountsdec();
  inline void clear_has_amountsdec();
  inline void set_has_itemaccountdebit();
  inline void clear_has_itemaccountdebit();
  inline void set_has_itemaccountcredit();
  inline void clear_has_itemaccountcredit();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* product_;
  ::Diadoc::Api::Proto::Invoicing::CorrectableInvoiceItemFields* originalvalues_;
  ::Diadoc::Api::Proto::Invoicing::CorrectableInvoiceItemFields* correctedvalues_;
  ::Diadoc::Api::Proto::Invoicing::InvoiceItemAmountsDiff* amountsinc_;
  ::Diadoc::Api::Proto::Invoicing::InvoiceItemAmountsDiff* amountsdec_;
  ::std::string* itemaccountdebit_;
  ::std::string* itemaccountcredit_;
  ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::AdditionalInfo > additionalinfo_;
  friend void  protobuf_AddDesc_Invoicing_2fUniversalTransferDocumentInfo_2eproto();
  friend void protobuf_AssignDesc_Invoicing_2fUniversalTransferDocumentInfo_2eproto();
  friend void protobuf_ShutdownFile_Invoicing_2fUniversalTransferDocumentInfo_2eproto();

  void InitAsDefaultInstance();
  static ExtendedInvoiceCorrectionItem* default_instance_;
};
// ===================================================================


// ===================================================================

// UniversalTransferDocumentSellerTitleInfo

// required .Diadoc.Api.Proto.Invoicing.FunctionType Function = 1;
inline bool UniversalTransferDocumentSellerTitleInfo::has_function() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UniversalTransferDocumentSellerTitleInfo::set_has_function() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UniversalTransferDocumentSellerTitleInfo::clear_has_function() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UniversalTransferDocumentSellerTitleInfo::clear_function() {
  function_ = 0;
  clear_has_function();
}
inline ::Diadoc::Api::Proto::Invoicing::FunctionType UniversalTransferDocumentSellerTitleInfo::function() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.UniversalTransferDocumentSellerTitleInfo.Function)
  return static_cast< ::Diadoc::Api::Proto::Invoicing::FunctionType >(function_);
}
inline void UniversalTransferDocumentSellerTitleInfo::set_function(::Diadoc::Api::Proto::Invoicing::FunctionType value) {
  assert(::Diadoc::Api::Proto::Invoicing::FunctionType_IsValid(value));
  set_has_function();
  function_ = value;
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.UniversalTransferDocumentSellerTitleInfo.Function)
}

// optional string DocumentName = 2;
inline bool UniversalTransferDocumentSellerTitleInfo::has_documentname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UniversalTransferDocumentSellerTitleInfo::set_has_documentname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UniversalTransferDocumentSellerTitleInfo::clear_has_documentname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UniversalTransferDocumentSellerTitleInfo::clear_documentname() {
  if (documentname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    documentname_->clear();
  }
  clear_has_documentname();
}
inline const ::std::string& UniversalTransferDocumentSellerTitleInfo::documentname() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.UniversalTransferDocumentSellerTitleInfo.DocumentName)
  return *documentname_;
}
inline void UniversalTransferDocumentSellerTitleInfo::set_documentname(const ::std::string& value) {
  set_has_documentname();
  if (documentname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    documentname_ = new ::std::string;
  }
  documentname_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.UniversalTransferDocumentSellerTitleInfo.DocumentName)
}
inline void UniversalTransferDocumentSellerTitleInfo::set_documentname(const char* value) {
  set_has_documentname();
  if (documentname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    documentname_ = new ::std::string;
  }
  documentname_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.UniversalTransferDocumentSellerTitleInfo.DocumentName)
}
inline void UniversalTransferDocumentSellerTitleInfo::set_documentname(const char* value, size_t size) {
  set_has_documentname();
  if (documentname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    documentname_ = new ::std::string;
  }
  documentname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.UniversalTransferDocumentSellerTitleInfo.DocumentName)
}
inline ::std::string* UniversalTransferDocumentSellerTitleInfo::mutable_documentname() {
  set_has_documentname();
  if (documentname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    documentname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.UniversalTransferDocumentSellerTitleInfo.DocumentName)
  return documentname_;
}
inline ::std::string* UniversalTransferDocumentSellerTitleInfo::release_documentname() {
  clear_has_documentname();
  if (documentname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = documentname_;
    documentname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UniversalTransferDocumentSellerTitleInfo::set_allocated_documentname(::std::string* documentname) {
  if (documentname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete documentname_;
  }
  if (documentname) {
    set_has_documentname();
    documentname_ = documentname;
  } else {
    clear_has_documentname();
    documentname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.UniversalTransferDocumentSellerTitleInfo.DocumentName)
}

// required string DocumentDate = 3;
inline bool UniversalTransferDocumentSellerTitleInfo::has_documentdate() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UniversalTransferDocumentSellerTitleInfo::set_has_documentdate() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UniversalTransferDocumentSellerTitleInfo::clear_has_documentdate() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UniversalTransferDocumentSellerTitleInfo::clear_documentdate() {
  if (documentdate_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    documentdate_->clear();
  }
  clear_has_documentdate();
}
inline const ::std::string& UniversalTransferDocumentSellerTitleInfo::documentdate() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.UniversalTransferDocumentSellerTitleInfo.DocumentDate)
  return *documentdate_;
}
inline void UniversalTransferDocumentSellerTitleInfo::set_documentdate(const ::std::string& value) {
  set_has_documentdate();
  if (documentdate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    documentdate_ = new ::std::string;
  }
  documentdate_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.UniversalTransferDocumentSellerTitleInfo.DocumentDate)
}
inline void UniversalTransferDocumentSellerTitleInfo::set_documentdate(const char* value) {
  set_has_documentdate();
  if (documentdate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    documentdate_ = new ::std::string;
  }
  documentdate_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.UniversalTransferDocumentSellerTitleInfo.DocumentDate)
}
inline void UniversalTransferDocumentSellerTitleInfo::set_documentdate(const char* value, size_t size) {
  set_has_documentdate();
  if (documentdate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    documentdate_ = new ::std::string;
  }
  documentdate_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.UniversalTransferDocumentSellerTitleInfo.DocumentDate)
}
inline ::std::string* UniversalTransferDocumentSellerTitleInfo::mutable_documentdate() {
  set_has_documentdate();
  if (documentdate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    documentdate_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.UniversalTransferDocumentSellerTitleInfo.DocumentDate)
  return documentdate_;
}
inline ::std::string* UniversalTransferDocumentSellerTitleInfo::release_documentdate() {
  clear_has_documentdate();
  if (documentdate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = documentdate_;
    documentdate_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UniversalTransferDocumentSellerTitleInfo::set_allocated_documentdate(::std::string* documentdate) {
  if (documentdate_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete documentdate_;
  }
  if (documentdate) {
    set_has_documentdate();
    documentdate_ = documentdate;
  } else {
    clear_has_documentdate();
    documentdate_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.UniversalTransferDocumentSellerTitleInfo.DocumentDate)
}

// required string DocumentNumber = 4;
inline bool UniversalTransferDocumentSellerTitleInfo::has_documentnumber() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UniversalTransferDocumentSellerTitleInfo::set_has_documentnumber() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UniversalTransferDocumentSellerTitleInfo::clear_has_documentnumber() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UniversalTransferDocumentSellerTitleInfo::clear_documentnumber() {
  if (documentnumber_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    documentnumber_->clear();
  }
  clear_has_documentnumber();
}
inline const ::std::string& UniversalTransferDocumentSellerTitleInfo::documentnumber() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.UniversalTransferDocumentSellerTitleInfo.DocumentNumber)
  return *documentnumber_;
}
inline void UniversalTransferDocumentSellerTitleInfo::set_documentnumber(const ::std::string& value) {
  set_has_documentnumber();
  if (documentnumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    documentnumber_ = new ::std::string;
  }
  documentnumber_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.UniversalTransferDocumentSellerTitleInfo.DocumentNumber)
}
inline void UniversalTransferDocumentSellerTitleInfo::set_documentnumber(const char* value) {
  set_has_documentnumber();
  if (documentnumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    documentnumber_ = new ::std::string;
  }
  documentnumber_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.UniversalTransferDocumentSellerTitleInfo.DocumentNumber)
}
inline void UniversalTransferDocumentSellerTitleInfo::set_documentnumber(const char* value, size_t size) {
  set_has_documentnumber();
  if (documentnumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    documentnumber_ = new ::std::string;
  }
  documentnumber_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.UniversalTransferDocumentSellerTitleInfo.DocumentNumber)
}
inline ::std::string* UniversalTransferDocumentSellerTitleInfo::mutable_documentnumber() {
  set_has_documentnumber();
  if (documentnumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    documentnumber_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.UniversalTransferDocumentSellerTitleInfo.DocumentNumber)
  return documentnumber_;
}
inline ::std::string* UniversalTransferDocumentSellerTitleInfo::release_documentnumber() {
  clear_has_documentnumber();
  if (documentnumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = documentnumber_;
    documentnumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UniversalTransferDocumentSellerTitleInfo::set_allocated_documentnumber(::std::string* documentnumber) {
  if (documentnumber_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete documentnumber_;
  }
  if (documentnumber) {
    set_has_documentnumber();
    documentnumber_ = documentnumber;
  } else {
    clear_has_documentnumber();
    documentnumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.UniversalTransferDocumentSellerTitleInfo.DocumentNumber)
}

// required .Diadoc.Api.Proto.Invoicing.Organizations.ExtendedOrganizationInfo Seller = 5;
inline bool UniversalTransferDocumentSellerTitleInfo::has_seller() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UniversalTransferDocumentSellerTitleInfo::set_has_seller() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UniversalTransferDocumentSellerTitleInfo::clear_has_seller() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UniversalTransferDocumentSellerTitleInfo::clear_seller() {
  if (seller_ != NULL) seller_->::Diadoc::Api::Proto::Invoicing::Organizations::ExtendedOrganizationInfo::Clear();
  clear_has_seller();
}
inline const ::Diadoc::Api::Proto::Invoicing::Organizations::ExtendedOrganizationInfo& UniversalTransferDocumentSellerTitleInfo::seller() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.UniversalTransferDocumentSellerTitleInfo.Seller)
  return seller_ != NULL ? *seller_ : *default_instance_->seller_;
}
inline ::Diadoc::Api::Proto::Invoicing::Organizations::ExtendedOrganizationInfo* UniversalTransferDocumentSellerTitleInfo::mutable_seller() {
  set_has_seller();
  if (seller_ == NULL) seller_ = new ::Diadoc::Api::Proto::Invoicing::Organizations::ExtendedOrganizationInfo;
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.UniversalTransferDocumentSellerTitleInfo.Seller)
  return seller_;
}
inline ::Diadoc::Api::Proto::Invoicing::Organizations::ExtendedOrganizationInfo* UniversalTransferDocumentSellerTitleInfo::release_seller() {
  clear_has_seller();
  ::Diadoc::Api::Proto::Invoicing::Organizations::ExtendedOrganizationInfo* temp = seller_;
  seller_ = NULL;
  return temp;
}
inline void UniversalTransferDocumentSellerTitleInfo::set_allocated_seller(::Diadoc::Api::Proto::Invoicing::Organizations::ExtendedOrganizationInfo* seller) {
  delete seller_;
  seller_ = seller;
  if (seller) {
    set_has_seller();
  } else {
    clear_has_seller();
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.UniversalTransferDocumentSellerTitleInfo.Seller)
}

// required .Diadoc.Api.Proto.Invoicing.Organizations.ExtendedOrganizationInfo Buyer = 6;
inline bool UniversalTransferDocumentSellerTitleInfo::has_buyer() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UniversalTransferDocumentSellerTitleInfo::set_has_buyer() {
  _has_bits_[0] |= 0x00000020u;
}
inline void UniversalTransferDocumentSellerTitleInfo::clear_has_buyer() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void UniversalTransferDocumentSellerTitleInfo::clear_buyer() {
  if (buyer_ != NULL) buyer_->::Diadoc::Api::Proto::Invoicing::Organizations::ExtendedOrganizationInfo::Clear();
  clear_has_buyer();
}
inline const ::Diadoc::Api::Proto::Invoicing::Organizations::ExtendedOrganizationInfo& UniversalTransferDocumentSellerTitleInfo::buyer() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.UniversalTransferDocumentSellerTitleInfo.Buyer)
  return buyer_ != NULL ? *buyer_ : *default_instance_->buyer_;
}
inline ::Diadoc::Api::Proto::Invoicing::Organizations::ExtendedOrganizationInfo* UniversalTransferDocumentSellerTitleInfo::mutable_buyer() {
  set_has_buyer();
  if (buyer_ == NULL) buyer_ = new ::Diadoc::Api::Proto::Invoicing::Organizations::ExtendedOrganizationInfo;
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.UniversalTransferDocumentSellerTitleInfo.Buyer)
  return buyer_;
}
inline ::Diadoc::Api::Proto::Invoicing::Organizations::ExtendedOrganizationInfo* UniversalTransferDocumentSellerTitleInfo::release_buyer() {
  clear_has_buyer();
  ::Diadoc::Api::Proto::Invoicing::Organizations::ExtendedOrganizationInfo* temp = buyer_;
  buyer_ = NULL;
  return temp;
}
inline void UniversalTransferDocumentSellerTitleInfo::set_allocated_buyer(::Diadoc::Api::Proto::Invoicing::Organizations::ExtendedOrganizationInfo* buyer) {
  delete buyer_;
  buyer_ = buyer;
  if (buyer) {
    set_has_buyer();
  } else {
    clear_has_buyer();
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.UniversalTransferDocumentSellerTitleInfo.Buyer)
}

// optional .Diadoc.Api.Proto.Invoicing.Shipper Shipper = 7;
inline bool UniversalTransferDocumentSellerTitleInfo::has_shipper() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void UniversalTransferDocumentSellerTitleInfo::set_has_shipper() {
  _has_bits_[0] |= 0x00000040u;
}
inline void UniversalTransferDocumentSellerTitleInfo::clear_has_shipper() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void UniversalTransferDocumentSellerTitleInfo::clear_shipper() {
  if (shipper_ != NULL) shipper_->::Diadoc::Api::Proto::Invoicing::Shipper::Clear();
  clear_has_shipper();
}
inline const ::Diadoc::Api::Proto::Invoicing::Shipper& UniversalTransferDocumentSellerTitleInfo::shipper() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.UniversalTransferDocumentSellerTitleInfo.Shipper)
  return shipper_ != NULL ? *shipper_ : *default_instance_->shipper_;
}
inline ::Diadoc::Api::Proto::Invoicing::Shipper* UniversalTransferDocumentSellerTitleInfo::mutable_shipper() {
  set_has_shipper();
  if (shipper_ == NULL) shipper_ = new ::Diadoc::Api::Proto::Invoicing::Shipper;
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.UniversalTransferDocumentSellerTitleInfo.Shipper)
  return shipper_;
}
inline ::Diadoc::Api::Proto::Invoicing::Shipper* UniversalTransferDocumentSellerTitleInfo::release_shipper() {
  clear_has_shipper();
  ::Diadoc::Api::Proto::Invoicing::Shipper* temp = shipper_;
  shipper_ = NULL;
  return temp;
}
inline void UniversalTransferDocumentSellerTitleInfo::set_allocated_shipper(::Diadoc::Api::Proto::Invoicing::Shipper* shipper) {
  delete shipper_;
  shipper_ = shipper;
  if (shipper) {
    set_has_shipper();
  } else {
    clear_has_shipper();
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.UniversalTransferDocumentSellerTitleInfo.Shipper)
}

// optional .Diadoc.Api.Proto.Invoicing.Organizations.ExtendedOrganizationInfo Consignee = 8;
inline bool UniversalTransferDocumentSellerTitleInfo::has_consignee() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void UniversalTransferDocumentSellerTitleInfo::set_has_consignee() {
  _has_bits_[0] |= 0x00000080u;
}
inline void UniversalTransferDocumentSellerTitleInfo::clear_has_consignee() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void UniversalTransferDocumentSellerTitleInfo::clear_consignee() {
  if (consignee_ != NULL) consignee_->::Diadoc::Api::Proto::Invoicing::Organizations::ExtendedOrganizationInfo::Clear();
  clear_has_consignee();
}
inline const ::Diadoc::Api::Proto::Invoicing::Organizations::ExtendedOrganizationInfo& UniversalTransferDocumentSellerTitleInfo::consignee() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.UniversalTransferDocumentSellerTitleInfo.Consignee)
  return consignee_ != NULL ? *consignee_ : *default_instance_->consignee_;
}
inline ::Diadoc::Api::Proto::Invoicing::Organizations::ExtendedOrganizationInfo* UniversalTransferDocumentSellerTitleInfo::mutable_consignee() {
  set_has_consignee();
  if (consignee_ == NULL) consignee_ = new ::Diadoc::Api::Proto::Invoicing::Organizations::ExtendedOrganizationInfo;
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.UniversalTransferDocumentSellerTitleInfo.Consignee)
  return consignee_;
}
inline ::Diadoc::Api::Proto::Invoicing::Organizations::ExtendedOrganizationInfo* UniversalTransferDocumentSellerTitleInfo::release_consignee() {
  clear_has_consignee();
  ::Diadoc::Api::Proto::Invoicing::Organizations::ExtendedOrganizationInfo* temp = consignee_;
  consignee_ = NULL;
  return temp;
}
inline void UniversalTransferDocumentSellerTitleInfo::set_allocated_consignee(::Diadoc::Api::Proto::Invoicing::Organizations::ExtendedOrganizationInfo* consignee) {
  delete consignee_;
  consignee_ = consignee;
  if (consignee) {
    set_has_consignee();
  } else {
    clear_has_consignee();
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.UniversalTransferDocumentSellerTitleInfo.Consignee)
}

// repeated .Diadoc.Api.Proto.Invoicing.Signers.ExtendedSigner Signers = 9;
inline int UniversalTransferDocumentSellerTitleInfo::signers_size() const {
  return signers_.size();
}
inline void UniversalTransferDocumentSellerTitleInfo::clear_signers() {
  signers_.Clear();
}
inline const ::Diadoc::Api::Proto::Invoicing::Signers::ExtendedSigner& UniversalTransferDocumentSellerTitleInfo::signers(int index) const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.UniversalTransferDocumentSellerTitleInfo.Signers)
  return signers_.Get(index);
}
inline ::Diadoc::Api::Proto::Invoicing::Signers::ExtendedSigner* UniversalTransferDocumentSellerTitleInfo::mutable_signers(int index) {
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.UniversalTransferDocumentSellerTitleInfo.Signers)
  return signers_.Mutable(index);
}
inline ::Diadoc::Api::Proto::Invoicing::Signers::ExtendedSigner* UniversalTransferDocumentSellerTitleInfo::add_signers() {
  // @@protoc_insertion_point(field_add:Diadoc.Api.Proto.Invoicing.UniversalTransferDocumentSellerTitleInfo.Signers)
  return signers_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::Signers::ExtendedSigner >&
UniversalTransferDocumentSellerTitleInfo::signers() const {
  // @@protoc_insertion_point(field_list:Diadoc.Api.Proto.Invoicing.UniversalTransferDocumentSellerTitleInfo.Signers)
  return signers_;
}
inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::Signers::ExtendedSigner >*
UniversalTransferDocumentSellerTitleInfo::mutable_signers() {
  // @@protoc_insertion_point(field_mutable_list:Diadoc.Api.Proto.Invoicing.UniversalTransferDocumentSellerTitleInfo.Signers)
  return &signers_;
}

// repeated .Diadoc.Api.Proto.Invoicing.PaymentDocumentInfo PaymentDocuments = 10;
inline int UniversalTransferDocumentSellerTitleInfo::paymentdocuments_size() const {
  return paymentdocuments_.size();
}
inline void UniversalTransferDocumentSellerTitleInfo::clear_paymentdocuments() {
  paymentdocuments_.Clear();
}
inline const ::Diadoc::Api::Proto::Invoicing::PaymentDocumentInfo& UniversalTransferDocumentSellerTitleInfo::paymentdocuments(int index) const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.UniversalTransferDocumentSellerTitleInfo.PaymentDocuments)
  return paymentdocuments_.Get(index);
}
inline ::Diadoc::Api::Proto::Invoicing::PaymentDocumentInfo* UniversalTransferDocumentSellerTitleInfo::mutable_paymentdocuments(int index) {
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.UniversalTransferDocumentSellerTitleInfo.PaymentDocuments)
  return paymentdocuments_.Mutable(index);
}
inline ::Diadoc::Api::Proto::Invoicing::PaymentDocumentInfo* UniversalTransferDocumentSellerTitleInfo::add_paymentdocuments() {
  // @@protoc_insertion_point(field_add:Diadoc.Api.Proto.Invoicing.UniversalTransferDocumentSellerTitleInfo.PaymentDocuments)
  return paymentdocuments_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::PaymentDocumentInfo >&
UniversalTransferDocumentSellerTitleInfo::paymentdocuments() const {
  // @@protoc_insertion_point(field_list:Diadoc.Api.Proto.Invoicing.UniversalTransferDocumentSellerTitleInfo.PaymentDocuments)
  return paymentdocuments_;
}
inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::PaymentDocumentInfo >*
UniversalTransferDocumentSellerTitleInfo::mutable_paymentdocuments() {
  // @@protoc_insertion_point(field_mutable_list:Diadoc.Api.Proto.Invoicing.UniversalTransferDocumentSellerTitleInfo.PaymentDocuments)
  return &paymentdocuments_;
}

// optional .Diadoc.Api.Proto.Invoicing.InvoiceTable InvoiceTable = 11;
inline bool UniversalTransferDocumentSellerTitleInfo::has_invoicetable() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void UniversalTransferDocumentSellerTitleInfo::set_has_invoicetable() {
  _has_bits_[0] |= 0x00000400u;
}
inline void UniversalTransferDocumentSellerTitleInfo::clear_has_invoicetable() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void UniversalTransferDocumentSellerTitleInfo::clear_invoicetable() {
  if (invoicetable_ != NULL) invoicetable_->::Diadoc::Api::Proto::Invoicing::InvoiceTable::Clear();
  clear_has_invoicetable();
}
inline const ::Diadoc::Api::Proto::Invoicing::InvoiceTable& UniversalTransferDocumentSellerTitleInfo::invoicetable() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.UniversalTransferDocumentSellerTitleInfo.InvoiceTable)
  return invoicetable_ != NULL ? *invoicetable_ : *default_instance_->invoicetable_;
}
inline ::Diadoc::Api::Proto::Invoicing::InvoiceTable* UniversalTransferDocumentSellerTitleInfo::mutable_invoicetable() {
  set_has_invoicetable();
  if (invoicetable_ == NULL) invoicetable_ = new ::Diadoc::Api::Proto::Invoicing::InvoiceTable;
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.UniversalTransferDocumentSellerTitleInfo.InvoiceTable)
  return invoicetable_;
}
inline ::Diadoc::Api::Proto::Invoicing::InvoiceTable* UniversalTransferDocumentSellerTitleInfo::release_invoicetable() {
  clear_has_invoicetable();
  ::Diadoc::Api::Proto::Invoicing::InvoiceTable* temp = invoicetable_;
  invoicetable_ = NULL;
  return temp;
}
inline void UniversalTransferDocumentSellerTitleInfo::set_allocated_invoicetable(::Diadoc::Api::Proto::Invoicing::InvoiceTable* invoicetable) {
  delete invoicetable_;
  invoicetable_ = invoicetable;
  if (invoicetable) {
    set_has_invoicetable();
  } else {
    clear_has_invoicetable();
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.UniversalTransferDocumentSellerTitleInfo.InvoiceTable)
}

// required string Currency = 12;
inline bool UniversalTransferDocumentSellerTitleInfo::has_currency() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void UniversalTransferDocumentSellerTitleInfo::set_has_currency() {
  _has_bits_[0] |= 0x00000800u;
}
inline void UniversalTransferDocumentSellerTitleInfo::clear_has_currency() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void UniversalTransferDocumentSellerTitleInfo::clear_currency() {
  if (currency_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    currency_->clear();
  }
  clear_has_currency();
}
inline const ::std::string& UniversalTransferDocumentSellerTitleInfo::currency() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.UniversalTransferDocumentSellerTitleInfo.Currency)
  return *currency_;
}
inline void UniversalTransferDocumentSellerTitleInfo::set_currency(const ::std::string& value) {
  set_has_currency();
  if (currency_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    currency_ = new ::std::string;
  }
  currency_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.UniversalTransferDocumentSellerTitleInfo.Currency)
}
inline void UniversalTransferDocumentSellerTitleInfo::set_currency(const char* value) {
  set_has_currency();
  if (currency_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    currency_ = new ::std::string;
  }
  currency_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.UniversalTransferDocumentSellerTitleInfo.Currency)
}
inline void UniversalTransferDocumentSellerTitleInfo::set_currency(const char* value, size_t size) {
  set_has_currency();
  if (currency_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    currency_ = new ::std::string;
  }
  currency_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.UniversalTransferDocumentSellerTitleInfo.Currency)
}
inline ::std::string* UniversalTransferDocumentSellerTitleInfo::mutable_currency() {
  set_has_currency();
  if (currency_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    currency_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.UniversalTransferDocumentSellerTitleInfo.Currency)
  return currency_;
}
inline ::std::string* UniversalTransferDocumentSellerTitleInfo::release_currency() {
  clear_has_currency();
  if (currency_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = currency_;
    currency_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UniversalTransferDocumentSellerTitleInfo::set_allocated_currency(::std::string* currency) {
  if (currency_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete currency_;
  }
  if (currency) {
    set_has_currency();
    currency_ = currency;
  } else {
    clear_has_currency();
    currency_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.UniversalTransferDocumentSellerTitleInfo.Currency)
}

// optional string CurrencyRate = 13;
inline bool UniversalTransferDocumentSellerTitleInfo::has_currencyrate() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void UniversalTransferDocumentSellerTitleInfo::set_has_currencyrate() {
  _has_bits_[0] |= 0x00001000u;
}
inline void UniversalTransferDocumentSellerTitleInfo::clear_has_currencyrate() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void UniversalTransferDocumentSellerTitleInfo::clear_currencyrate() {
  if (currencyrate_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    currencyrate_->clear();
  }
  clear_has_currencyrate();
}
inline const ::std::string& UniversalTransferDocumentSellerTitleInfo::currencyrate() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.UniversalTransferDocumentSellerTitleInfo.CurrencyRate)
  return *currencyrate_;
}
inline void UniversalTransferDocumentSellerTitleInfo::set_currencyrate(const ::std::string& value) {
  set_has_currencyrate();
  if (currencyrate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    currencyrate_ = new ::std::string;
  }
  currencyrate_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.UniversalTransferDocumentSellerTitleInfo.CurrencyRate)
}
inline void UniversalTransferDocumentSellerTitleInfo::set_currencyrate(const char* value) {
  set_has_currencyrate();
  if (currencyrate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    currencyrate_ = new ::std::string;
  }
  currencyrate_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.UniversalTransferDocumentSellerTitleInfo.CurrencyRate)
}
inline void UniversalTransferDocumentSellerTitleInfo::set_currencyrate(const char* value, size_t size) {
  set_has_currencyrate();
  if (currencyrate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    currencyrate_ = new ::std::string;
  }
  currencyrate_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.UniversalTransferDocumentSellerTitleInfo.CurrencyRate)
}
inline ::std::string* UniversalTransferDocumentSellerTitleInfo::mutable_currencyrate() {
  set_has_currencyrate();
  if (currencyrate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    currencyrate_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.UniversalTransferDocumentSellerTitleInfo.CurrencyRate)
  return currencyrate_;
}
inline ::std::string* UniversalTransferDocumentSellerTitleInfo::release_currencyrate() {
  clear_has_currencyrate();
  if (currencyrate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = currencyrate_;
    currencyrate_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UniversalTransferDocumentSellerTitleInfo::set_allocated_currencyrate(::std::string* currencyrate) {
  if (currencyrate_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete currencyrate_;
  }
  if (currencyrate) {
    set_has_currencyrate();
    currencyrate_ = currencyrate;
  } else {
    clear_has_currencyrate();
    currencyrate_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.UniversalTransferDocumentSellerTitleInfo.CurrencyRate)
}

// optional string RevisionDate = 14;
inline bool UniversalTransferDocumentSellerTitleInfo::has_revisiondate() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void UniversalTransferDocumentSellerTitleInfo::set_has_revisiondate() {
  _has_bits_[0] |= 0x00002000u;
}
inline void UniversalTransferDocumentSellerTitleInfo::clear_has_revisiondate() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void UniversalTransferDocumentSellerTitleInfo::clear_revisiondate() {
  if (revisiondate_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    revisiondate_->clear();
  }
  clear_has_revisiondate();
}
inline const ::std::string& UniversalTransferDocumentSellerTitleInfo::revisiondate() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.UniversalTransferDocumentSellerTitleInfo.RevisionDate)
  return *revisiondate_;
}
inline void UniversalTransferDocumentSellerTitleInfo::set_revisiondate(const ::std::string& value) {
  set_has_revisiondate();
  if (revisiondate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    revisiondate_ = new ::std::string;
  }
  revisiondate_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.UniversalTransferDocumentSellerTitleInfo.RevisionDate)
}
inline void UniversalTransferDocumentSellerTitleInfo::set_revisiondate(const char* value) {
  set_has_revisiondate();
  if (revisiondate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    revisiondate_ = new ::std::string;
  }
  revisiondate_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.UniversalTransferDocumentSellerTitleInfo.RevisionDate)
}
inline void UniversalTransferDocumentSellerTitleInfo::set_revisiondate(const char* value, size_t size) {
  set_has_revisiondate();
  if (revisiondate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    revisiondate_ = new ::std::string;
  }
  revisiondate_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.UniversalTransferDocumentSellerTitleInfo.RevisionDate)
}
inline ::std::string* UniversalTransferDocumentSellerTitleInfo::mutable_revisiondate() {
  set_has_revisiondate();
  if (revisiondate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    revisiondate_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.UniversalTransferDocumentSellerTitleInfo.RevisionDate)
  return revisiondate_;
}
inline ::std::string* UniversalTransferDocumentSellerTitleInfo::release_revisiondate() {
  clear_has_revisiondate();
  if (revisiondate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = revisiondate_;
    revisiondate_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UniversalTransferDocumentSellerTitleInfo::set_allocated_revisiondate(::std::string* revisiondate) {
  if (revisiondate_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete revisiondate_;
  }
  if (revisiondate) {
    set_has_revisiondate();
    revisiondate_ = revisiondate;
  } else {
    clear_has_revisiondate();
    revisiondate_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.UniversalTransferDocumentSellerTitleInfo.RevisionDate)
}

// optional string RevisionNumber = 15;
inline bool UniversalTransferDocumentSellerTitleInfo::has_revisionnumber() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void UniversalTransferDocumentSellerTitleInfo::set_has_revisionnumber() {
  _has_bits_[0] |= 0x00004000u;
}
inline void UniversalTransferDocumentSellerTitleInfo::clear_has_revisionnumber() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void UniversalTransferDocumentSellerTitleInfo::clear_revisionnumber() {
  if (revisionnumber_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    revisionnumber_->clear();
  }
  clear_has_revisionnumber();
}
inline const ::std::string& UniversalTransferDocumentSellerTitleInfo::revisionnumber() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.UniversalTransferDocumentSellerTitleInfo.RevisionNumber)
  return *revisionnumber_;
}
inline void UniversalTransferDocumentSellerTitleInfo::set_revisionnumber(const ::std::string& value) {
  set_has_revisionnumber();
  if (revisionnumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    revisionnumber_ = new ::std::string;
  }
  revisionnumber_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.UniversalTransferDocumentSellerTitleInfo.RevisionNumber)
}
inline void UniversalTransferDocumentSellerTitleInfo::set_revisionnumber(const char* value) {
  set_has_revisionnumber();
  if (revisionnumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    revisionnumber_ = new ::std::string;
  }
  revisionnumber_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.UniversalTransferDocumentSellerTitleInfo.RevisionNumber)
}
inline void UniversalTransferDocumentSellerTitleInfo::set_revisionnumber(const char* value, size_t size) {
  set_has_revisionnumber();
  if (revisionnumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    revisionnumber_ = new ::std::string;
  }
  revisionnumber_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.UniversalTransferDocumentSellerTitleInfo.RevisionNumber)
}
inline ::std::string* UniversalTransferDocumentSellerTitleInfo::mutable_revisionnumber() {
  set_has_revisionnumber();
  if (revisionnumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    revisionnumber_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.UniversalTransferDocumentSellerTitleInfo.RevisionNumber)
  return revisionnumber_;
}
inline ::std::string* UniversalTransferDocumentSellerTitleInfo::release_revisionnumber() {
  clear_has_revisionnumber();
  if (revisionnumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = revisionnumber_;
    revisionnumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UniversalTransferDocumentSellerTitleInfo::set_allocated_revisionnumber(::std::string* revisionnumber) {
  if (revisionnumber_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete revisionnumber_;
  }
  if (revisionnumber) {
    set_has_revisionnumber();
    revisionnumber_ = revisionnumber;
  } else {
    clear_has_revisionnumber();
    revisionnumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.UniversalTransferDocumentSellerTitleInfo.RevisionNumber)
}

// optional .Diadoc.Api.Proto.Invoicing.AdditionalInfoId AdditionalInfoId = 16;
inline bool UniversalTransferDocumentSellerTitleInfo::has_additionalinfoid() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void UniversalTransferDocumentSellerTitleInfo::set_has_additionalinfoid() {
  _has_bits_[0] |= 0x00008000u;
}
inline void UniversalTransferDocumentSellerTitleInfo::clear_has_additionalinfoid() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void UniversalTransferDocumentSellerTitleInfo::clear_additionalinfoid() {
  if (additionalinfoid_ != NULL) additionalinfoid_->::Diadoc::Api::Proto::Invoicing::AdditionalInfoId::Clear();
  clear_has_additionalinfoid();
}
inline const ::Diadoc::Api::Proto::Invoicing::AdditionalInfoId& UniversalTransferDocumentSellerTitleInfo::additionalinfoid() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.UniversalTransferDocumentSellerTitleInfo.AdditionalInfoId)
  return additionalinfoid_ != NULL ? *additionalinfoid_ : *default_instance_->additionalinfoid_;
}
inline ::Diadoc::Api::Proto::Invoicing::AdditionalInfoId* UniversalTransferDocumentSellerTitleInfo::mutable_additionalinfoid() {
  set_has_additionalinfoid();
  if (additionalinfoid_ == NULL) additionalinfoid_ = new ::Diadoc::Api::Proto::Invoicing::AdditionalInfoId;
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.UniversalTransferDocumentSellerTitleInfo.AdditionalInfoId)
  return additionalinfoid_;
}
inline ::Diadoc::Api::Proto::Invoicing::AdditionalInfoId* UniversalTransferDocumentSellerTitleInfo::release_additionalinfoid() {
  clear_has_additionalinfoid();
  ::Diadoc::Api::Proto::Invoicing::AdditionalInfoId* temp = additionalinfoid_;
  additionalinfoid_ = NULL;
  return temp;
}
inline void UniversalTransferDocumentSellerTitleInfo::set_allocated_additionalinfoid(::Diadoc::Api::Proto::Invoicing::AdditionalInfoId* additionalinfoid) {
  delete additionalinfoid_;
  additionalinfoid_ = additionalinfoid;
  if (additionalinfoid) {
    set_has_additionalinfoid();
  } else {
    clear_has_additionalinfoid();
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.UniversalTransferDocumentSellerTitleInfo.AdditionalInfoId)
}

// optional .Diadoc.Api.Proto.Invoicing.TransferInfo TransferInfo = 17;
inline bool UniversalTransferDocumentSellerTitleInfo::has_transferinfo() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void UniversalTransferDocumentSellerTitleInfo::set_has_transferinfo() {
  _has_bits_[0] |= 0x00010000u;
}
inline void UniversalTransferDocumentSellerTitleInfo::clear_has_transferinfo() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void UniversalTransferDocumentSellerTitleInfo::clear_transferinfo() {
  if (transferinfo_ != NULL) transferinfo_->::Diadoc::Api::Proto::Invoicing::TransferInfo::Clear();
  clear_has_transferinfo();
}
inline const ::Diadoc::Api::Proto::Invoicing::TransferInfo& UniversalTransferDocumentSellerTitleInfo::transferinfo() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.UniversalTransferDocumentSellerTitleInfo.TransferInfo)
  return transferinfo_ != NULL ? *transferinfo_ : *default_instance_->transferinfo_;
}
inline ::Diadoc::Api::Proto::Invoicing::TransferInfo* UniversalTransferDocumentSellerTitleInfo::mutable_transferinfo() {
  set_has_transferinfo();
  if (transferinfo_ == NULL) transferinfo_ = new ::Diadoc::Api::Proto::Invoicing::TransferInfo;
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.UniversalTransferDocumentSellerTitleInfo.TransferInfo)
  return transferinfo_;
}
inline ::Diadoc::Api::Proto::Invoicing::TransferInfo* UniversalTransferDocumentSellerTitleInfo::release_transferinfo() {
  clear_has_transferinfo();
  ::Diadoc::Api::Proto::Invoicing::TransferInfo* temp = transferinfo_;
  transferinfo_ = NULL;
  return temp;
}
inline void UniversalTransferDocumentSellerTitleInfo::set_allocated_transferinfo(::Diadoc::Api::Proto::Invoicing::TransferInfo* transferinfo) {
  delete transferinfo_;
  transferinfo_ = transferinfo;
  if (transferinfo) {
    set_has_transferinfo();
  } else {
    clear_has_transferinfo();
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.UniversalTransferDocumentSellerTitleInfo.TransferInfo)
}

// required string DocumentCreator = 18;
inline bool UniversalTransferDocumentSellerTitleInfo::has_documentcreator() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void UniversalTransferDocumentSellerTitleInfo::set_has_documentcreator() {
  _has_bits_[0] |= 0x00020000u;
}
inline void UniversalTransferDocumentSellerTitleInfo::clear_has_documentcreator() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void UniversalTransferDocumentSellerTitleInfo::clear_documentcreator() {
  if (documentcreator_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    documentcreator_->clear();
  }
  clear_has_documentcreator();
}
inline const ::std::string& UniversalTransferDocumentSellerTitleInfo::documentcreator() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.UniversalTransferDocumentSellerTitleInfo.DocumentCreator)
  return *documentcreator_;
}
inline void UniversalTransferDocumentSellerTitleInfo::set_documentcreator(const ::std::string& value) {
  set_has_documentcreator();
  if (documentcreator_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    documentcreator_ = new ::std::string;
  }
  documentcreator_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.UniversalTransferDocumentSellerTitleInfo.DocumentCreator)
}
inline void UniversalTransferDocumentSellerTitleInfo::set_documentcreator(const char* value) {
  set_has_documentcreator();
  if (documentcreator_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    documentcreator_ = new ::std::string;
  }
  documentcreator_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.UniversalTransferDocumentSellerTitleInfo.DocumentCreator)
}
inline void UniversalTransferDocumentSellerTitleInfo::set_documentcreator(const char* value, size_t size) {
  set_has_documentcreator();
  if (documentcreator_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    documentcreator_ = new ::std::string;
  }
  documentcreator_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.UniversalTransferDocumentSellerTitleInfo.DocumentCreator)
}
inline ::std::string* UniversalTransferDocumentSellerTitleInfo::mutable_documentcreator() {
  set_has_documentcreator();
  if (documentcreator_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    documentcreator_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.UniversalTransferDocumentSellerTitleInfo.DocumentCreator)
  return documentcreator_;
}
inline ::std::string* UniversalTransferDocumentSellerTitleInfo::release_documentcreator() {
  clear_has_documentcreator();
  if (documentcreator_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = documentcreator_;
    documentcreator_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UniversalTransferDocumentSellerTitleInfo::set_allocated_documentcreator(::std::string* documentcreator) {
  if (documentcreator_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete documentcreator_;
  }
  if (documentcreator) {
    set_has_documentcreator();
    documentcreator_ = documentcreator;
  } else {
    clear_has_documentcreator();
    documentcreator_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.UniversalTransferDocumentSellerTitleInfo.DocumentCreator)
}

// optional string DocumentCreatorBase = 19;
inline bool UniversalTransferDocumentSellerTitleInfo::has_documentcreatorbase() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void UniversalTransferDocumentSellerTitleInfo::set_has_documentcreatorbase() {
  _has_bits_[0] |= 0x00040000u;
}
inline void UniversalTransferDocumentSellerTitleInfo::clear_has_documentcreatorbase() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void UniversalTransferDocumentSellerTitleInfo::clear_documentcreatorbase() {
  if (documentcreatorbase_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    documentcreatorbase_->clear();
  }
  clear_has_documentcreatorbase();
}
inline const ::std::string& UniversalTransferDocumentSellerTitleInfo::documentcreatorbase() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.UniversalTransferDocumentSellerTitleInfo.DocumentCreatorBase)
  return *documentcreatorbase_;
}
inline void UniversalTransferDocumentSellerTitleInfo::set_documentcreatorbase(const ::std::string& value) {
  set_has_documentcreatorbase();
  if (documentcreatorbase_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    documentcreatorbase_ = new ::std::string;
  }
  documentcreatorbase_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.UniversalTransferDocumentSellerTitleInfo.DocumentCreatorBase)
}
inline void UniversalTransferDocumentSellerTitleInfo::set_documentcreatorbase(const char* value) {
  set_has_documentcreatorbase();
  if (documentcreatorbase_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    documentcreatorbase_ = new ::std::string;
  }
  documentcreatorbase_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.UniversalTransferDocumentSellerTitleInfo.DocumentCreatorBase)
}
inline void UniversalTransferDocumentSellerTitleInfo::set_documentcreatorbase(const char* value, size_t size) {
  set_has_documentcreatorbase();
  if (documentcreatorbase_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    documentcreatorbase_ = new ::std::string;
  }
  documentcreatorbase_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.UniversalTransferDocumentSellerTitleInfo.DocumentCreatorBase)
}
inline ::std::string* UniversalTransferDocumentSellerTitleInfo::mutable_documentcreatorbase() {
  set_has_documentcreatorbase();
  if (documentcreatorbase_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    documentcreatorbase_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.UniversalTransferDocumentSellerTitleInfo.DocumentCreatorBase)
  return documentcreatorbase_;
}
inline ::std::string* UniversalTransferDocumentSellerTitleInfo::release_documentcreatorbase() {
  clear_has_documentcreatorbase();
  if (documentcreatorbase_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = documentcreatorbase_;
    documentcreatorbase_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UniversalTransferDocumentSellerTitleInfo::set_allocated_documentcreatorbase(::std::string* documentcreatorbase) {
  if (documentcreatorbase_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete documentcreatorbase_;
  }
  if (documentcreatorbase) {
    set_has_documentcreatorbase();
    documentcreatorbase_ = documentcreatorbase;
  } else {
    clear_has_documentcreatorbase();
    documentcreatorbase_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.UniversalTransferDocumentSellerTitleInfo.DocumentCreatorBase)
}

// optional string GovernmentContractInfo = 20;
inline bool UniversalTransferDocumentSellerTitleInfo::has_governmentcontractinfo() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void UniversalTransferDocumentSellerTitleInfo::set_has_governmentcontractinfo() {
  _has_bits_[0] |= 0x00080000u;
}
inline void UniversalTransferDocumentSellerTitleInfo::clear_has_governmentcontractinfo() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void UniversalTransferDocumentSellerTitleInfo::clear_governmentcontractinfo() {
  if (governmentcontractinfo_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    governmentcontractinfo_->clear();
  }
  clear_has_governmentcontractinfo();
}
inline const ::std::string& UniversalTransferDocumentSellerTitleInfo::governmentcontractinfo() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.UniversalTransferDocumentSellerTitleInfo.GovernmentContractInfo)
  return *governmentcontractinfo_;
}
inline void UniversalTransferDocumentSellerTitleInfo::set_governmentcontractinfo(const ::std::string& value) {
  set_has_governmentcontractinfo();
  if (governmentcontractinfo_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    governmentcontractinfo_ = new ::std::string;
  }
  governmentcontractinfo_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.UniversalTransferDocumentSellerTitleInfo.GovernmentContractInfo)
}
inline void UniversalTransferDocumentSellerTitleInfo::set_governmentcontractinfo(const char* value) {
  set_has_governmentcontractinfo();
  if (governmentcontractinfo_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    governmentcontractinfo_ = new ::std::string;
  }
  governmentcontractinfo_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.UniversalTransferDocumentSellerTitleInfo.GovernmentContractInfo)
}
inline void UniversalTransferDocumentSellerTitleInfo::set_governmentcontractinfo(const char* value, size_t size) {
  set_has_governmentcontractinfo();
  if (governmentcontractinfo_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    governmentcontractinfo_ = new ::std::string;
  }
  governmentcontractinfo_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.UniversalTransferDocumentSellerTitleInfo.GovernmentContractInfo)
}
inline ::std::string* UniversalTransferDocumentSellerTitleInfo::mutable_governmentcontractinfo() {
  set_has_governmentcontractinfo();
  if (governmentcontractinfo_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    governmentcontractinfo_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.UniversalTransferDocumentSellerTitleInfo.GovernmentContractInfo)
  return governmentcontractinfo_;
}
inline ::std::string* UniversalTransferDocumentSellerTitleInfo::release_governmentcontractinfo() {
  clear_has_governmentcontractinfo();
  if (governmentcontractinfo_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = governmentcontractinfo_;
    governmentcontractinfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UniversalTransferDocumentSellerTitleInfo::set_allocated_governmentcontractinfo(::std::string* governmentcontractinfo) {
  if (governmentcontractinfo_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete governmentcontractinfo_;
  }
  if (governmentcontractinfo) {
    set_has_governmentcontractinfo();
    governmentcontractinfo_ = governmentcontractinfo;
  } else {
    clear_has_governmentcontractinfo();
    governmentcontractinfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.UniversalTransferDocumentSellerTitleInfo.GovernmentContractInfo)
}

// -------------------------------------------------------------------

// Shipper

// optional bool SameAsSeller = 1;
inline bool Shipper::has_sameasseller() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Shipper::set_has_sameasseller() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Shipper::clear_has_sameasseller() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Shipper::clear_sameasseller() {
  sameasseller_ = false;
  clear_has_sameasseller();
}
inline bool Shipper::sameasseller() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.Shipper.SameAsSeller)
  return sameasseller_;
}
inline void Shipper::set_sameasseller(bool value) {
  set_has_sameasseller();
  sameasseller_ = value;
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.Shipper.SameAsSeller)
}

// optional .Diadoc.Api.Proto.Invoicing.Organizations.ExtendedOrganizationInfo OrgInfo = 2;
inline bool Shipper::has_orginfo() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Shipper::set_has_orginfo() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Shipper::clear_has_orginfo() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Shipper::clear_orginfo() {
  if (orginfo_ != NULL) orginfo_->::Diadoc::Api::Proto::Invoicing::Organizations::ExtendedOrganizationInfo::Clear();
  clear_has_orginfo();
}
inline const ::Diadoc::Api::Proto::Invoicing::Organizations::ExtendedOrganizationInfo& Shipper::orginfo() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.Shipper.OrgInfo)
  return orginfo_ != NULL ? *orginfo_ : *default_instance_->orginfo_;
}
inline ::Diadoc::Api::Proto::Invoicing::Organizations::ExtendedOrganizationInfo* Shipper::mutable_orginfo() {
  set_has_orginfo();
  if (orginfo_ == NULL) orginfo_ = new ::Diadoc::Api::Proto::Invoicing::Organizations::ExtendedOrganizationInfo;
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.Shipper.OrgInfo)
  return orginfo_;
}
inline ::Diadoc::Api::Proto::Invoicing::Organizations::ExtendedOrganizationInfo* Shipper::release_orginfo() {
  clear_has_orginfo();
  ::Diadoc::Api::Proto::Invoicing::Organizations::ExtendedOrganizationInfo* temp = orginfo_;
  orginfo_ = NULL;
  return temp;
}
inline void Shipper::set_allocated_orginfo(::Diadoc::Api::Proto::Invoicing::Organizations::ExtendedOrganizationInfo* orginfo) {
  delete orginfo_;
  orginfo_ = orginfo;
  if (orginfo) {
    set_has_orginfo();
  } else {
    clear_has_orginfo();
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.Shipper.OrgInfo)
}

// -------------------------------------------------------------------

// InvoiceTable

// repeated .Diadoc.Api.Proto.Invoicing.ExtendedInvoiceItem Items = 1;
inline int InvoiceTable::items_size() const {
  return items_.size();
}
inline void InvoiceTable::clear_items() {
  items_.Clear();
}
inline const ::Diadoc::Api::Proto::Invoicing::ExtendedInvoiceItem& InvoiceTable::items(int index) const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.InvoiceTable.Items)
  return items_.Get(index);
}
inline ::Diadoc::Api::Proto::Invoicing::ExtendedInvoiceItem* InvoiceTable::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.InvoiceTable.Items)
  return items_.Mutable(index);
}
inline ::Diadoc::Api::Proto::Invoicing::ExtendedInvoiceItem* InvoiceTable::add_items() {
  // @@protoc_insertion_point(field_add:Diadoc.Api.Proto.Invoicing.InvoiceTable.Items)
  return items_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::ExtendedInvoiceItem >&
InvoiceTable::items() const {
  // @@protoc_insertion_point(field_list:Diadoc.Api.Proto.Invoicing.InvoiceTable.Items)
  return items_;
}
inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::ExtendedInvoiceItem >*
InvoiceTable::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:Diadoc.Api.Proto.Invoicing.InvoiceTable.Items)
  return &items_;
}

// optional string TotalWithVatExcluded = 2;
inline bool InvoiceTable::has_totalwithvatexcluded() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InvoiceTable::set_has_totalwithvatexcluded() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InvoiceTable::clear_has_totalwithvatexcluded() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InvoiceTable::clear_totalwithvatexcluded() {
  if (totalwithvatexcluded_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    totalwithvatexcluded_->clear();
  }
  clear_has_totalwithvatexcluded();
}
inline const ::std::string& InvoiceTable::totalwithvatexcluded() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.InvoiceTable.TotalWithVatExcluded)
  return *totalwithvatexcluded_;
}
inline void InvoiceTable::set_totalwithvatexcluded(const ::std::string& value) {
  set_has_totalwithvatexcluded();
  if (totalwithvatexcluded_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    totalwithvatexcluded_ = new ::std::string;
  }
  totalwithvatexcluded_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.InvoiceTable.TotalWithVatExcluded)
}
inline void InvoiceTable::set_totalwithvatexcluded(const char* value) {
  set_has_totalwithvatexcluded();
  if (totalwithvatexcluded_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    totalwithvatexcluded_ = new ::std::string;
  }
  totalwithvatexcluded_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.InvoiceTable.TotalWithVatExcluded)
}
inline void InvoiceTable::set_totalwithvatexcluded(const char* value, size_t size) {
  set_has_totalwithvatexcluded();
  if (totalwithvatexcluded_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    totalwithvatexcluded_ = new ::std::string;
  }
  totalwithvatexcluded_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.InvoiceTable.TotalWithVatExcluded)
}
inline ::std::string* InvoiceTable::mutable_totalwithvatexcluded() {
  set_has_totalwithvatexcluded();
  if (totalwithvatexcluded_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    totalwithvatexcluded_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.InvoiceTable.TotalWithVatExcluded)
  return totalwithvatexcluded_;
}
inline ::std::string* InvoiceTable::release_totalwithvatexcluded() {
  clear_has_totalwithvatexcluded();
  if (totalwithvatexcluded_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = totalwithvatexcluded_;
    totalwithvatexcluded_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void InvoiceTable::set_allocated_totalwithvatexcluded(::std::string* totalwithvatexcluded) {
  if (totalwithvatexcluded_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete totalwithvatexcluded_;
  }
  if (totalwithvatexcluded) {
    set_has_totalwithvatexcluded();
    totalwithvatexcluded_ = totalwithvatexcluded;
  } else {
    clear_has_totalwithvatexcluded();
    totalwithvatexcluded_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.InvoiceTable.TotalWithVatExcluded)
}

// required string Vat = 3;
inline bool InvoiceTable::has_vat() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InvoiceTable::set_has_vat() {
  _has_bits_[0] |= 0x00000004u;
}
inline void InvoiceTable::clear_has_vat() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void InvoiceTable::clear_vat() {
  if (vat_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vat_->clear();
  }
  clear_has_vat();
}
inline const ::std::string& InvoiceTable::vat() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.InvoiceTable.Vat)
  return *vat_;
}
inline void InvoiceTable::set_vat(const ::std::string& value) {
  set_has_vat();
  if (vat_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vat_ = new ::std::string;
  }
  vat_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.InvoiceTable.Vat)
}
inline void InvoiceTable::set_vat(const char* value) {
  set_has_vat();
  if (vat_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vat_ = new ::std::string;
  }
  vat_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.InvoiceTable.Vat)
}
inline void InvoiceTable::set_vat(const char* value, size_t size) {
  set_has_vat();
  if (vat_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vat_ = new ::std::string;
  }
  vat_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.InvoiceTable.Vat)
}
inline ::std::string* InvoiceTable::mutable_vat() {
  set_has_vat();
  if (vat_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vat_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.InvoiceTable.Vat)
  return vat_;
}
inline ::std::string* InvoiceTable::release_vat() {
  clear_has_vat();
  if (vat_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = vat_;
    vat_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void InvoiceTable::set_allocated_vat(::std::string* vat) {
  if (vat_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete vat_;
  }
  if (vat) {
    set_has_vat();
    vat_ = vat;
  } else {
    clear_has_vat();
    vat_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.InvoiceTable.Vat)
}

// required string Total = 4;
inline bool InvoiceTable::has_total() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void InvoiceTable::set_has_total() {
  _has_bits_[0] |= 0x00000008u;
}
inline void InvoiceTable::clear_has_total() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void InvoiceTable::clear_total() {
  if (total_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    total_->clear();
  }
  clear_has_total();
}
inline const ::std::string& InvoiceTable::total() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.InvoiceTable.Total)
  return *total_;
}
inline void InvoiceTable::set_total(const ::std::string& value) {
  set_has_total();
  if (total_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    total_ = new ::std::string;
  }
  total_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.InvoiceTable.Total)
}
inline void InvoiceTable::set_total(const char* value) {
  set_has_total();
  if (total_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    total_ = new ::std::string;
  }
  total_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.InvoiceTable.Total)
}
inline void InvoiceTable::set_total(const char* value, size_t size) {
  set_has_total();
  if (total_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    total_ = new ::std::string;
  }
  total_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.InvoiceTable.Total)
}
inline ::std::string* InvoiceTable::mutable_total() {
  set_has_total();
  if (total_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    total_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.InvoiceTable.Total)
  return total_;
}
inline ::std::string* InvoiceTable::release_total() {
  clear_has_total();
  if (total_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = total_;
    total_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void InvoiceTable::set_allocated_total(::std::string* total) {
  if (total_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete total_;
  }
  if (total) {
    set_has_total();
    total_ = total;
  } else {
    clear_has_total();
    total_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.InvoiceTable.Total)
}

// optional string TotalNet = 5;
inline bool InvoiceTable::has_totalnet() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void InvoiceTable::set_has_totalnet() {
  _has_bits_[0] |= 0x00000010u;
}
inline void InvoiceTable::clear_has_totalnet() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void InvoiceTable::clear_totalnet() {
  if (totalnet_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    totalnet_->clear();
  }
  clear_has_totalnet();
}
inline const ::std::string& InvoiceTable::totalnet() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.InvoiceTable.TotalNet)
  return *totalnet_;
}
inline void InvoiceTable::set_totalnet(const ::std::string& value) {
  set_has_totalnet();
  if (totalnet_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    totalnet_ = new ::std::string;
  }
  totalnet_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.InvoiceTable.TotalNet)
}
inline void InvoiceTable::set_totalnet(const char* value) {
  set_has_totalnet();
  if (totalnet_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    totalnet_ = new ::std::string;
  }
  totalnet_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.InvoiceTable.TotalNet)
}
inline void InvoiceTable::set_totalnet(const char* value, size_t size) {
  set_has_totalnet();
  if (totalnet_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    totalnet_ = new ::std::string;
  }
  totalnet_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.InvoiceTable.TotalNet)
}
inline ::std::string* InvoiceTable::mutable_totalnet() {
  set_has_totalnet();
  if (totalnet_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    totalnet_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.InvoiceTable.TotalNet)
  return totalnet_;
}
inline ::std::string* InvoiceTable::release_totalnet() {
  clear_has_totalnet();
  if (totalnet_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = totalnet_;
    totalnet_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void InvoiceTable::set_allocated_totalnet(::std::string* totalnet) {
  if (totalnet_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete totalnet_;
  }
  if (totalnet) {
    set_has_totalnet();
    totalnet_ = totalnet;
  } else {
    clear_has_totalnet();
    totalnet_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.InvoiceTable.TotalNet)
}

// -------------------------------------------------------------------

// ExtendedInvoiceItem

// required string Product = 1;
inline bool ExtendedInvoiceItem::has_product() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ExtendedInvoiceItem::set_has_product() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ExtendedInvoiceItem::clear_has_product() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ExtendedInvoiceItem::clear_product() {
  if (product_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    product_->clear();
  }
  clear_has_product();
}
inline const ::std::string& ExtendedInvoiceItem::product() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.ExtendedInvoiceItem.Product)
  return *product_;
}
inline void ExtendedInvoiceItem::set_product(const ::std::string& value) {
  set_has_product();
  if (product_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    product_ = new ::std::string;
  }
  product_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.ExtendedInvoiceItem.Product)
}
inline void ExtendedInvoiceItem::set_product(const char* value) {
  set_has_product();
  if (product_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    product_ = new ::std::string;
  }
  product_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.ExtendedInvoiceItem.Product)
}
inline void ExtendedInvoiceItem::set_product(const char* value, size_t size) {
  set_has_product();
  if (product_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    product_ = new ::std::string;
  }
  product_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.ExtendedInvoiceItem.Product)
}
inline ::std::string* ExtendedInvoiceItem::mutable_product() {
  set_has_product();
  if (product_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    product_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.ExtendedInvoiceItem.Product)
  return product_;
}
inline ::std::string* ExtendedInvoiceItem::release_product() {
  clear_has_product();
  if (product_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = product_;
    product_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ExtendedInvoiceItem::set_allocated_product(::std::string* product) {
  if (product_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete product_;
  }
  if (product) {
    set_has_product();
    product_ = product;
  } else {
    clear_has_product();
    product_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.ExtendedInvoiceItem.Product)
}

// optional string Unit = 2;
inline bool ExtendedInvoiceItem::has_unit() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ExtendedInvoiceItem::set_has_unit() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ExtendedInvoiceItem::clear_has_unit() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ExtendedInvoiceItem::clear_unit() {
  if (unit_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    unit_->clear();
  }
  clear_has_unit();
}
inline const ::std::string& ExtendedInvoiceItem::unit() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.ExtendedInvoiceItem.Unit)
  return *unit_;
}
inline void ExtendedInvoiceItem::set_unit(const ::std::string& value) {
  set_has_unit();
  if (unit_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    unit_ = new ::std::string;
  }
  unit_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.ExtendedInvoiceItem.Unit)
}
inline void ExtendedInvoiceItem::set_unit(const char* value) {
  set_has_unit();
  if (unit_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    unit_ = new ::std::string;
  }
  unit_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.ExtendedInvoiceItem.Unit)
}
inline void ExtendedInvoiceItem::set_unit(const char* value, size_t size) {
  set_has_unit();
  if (unit_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    unit_ = new ::std::string;
  }
  unit_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.ExtendedInvoiceItem.Unit)
}
inline ::std::string* ExtendedInvoiceItem::mutable_unit() {
  set_has_unit();
  if (unit_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    unit_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.ExtendedInvoiceItem.Unit)
  return unit_;
}
inline ::std::string* ExtendedInvoiceItem::release_unit() {
  clear_has_unit();
  if (unit_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = unit_;
    unit_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ExtendedInvoiceItem::set_allocated_unit(::std::string* unit) {
  if (unit_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete unit_;
  }
  if (unit) {
    set_has_unit();
    unit_ = unit;
  } else {
    clear_has_unit();
    unit_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.ExtendedInvoiceItem.Unit)
}

// optional string UnitName = 3;
inline bool ExtendedInvoiceItem::has_unitname() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ExtendedInvoiceItem::set_has_unitname() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ExtendedInvoiceItem::clear_has_unitname() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ExtendedInvoiceItem::clear_unitname() {
  if (unitname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    unitname_->clear();
  }
  clear_has_unitname();
}
inline const ::std::string& ExtendedInvoiceItem::unitname() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.ExtendedInvoiceItem.UnitName)
  return *unitname_;
}
inline void ExtendedInvoiceItem::set_unitname(const ::std::string& value) {
  set_has_unitname();
  if (unitname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    unitname_ = new ::std::string;
  }
  unitname_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.ExtendedInvoiceItem.UnitName)
}
inline void ExtendedInvoiceItem::set_unitname(const char* value) {
  set_has_unitname();
  if (unitname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    unitname_ = new ::std::string;
  }
  unitname_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.ExtendedInvoiceItem.UnitName)
}
inline void ExtendedInvoiceItem::set_unitname(const char* value, size_t size) {
  set_has_unitname();
  if (unitname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    unitname_ = new ::std::string;
  }
  unitname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.ExtendedInvoiceItem.UnitName)
}
inline ::std::string* ExtendedInvoiceItem::mutable_unitname() {
  set_has_unitname();
  if (unitname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    unitname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.ExtendedInvoiceItem.UnitName)
  return unitname_;
}
inline ::std::string* ExtendedInvoiceItem::release_unitname() {
  clear_has_unitname();
  if (unitname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = unitname_;
    unitname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ExtendedInvoiceItem::set_allocated_unitname(::std::string* unitname) {
  if (unitname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete unitname_;
  }
  if (unitname) {
    set_has_unitname();
    unitname_ = unitname;
  } else {
    clear_has_unitname();
    unitname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.ExtendedInvoiceItem.UnitName)
}

// optional string Quantity = 4;
inline bool ExtendedInvoiceItem::has_quantity() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ExtendedInvoiceItem::set_has_quantity() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ExtendedInvoiceItem::clear_has_quantity() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ExtendedInvoiceItem::clear_quantity() {
  if (quantity_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    quantity_->clear();
  }
  clear_has_quantity();
}
inline const ::std::string& ExtendedInvoiceItem::quantity() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.ExtendedInvoiceItem.Quantity)
  return *quantity_;
}
inline void ExtendedInvoiceItem::set_quantity(const ::std::string& value) {
  set_has_quantity();
  if (quantity_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    quantity_ = new ::std::string;
  }
  quantity_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.ExtendedInvoiceItem.Quantity)
}
inline void ExtendedInvoiceItem::set_quantity(const char* value) {
  set_has_quantity();
  if (quantity_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    quantity_ = new ::std::string;
  }
  quantity_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.ExtendedInvoiceItem.Quantity)
}
inline void ExtendedInvoiceItem::set_quantity(const char* value, size_t size) {
  set_has_quantity();
  if (quantity_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    quantity_ = new ::std::string;
  }
  quantity_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.ExtendedInvoiceItem.Quantity)
}
inline ::std::string* ExtendedInvoiceItem::mutable_quantity() {
  set_has_quantity();
  if (quantity_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    quantity_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.ExtendedInvoiceItem.Quantity)
  return quantity_;
}
inline ::std::string* ExtendedInvoiceItem::release_quantity() {
  clear_has_quantity();
  if (quantity_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = quantity_;
    quantity_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ExtendedInvoiceItem::set_allocated_quantity(::std::string* quantity) {
  if (quantity_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete quantity_;
  }
  if (quantity) {
    set_has_quantity();
    quantity_ = quantity;
  } else {
    clear_has_quantity();
    quantity_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.ExtendedInvoiceItem.Quantity)
}

// optional string Price = 5;
inline bool ExtendedInvoiceItem::has_price() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ExtendedInvoiceItem::set_has_price() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ExtendedInvoiceItem::clear_has_price() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ExtendedInvoiceItem::clear_price() {
  if (price_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    price_->clear();
  }
  clear_has_price();
}
inline const ::std::string& ExtendedInvoiceItem::price() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.ExtendedInvoiceItem.Price)
  return *price_;
}
inline void ExtendedInvoiceItem::set_price(const ::std::string& value) {
  set_has_price();
  if (price_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    price_ = new ::std::string;
  }
  price_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.ExtendedInvoiceItem.Price)
}
inline void ExtendedInvoiceItem::set_price(const char* value) {
  set_has_price();
  if (price_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    price_ = new ::std::string;
  }
  price_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.ExtendedInvoiceItem.Price)
}
inline void ExtendedInvoiceItem::set_price(const char* value, size_t size) {
  set_has_price();
  if (price_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    price_ = new ::std::string;
  }
  price_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.ExtendedInvoiceItem.Price)
}
inline ::std::string* ExtendedInvoiceItem::mutable_price() {
  set_has_price();
  if (price_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    price_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.ExtendedInvoiceItem.Price)
  return price_;
}
inline ::std::string* ExtendedInvoiceItem::release_price() {
  clear_has_price();
  if (price_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = price_;
    price_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ExtendedInvoiceItem::set_allocated_price(::std::string* price) {
  if (price_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete price_;
  }
  if (price) {
    set_has_price();
    price_ = price;
  } else {
    clear_has_price();
    price_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.ExtendedInvoiceItem.Price)
}

// optional string Excise = 6;
inline bool ExtendedInvoiceItem::has_excise() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ExtendedInvoiceItem::set_has_excise() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ExtendedInvoiceItem::clear_has_excise() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ExtendedInvoiceItem::clear_excise() {
  if (excise_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    excise_->clear();
  }
  clear_has_excise();
}
inline const ::std::string& ExtendedInvoiceItem::excise() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.ExtendedInvoiceItem.Excise)
  return *excise_;
}
inline void ExtendedInvoiceItem::set_excise(const ::std::string& value) {
  set_has_excise();
  if (excise_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    excise_ = new ::std::string;
  }
  excise_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.ExtendedInvoiceItem.Excise)
}
inline void ExtendedInvoiceItem::set_excise(const char* value) {
  set_has_excise();
  if (excise_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    excise_ = new ::std::string;
  }
  excise_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.ExtendedInvoiceItem.Excise)
}
inline void ExtendedInvoiceItem::set_excise(const char* value, size_t size) {
  set_has_excise();
  if (excise_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    excise_ = new ::std::string;
  }
  excise_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.ExtendedInvoiceItem.Excise)
}
inline ::std::string* ExtendedInvoiceItem::mutable_excise() {
  set_has_excise();
  if (excise_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    excise_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.ExtendedInvoiceItem.Excise)
  return excise_;
}
inline ::std::string* ExtendedInvoiceItem::release_excise() {
  clear_has_excise();
  if (excise_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = excise_;
    excise_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ExtendedInvoiceItem::set_allocated_excise(::std::string* excise) {
  if (excise_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete excise_;
  }
  if (excise) {
    set_has_excise();
    excise_ = excise;
  } else {
    clear_has_excise();
    excise_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.ExtendedInvoiceItem.Excise)
}

// required .Diadoc.Api.Proto.Invoicing.TaxRate TaxRate = 7;
inline bool ExtendedInvoiceItem::has_taxrate() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ExtendedInvoiceItem::set_has_taxrate() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ExtendedInvoiceItem::clear_has_taxrate() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ExtendedInvoiceItem::clear_taxrate() {
  taxrate_ = 0;
  clear_has_taxrate();
}
inline ::Diadoc::Api::Proto::Invoicing::TaxRate ExtendedInvoiceItem::taxrate() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.ExtendedInvoiceItem.TaxRate)
  return static_cast< ::Diadoc::Api::Proto::Invoicing::TaxRate >(taxrate_);
}
inline void ExtendedInvoiceItem::set_taxrate(::Diadoc::Api::Proto::Invoicing::TaxRate value) {
  assert(::Diadoc::Api::Proto::Invoicing::TaxRate_IsValid(value));
  set_has_taxrate();
  taxrate_ = value;
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.ExtendedInvoiceItem.TaxRate)
}

// optional string SubtotalWithVatExcluded = 8;
inline bool ExtendedInvoiceItem::has_subtotalwithvatexcluded() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ExtendedInvoiceItem::set_has_subtotalwithvatexcluded() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ExtendedInvoiceItem::clear_has_subtotalwithvatexcluded() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ExtendedInvoiceItem::clear_subtotalwithvatexcluded() {
  if (subtotalwithvatexcluded_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    subtotalwithvatexcluded_->clear();
  }
  clear_has_subtotalwithvatexcluded();
}
inline const ::std::string& ExtendedInvoiceItem::subtotalwithvatexcluded() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.ExtendedInvoiceItem.SubtotalWithVatExcluded)
  return *subtotalwithvatexcluded_;
}
inline void ExtendedInvoiceItem::set_subtotalwithvatexcluded(const ::std::string& value) {
  set_has_subtotalwithvatexcluded();
  if (subtotalwithvatexcluded_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    subtotalwithvatexcluded_ = new ::std::string;
  }
  subtotalwithvatexcluded_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.ExtendedInvoiceItem.SubtotalWithVatExcluded)
}
inline void ExtendedInvoiceItem::set_subtotalwithvatexcluded(const char* value) {
  set_has_subtotalwithvatexcluded();
  if (subtotalwithvatexcluded_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    subtotalwithvatexcluded_ = new ::std::string;
  }
  subtotalwithvatexcluded_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.ExtendedInvoiceItem.SubtotalWithVatExcluded)
}
inline void ExtendedInvoiceItem::set_subtotalwithvatexcluded(const char* value, size_t size) {
  set_has_subtotalwithvatexcluded();
  if (subtotalwithvatexcluded_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    subtotalwithvatexcluded_ = new ::std::string;
  }
  subtotalwithvatexcluded_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.ExtendedInvoiceItem.SubtotalWithVatExcluded)
}
inline ::std::string* ExtendedInvoiceItem::mutable_subtotalwithvatexcluded() {
  set_has_subtotalwithvatexcluded();
  if (subtotalwithvatexcluded_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    subtotalwithvatexcluded_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.ExtendedInvoiceItem.SubtotalWithVatExcluded)
  return subtotalwithvatexcluded_;
}
inline ::std::string* ExtendedInvoiceItem::release_subtotalwithvatexcluded() {
  clear_has_subtotalwithvatexcluded();
  if (subtotalwithvatexcluded_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = subtotalwithvatexcluded_;
    subtotalwithvatexcluded_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ExtendedInvoiceItem::set_allocated_subtotalwithvatexcluded(::std::string* subtotalwithvatexcluded) {
  if (subtotalwithvatexcluded_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete subtotalwithvatexcluded_;
  }
  if (subtotalwithvatexcluded) {
    set_has_subtotalwithvatexcluded();
    subtotalwithvatexcluded_ = subtotalwithvatexcluded;
  } else {
    clear_has_subtotalwithvatexcluded();
    subtotalwithvatexcluded_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.ExtendedInvoiceItem.SubtotalWithVatExcluded)
}

// optional string Vat = 9;
inline bool ExtendedInvoiceItem::has_vat() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ExtendedInvoiceItem::set_has_vat() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ExtendedInvoiceItem::clear_has_vat() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ExtendedInvoiceItem::clear_vat() {
  if (vat_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vat_->clear();
  }
  clear_has_vat();
}
inline const ::std::string& ExtendedInvoiceItem::vat() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.ExtendedInvoiceItem.Vat)
  return *vat_;
}
inline void ExtendedInvoiceItem::set_vat(const ::std::string& value) {
  set_has_vat();
  if (vat_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vat_ = new ::std::string;
  }
  vat_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.ExtendedInvoiceItem.Vat)
}
inline void ExtendedInvoiceItem::set_vat(const char* value) {
  set_has_vat();
  if (vat_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vat_ = new ::std::string;
  }
  vat_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.ExtendedInvoiceItem.Vat)
}
inline void ExtendedInvoiceItem::set_vat(const char* value, size_t size) {
  set_has_vat();
  if (vat_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vat_ = new ::std::string;
  }
  vat_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.ExtendedInvoiceItem.Vat)
}
inline ::std::string* ExtendedInvoiceItem::mutable_vat() {
  set_has_vat();
  if (vat_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vat_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.ExtendedInvoiceItem.Vat)
  return vat_;
}
inline ::std::string* ExtendedInvoiceItem::release_vat() {
  clear_has_vat();
  if (vat_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = vat_;
    vat_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ExtendedInvoiceItem::set_allocated_vat(::std::string* vat) {
  if (vat_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete vat_;
  }
  if (vat) {
    set_has_vat();
    vat_ = vat;
  } else {
    clear_has_vat();
    vat_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.ExtendedInvoiceItem.Vat)
}

// required string Subtotal = 10;
inline bool ExtendedInvoiceItem::has_subtotal() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ExtendedInvoiceItem::set_has_subtotal() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ExtendedInvoiceItem::clear_has_subtotal() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ExtendedInvoiceItem::clear_subtotal() {
  if (subtotal_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    subtotal_->clear();
  }
  clear_has_subtotal();
}
inline const ::std::string& ExtendedInvoiceItem::subtotal() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.ExtendedInvoiceItem.Subtotal)
  return *subtotal_;
}
inline void ExtendedInvoiceItem::set_subtotal(const ::std::string& value) {
  set_has_subtotal();
  if (subtotal_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    subtotal_ = new ::std::string;
  }
  subtotal_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.ExtendedInvoiceItem.Subtotal)
}
inline void ExtendedInvoiceItem::set_subtotal(const char* value) {
  set_has_subtotal();
  if (subtotal_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    subtotal_ = new ::std::string;
  }
  subtotal_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.ExtendedInvoiceItem.Subtotal)
}
inline void ExtendedInvoiceItem::set_subtotal(const char* value, size_t size) {
  set_has_subtotal();
  if (subtotal_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    subtotal_ = new ::std::string;
  }
  subtotal_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.ExtendedInvoiceItem.Subtotal)
}
inline ::std::string* ExtendedInvoiceItem::mutable_subtotal() {
  set_has_subtotal();
  if (subtotal_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    subtotal_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.ExtendedInvoiceItem.Subtotal)
  return subtotal_;
}
inline ::std::string* ExtendedInvoiceItem::release_subtotal() {
  clear_has_subtotal();
  if (subtotal_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = subtotal_;
    subtotal_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ExtendedInvoiceItem::set_allocated_subtotal(::std::string* subtotal) {
  if (subtotal_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete subtotal_;
  }
  if (subtotal) {
    set_has_subtotal();
    subtotal_ = subtotal;
  } else {
    clear_has_subtotal();
    subtotal_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.ExtendedInvoiceItem.Subtotal)
}

// repeated .Diadoc.Api.Proto.Invoicing.CustomsDeclaration CustomsDeclarations = 11;
inline int ExtendedInvoiceItem::customsdeclarations_size() const {
  return customsdeclarations_.size();
}
inline void ExtendedInvoiceItem::clear_customsdeclarations() {
  customsdeclarations_.Clear();
}
inline const ::Diadoc::Api::Proto::Invoicing::CustomsDeclaration& ExtendedInvoiceItem::customsdeclarations(int index) const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.ExtendedInvoiceItem.CustomsDeclarations)
  return customsdeclarations_.Get(index);
}
inline ::Diadoc::Api::Proto::Invoicing::CustomsDeclaration* ExtendedInvoiceItem::mutable_customsdeclarations(int index) {
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.ExtendedInvoiceItem.CustomsDeclarations)
  return customsdeclarations_.Mutable(index);
}
inline ::Diadoc::Api::Proto::Invoicing::CustomsDeclaration* ExtendedInvoiceItem::add_customsdeclarations() {
  // @@protoc_insertion_point(field_add:Diadoc.Api.Proto.Invoicing.ExtendedInvoiceItem.CustomsDeclarations)
  return customsdeclarations_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::CustomsDeclaration >&
ExtendedInvoiceItem::customsdeclarations() const {
  // @@protoc_insertion_point(field_list:Diadoc.Api.Proto.Invoicing.ExtendedInvoiceItem.CustomsDeclarations)
  return customsdeclarations_;
}
inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::CustomsDeclaration >*
ExtendedInvoiceItem::mutable_customsdeclarations() {
  // @@protoc_insertion_point(field_mutable_list:Diadoc.Api.Proto.Invoicing.ExtendedInvoiceItem.CustomsDeclarations)
  return &customsdeclarations_;
}

// optional .Diadoc.Api.Proto.Invoicing.ItemMark ItemMark = 12;
inline bool ExtendedInvoiceItem::has_itemmark() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void ExtendedInvoiceItem::set_has_itemmark() {
  _has_bits_[0] |= 0x00000800u;
}
inline void ExtendedInvoiceItem::clear_has_itemmark() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void ExtendedInvoiceItem::clear_itemmark() {
  itemmark_ = 0;
  clear_has_itemmark();
}
inline ::Diadoc::Api::Proto::Invoicing::ItemMark ExtendedInvoiceItem::itemmark() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.ExtendedInvoiceItem.ItemMark)
  return static_cast< ::Diadoc::Api::Proto::Invoicing::ItemMark >(itemmark_);
}
inline void ExtendedInvoiceItem::set_itemmark(::Diadoc::Api::Proto::Invoicing::ItemMark value) {
  assert(::Diadoc::Api::Proto::Invoicing::ItemMark_IsValid(value));
  set_has_itemmark();
  itemmark_ = value;
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.ExtendedInvoiceItem.ItemMark)
}

// optional string AdditionalProperty = 13;
inline bool ExtendedInvoiceItem::has_additionalproperty() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void ExtendedInvoiceItem::set_has_additionalproperty() {
  _has_bits_[0] |= 0x00001000u;
}
inline void ExtendedInvoiceItem::clear_has_additionalproperty() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void ExtendedInvoiceItem::clear_additionalproperty() {
  if (additionalproperty_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    additionalproperty_->clear();
  }
  clear_has_additionalproperty();
}
inline const ::std::string& ExtendedInvoiceItem::additionalproperty() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.ExtendedInvoiceItem.AdditionalProperty)
  return *additionalproperty_;
}
inline void ExtendedInvoiceItem::set_additionalproperty(const ::std::string& value) {
  set_has_additionalproperty();
  if (additionalproperty_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    additionalproperty_ = new ::std::string;
  }
  additionalproperty_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.ExtendedInvoiceItem.AdditionalProperty)
}
inline void ExtendedInvoiceItem::set_additionalproperty(const char* value) {
  set_has_additionalproperty();
  if (additionalproperty_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    additionalproperty_ = new ::std::string;
  }
  additionalproperty_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.ExtendedInvoiceItem.AdditionalProperty)
}
inline void ExtendedInvoiceItem::set_additionalproperty(const char* value, size_t size) {
  set_has_additionalproperty();
  if (additionalproperty_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    additionalproperty_ = new ::std::string;
  }
  additionalproperty_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.ExtendedInvoiceItem.AdditionalProperty)
}
inline ::std::string* ExtendedInvoiceItem::mutable_additionalproperty() {
  set_has_additionalproperty();
  if (additionalproperty_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    additionalproperty_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.ExtendedInvoiceItem.AdditionalProperty)
  return additionalproperty_;
}
inline ::std::string* ExtendedInvoiceItem::release_additionalproperty() {
  clear_has_additionalproperty();
  if (additionalproperty_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = additionalproperty_;
    additionalproperty_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ExtendedInvoiceItem::set_allocated_additionalproperty(::std::string* additionalproperty) {
  if (additionalproperty_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete additionalproperty_;
  }
  if (additionalproperty) {
    set_has_additionalproperty();
    additionalproperty_ = additionalproperty;
  } else {
    clear_has_additionalproperty();
    additionalproperty_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.ExtendedInvoiceItem.AdditionalProperty)
}

// optional string ItemVendorCode = 14;
inline bool ExtendedInvoiceItem::has_itemvendorcode() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void ExtendedInvoiceItem::set_has_itemvendorcode() {
  _has_bits_[0] |= 0x00002000u;
}
inline void ExtendedInvoiceItem::clear_has_itemvendorcode() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void ExtendedInvoiceItem::clear_itemvendorcode() {
  if (itemvendorcode_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    itemvendorcode_->clear();
  }
  clear_has_itemvendorcode();
}
inline const ::std::string& ExtendedInvoiceItem::itemvendorcode() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.ExtendedInvoiceItem.ItemVendorCode)
  return *itemvendorcode_;
}
inline void ExtendedInvoiceItem::set_itemvendorcode(const ::std::string& value) {
  set_has_itemvendorcode();
  if (itemvendorcode_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    itemvendorcode_ = new ::std::string;
  }
  itemvendorcode_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.ExtendedInvoiceItem.ItemVendorCode)
}
inline void ExtendedInvoiceItem::set_itemvendorcode(const char* value) {
  set_has_itemvendorcode();
  if (itemvendorcode_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    itemvendorcode_ = new ::std::string;
  }
  itemvendorcode_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.ExtendedInvoiceItem.ItemVendorCode)
}
inline void ExtendedInvoiceItem::set_itemvendorcode(const char* value, size_t size) {
  set_has_itemvendorcode();
  if (itemvendorcode_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    itemvendorcode_ = new ::std::string;
  }
  itemvendorcode_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.ExtendedInvoiceItem.ItemVendorCode)
}
inline ::std::string* ExtendedInvoiceItem::mutable_itemvendorcode() {
  set_has_itemvendorcode();
  if (itemvendorcode_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    itemvendorcode_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.ExtendedInvoiceItem.ItemVendorCode)
  return itemvendorcode_;
}
inline ::std::string* ExtendedInvoiceItem::release_itemvendorcode() {
  clear_has_itemvendorcode();
  if (itemvendorcode_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = itemvendorcode_;
    itemvendorcode_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ExtendedInvoiceItem::set_allocated_itemvendorcode(::std::string* itemvendorcode) {
  if (itemvendorcode_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete itemvendorcode_;
  }
  if (itemvendorcode) {
    set_has_itemvendorcode();
    itemvendorcode_ = itemvendorcode;
  } else {
    clear_has_itemvendorcode();
    itemvendorcode_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.ExtendedInvoiceItem.ItemVendorCode)
}

// optional string ItemToRelease = 15;
inline bool ExtendedInvoiceItem::has_itemtorelease() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void ExtendedInvoiceItem::set_has_itemtorelease() {
  _has_bits_[0] |= 0x00004000u;
}
inline void ExtendedInvoiceItem::clear_has_itemtorelease() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void ExtendedInvoiceItem::clear_itemtorelease() {
  if (itemtorelease_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    itemtorelease_->clear();
  }
  clear_has_itemtorelease();
}
inline const ::std::string& ExtendedInvoiceItem::itemtorelease() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.ExtendedInvoiceItem.ItemToRelease)
  return *itemtorelease_;
}
inline void ExtendedInvoiceItem::set_itemtorelease(const ::std::string& value) {
  set_has_itemtorelease();
  if (itemtorelease_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    itemtorelease_ = new ::std::string;
  }
  itemtorelease_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.ExtendedInvoiceItem.ItemToRelease)
}
inline void ExtendedInvoiceItem::set_itemtorelease(const char* value) {
  set_has_itemtorelease();
  if (itemtorelease_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    itemtorelease_ = new ::std::string;
  }
  itemtorelease_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.ExtendedInvoiceItem.ItemToRelease)
}
inline void ExtendedInvoiceItem::set_itemtorelease(const char* value, size_t size) {
  set_has_itemtorelease();
  if (itemtorelease_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    itemtorelease_ = new ::std::string;
  }
  itemtorelease_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.ExtendedInvoiceItem.ItemToRelease)
}
inline ::std::string* ExtendedInvoiceItem::mutable_itemtorelease() {
  set_has_itemtorelease();
  if (itemtorelease_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    itemtorelease_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.ExtendedInvoiceItem.ItemToRelease)
  return itemtorelease_;
}
inline ::std::string* ExtendedInvoiceItem::release_itemtorelease() {
  clear_has_itemtorelease();
  if (itemtorelease_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = itemtorelease_;
    itemtorelease_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ExtendedInvoiceItem::set_allocated_itemtorelease(::std::string* itemtorelease) {
  if (itemtorelease_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete itemtorelease_;
  }
  if (itemtorelease) {
    set_has_itemtorelease();
    itemtorelease_ = itemtorelease;
  } else {
    clear_has_itemtorelease();
    itemtorelease_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.ExtendedInvoiceItem.ItemToRelease)
}

// optional string ItemAccountDebit = 16;
inline bool ExtendedInvoiceItem::has_itemaccountdebit() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void ExtendedInvoiceItem::set_has_itemaccountdebit() {
  _has_bits_[0] |= 0x00008000u;
}
inline void ExtendedInvoiceItem::clear_has_itemaccountdebit() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void ExtendedInvoiceItem::clear_itemaccountdebit() {
  if (itemaccountdebit_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    itemaccountdebit_->clear();
  }
  clear_has_itemaccountdebit();
}
inline const ::std::string& ExtendedInvoiceItem::itemaccountdebit() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.ExtendedInvoiceItem.ItemAccountDebit)
  return *itemaccountdebit_;
}
inline void ExtendedInvoiceItem::set_itemaccountdebit(const ::std::string& value) {
  set_has_itemaccountdebit();
  if (itemaccountdebit_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    itemaccountdebit_ = new ::std::string;
  }
  itemaccountdebit_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.ExtendedInvoiceItem.ItemAccountDebit)
}
inline void ExtendedInvoiceItem::set_itemaccountdebit(const char* value) {
  set_has_itemaccountdebit();
  if (itemaccountdebit_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    itemaccountdebit_ = new ::std::string;
  }
  itemaccountdebit_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.ExtendedInvoiceItem.ItemAccountDebit)
}
inline void ExtendedInvoiceItem::set_itemaccountdebit(const char* value, size_t size) {
  set_has_itemaccountdebit();
  if (itemaccountdebit_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    itemaccountdebit_ = new ::std::string;
  }
  itemaccountdebit_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.ExtendedInvoiceItem.ItemAccountDebit)
}
inline ::std::string* ExtendedInvoiceItem::mutable_itemaccountdebit() {
  set_has_itemaccountdebit();
  if (itemaccountdebit_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    itemaccountdebit_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.ExtendedInvoiceItem.ItemAccountDebit)
  return itemaccountdebit_;
}
inline ::std::string* ExtendedInvoiceItem::release_itemaccountdebit() {
  clear_has_itemaccountdebit();
  if (itemaccountdebit_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = itemaccountdebit_;
    itemaccountdebit_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ExtendedInvoiceItem::set_allocated_itemaccountdebit(::std::string* itemaccountdebit) {
  if (itemaccountdebit_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete itemaccountdebit_;
  }
  if (itemaccountdebit) {
    set_has_itemaccountdebit();
    itemaccountdebit_ = itemaccountdebit;
  } else {
    clear_has_itemaccountdebit();
    itemaccountdebit_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.ExtendedInvoiceItem.ItemAccountDebit)
}

// optional string ItemAccountCredit = 17;
inline bool ExtendedInvoiceItem::has_itemaccountcredit() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void ExtendedInvoiceItem::set_has_itemaccountcredit() {
  _has_bits_[0] |= 0x00010000u;
}
inline void ExtendedInvoiceItem::clear_has_itemaccountcredit() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void ExtendedInvoiceItem::clear_itemaccountcredit() {
  if (itemaccountcredit_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    itemaccountcredit_->clear();
  }
  clear_has_itemaccountcredit();
}
inline const ::std::string& ExtendedInvoiceItem::itemaccountcredit() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.ExtendedInvoiceItem.ItemAccountCredit)
  return *itemaccountcredit_;
}
inline void ExtendedInvoiceItem::set_itemaccountcredit(const ::std::string& value) {
  set_has_itemaccountcredit();
  if (itemaccountcredit_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    itemaccountcredit_ = new ::std::string;
  }
  itemaccountcredit_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.ExtendedInvoiceItem.ItemAccountCredit)
}
inline void ExtendedInvoiceItem::set_itemaccountcredit(const char* value) {
  set_has_itemaccountcredit();
  if (itemaccountcredit_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    itemaccountcredit_ = new ::std::string;
  }
  itemaccountcredit_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.ExtendedInvoiceItem.ItemAccountCredit)
}
inline void ExtendedInvoiceItem::set_itemaccountcredit(const char* value, size_t size) {
  set_has_itemaccountcredit();
  if (itemaccountcredit_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    itemaccountcredit_ = new ::std::string;
  }
  itemaccountcredit_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.ExtendedInvoiceItem.ItemAccountCredit)
}
inline ::std::string* ExtendedInvoiceItem::mutable_itemaccountcredit() {
  set_has_itemaccountcredit();
  if (itemaccountcredit_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    itemaccountcredit_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.ExtendedInvoiceItem.ItemAccountCredit)
  return itemaccountcredit_;
}
inline ::std::string* ExtendedInvoiceItem::release_itemaccountcredit() {
  clear_has_itemaccountcredit();
  if (itemaccountcredit_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = itemaccountcredit_;
    itemaccountcredit_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ExtendedInvoiceItem::set_allocated_itemaccountcredit(::std::string* itemaccountcredit) {
  if (itemaccountcredit_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete itemaccountcredit_;
  }
  if (itemaccountcredit) {
    set_has_itemaccountcredit();
    itemaccountcredit_ = itemaccountcredit;
  } else {
    clear_has_itemaccountcredit();
    itemaccountcredit_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.ExtendedInvoiceItem.ItemAccountCredit)
}

// repeated .Diadoc.Api.Proto.Invoicing.AdditionalInfo AdditionalInfo = 18;
inline int ExtendedInvoiceItem::additionalinfo_size() const {
  return additionalinfo_.size();
}
inline void ExtendedInvoiceItem::clear_additionalinfo() {
  additionalinfo_.Clear();
}
inline const ::Diadoc::Api::Proto::Invoicing::AdditionalInfo& ExtendedInvoiceItem::additionalinfo(int index) const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.ExtendedInvoiceItem.AdditionalInfo)
  return additionalinfo_.Get(index);
}
inline ::Diadoc::Api::Proto::Invoicing::AdditionalInfo* ExtendedInvoiceItem::mutable_additionalinfo(int index) {
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.ExtendedInvoiceItem.AdditionalInfo)
  return additionalinfo_.Mutable(index);
}
inline ::Diadoc::Api::Proto::Invoicing::AdditionalInfo* ExtendedInvoiceItem::add_additionalinfo() {
  // @@protoc_insertion_point(field_add:Diadoc.Api.Proto.Invoicing.ExtendedInvoiceItem.AdditionalInfo)
  return additionalinfo_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::AdditionalInfo >&
ExtendedInvoiceItem::additionalinfo() const {
  // @@protoc_insertion_point(field_list:Diadoc.Api.Proto.Invoicing.ExtendedInvoiceItem.AdditionalInfo)
  return additionalinfo_;
}
inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::AdditionalInfo >*
ExtendedInvoiceItem::mutable_additionalinfo() {
  // @@protoc_insertion_point(field_mutable_list:Diadoc.Api.Proto.Invoicing.ExtendedInvoiceItem.AdditionalInfo)
  return &additionalinfo_;
}

// -------------------------------------------------------------------

// TransferInfo

// required string OperationInfo = 1;
inline bool TransferInfo::has_operationinfo() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TransferInfo::set_has_operationinfo() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TransferInfo::clear_has_operationinfo() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TransferInfo::clear_operationinfo() {
  if (operationinfo_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    operationinfo_->clear();
  }
  clear_has_operationinfo();
}
inline const ::std::string& TransferInfo::operationinfo() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.TransferInfo.OperationInfo)
  return *operationinfo_;
}
inline void TransferInfo::set_operationinfo(const ::std::string& value) {
  set_has_operationinfo();
  if (operationinfo_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    operationinfo_ = new ::std::string;
  }
  operationinfo_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.TransferInfo.OperationInfo)
}
inline void TransferInfo::set_operationinfo(const char* value) {
  set_has_operationinfo();
  if (operationinfo_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    operationinfo_ = new ::std::string;
  }
  operationinfo_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.TransferInfo.OperationInfo)
}
inline void TransferInfo::set_operationinfo(const char* value, size_t size) {
  set_has_operationinfo();
  if (operationinfo_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    operationinfo_ = new ::std::string;
  }
  operationinfo_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.TransferInfo.OperationInfo)
}
inline ::std::string* TransferInfo::mutable_operationinfo() {
  set_has_operationinfo();
  if (operationinfo_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    operationinfo_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.TransferInfo.OperationInfo)
  return operationinfo_;
}
inline ::std::string* TransferInfo::release_operationinfo() {
  clear_has_operationinfo();
  if (operationinfo_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = operationinfo_;
    operationinfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TransferInfo::set_allocated_operationinfo(::std::string* operationinfo) {
  if (operationinfo_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete operationinfo_;
  }
  if (operationinfo) {
    set_has_operationinfo();
    operationinfo_ = operationinfo;
  } else {
    clear_has_operationinfo();
    operationinfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.TransferInfo.OperationInfo)
}

// optional string OperationType = 2;
inline bool TransferInfo::has_operationtype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TransferInfo::set_has_operationtype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TransferInfo::clear_has_operationtype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TransferInfo::clear_operationtype() {
  if (operationtype_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    operationtype_->clear();
  }
  clear_has_operationtype();
}
inline const ::std::string& TransferInfo::operationtype() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.TransferInfo.OperationType)
  return *operationtype_;
}
inline void TransferInfo::set_operationtype(const ::std::string& value) {
  set_has_operationtype();
  if (operationtype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    operationtype_ = new ::std::string;
  }
  operationtype_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.TransferInfo.OperationType)
}
inline void TransferInfo::set_operationtype(const char* value) {
  set_has_operationtype();
  if (operationtype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    operationtype_ = new ::std::string;
  }
  operationtype_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.TransferInfo.OperationType)
}
inline void TransferInfo::set_operationtype(const char* value, size_t size) {
  set_has_operationtype();
  if (operationtype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    operationtype_ = new ::std::string;
  }
  operationtype_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.TransferInfo.OperationType)
}
inline ::std::string* TransferInfo::mutable_operationtype() {
  set_has_operationtype();
  if (operationtype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    operationtype_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.TransferInfo.OperationType)
  return operationtype_;
}
inline ::std::string* TransferInfo::release_operationtype() {
  clear_has_operationtype();
  if (operationtype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = operationtype_;
    operationtype_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TransferInfo::set_allocated_operationtype(::std::string* operationtype) {
  if (operationtype_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete operationtype_;
  }
  if (operationtype) {
    set_has_operationtype();
    operationtype_ = operationtype;
  } else {
    clear_has_operationtype();
    operationtype_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.TransferInfo.OperationType)
}

// optional string TransferDate = 3;
inline bool TransferInfo::has_transferdate() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TransferInfo::set_has_transferdate() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TransferInfo::clear_has_transferdate() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TransferInfo::clear_transferdate() {
  if (transferdate_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    transferdate_->clear();
  }
  clear_has_transferdate();
}
inline const ::std::string& TransferInfo::transferdate() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.TransferInfo.TransferDate)
  return *transferdate_;
}
inline void TransferInfo::set_transferdate(const ::std::string& value) {
  set_has_transferdate();
  if (transferdate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    transferdate_ = new ::std::string;
  }
  transferdate_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.TransferInfo.TransferDate)
}
inline void TransferInfo::set_transferdate(const char* value) {
  set_has_transferdate();
  if (transferdate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    transferdate_ = new ::std::string;
  }
  transferdate_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.TransferInfo.TransferDate)
}
inline void TransferInfo::set_transferdate(const char* value, size_t size) {
  set_has_transferdate();
  if (transferdate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    transferdate_ = new ::std::string;
  }
  transferdate_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.TransferInfo.TransferDate)
}
inline ::std::string* TransferInfo::mutable_transferdate() {
  set_has_transferdate();
  if (transferdate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    transferdate_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.TransferInfo.TransferDate)
  return transferdate_;
}
inline ::std::string* TransferInfo::release_transferdate() {
  clear_has_transferdate();
  if (transferdate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = transferdate_;
    transferdate_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TransferInfo::set_allocated_transferdate(::std::string* transferdate) {
  if (transferdate_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete transferdate_;
  }
  if (transferdate) {
    set_has_transferdate();
    transferdate_ = transferdate;
  } else {
    clear_has_transferdate();
    transferdate_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.TransferInfo.TransferDate)
}

// repeated .Diadoc.Api.Proto.Invoicing.TransferBase TransferBase = 4;
inline int TransferInfo::transferbase_size() const {
  return transferbase_.size();
}
inline void TransferInfo::clear_transferbase() {
  transferbase_.Clear();
}
inline const ::Diadoc::Api::Proto::Invoicing::TransferBase& TransferInfo::transferbase(int index) const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.TransferInfo.TransferBase)
  return transferbase_.Get(index);
}
inline ::Diadoc::Api::Proto::Invoicing::TransferBase* TransferInfo::mutable_transferbase(int index) {
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.TransferInfo.TransferBase)
  return transferbase_.Mutable(index);
}
inline ::Diadoc::Api::Proto::Invoicing::TransferBase* TransferInfo::add_transferbase() {
  // @@protoc_insertion_point(field_add:Diadoc.Api.Proto.Invoicing.TransferInfo.TransferBase)
  return transferbase_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::TransferBase >&
TransferInfo::transferbase() const {
  // @@protoc_insertion_point(field_list:Diadoc.Api.Proto.Invoicing.TransferInfo.TransferBase)
  return transferbase_;
}
inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::TransferBase >*
TransferInfo::mutable_transferbase() {
  // @@protoc_insertion_point(field_mutable_list:Diadoc.Api.Proto.Invoicing.TransferInfo.TransferBase)
  return &transferbase_;
}

// optional string TransferTextInfo = 5;
inline bool TransferInfo::has_transfertextinfo() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TransferInfo::set_has_transfertextinfo() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TransferInfo::clear_has_transfertextinfo() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TransferInfo::clear_transfertextinfo() {
  if (transfertextinfo_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    transfertextinfo_->clear();
  }
  clear_has_transfertextinfo();
}
inline const ::std::string& TransferInfo::transfertextinfo() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.TransferInfo.TransferTextInfo)
  return *transfertextinfo_;
}
inline void TransferInfo::set_transfertextinfo(const ::std::string& value) {
  set_has_transfertextinfo();
  if (transfertextinfo_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    transfertextinfo_ = new ::std::string;
  }
  transfertextinfo_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.TransferInfo.TransferTextInfo)
}
inline void TransferInfo::set_transfertextinfo(const char* value) {
  set_has_transfertextinfo();
  if (transfertextinfo_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    transfertextinfo_ = new ::std::string;
  }
  transfertextinfo_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.TransferInfo.TransferTextInfo)
}
inline void TransferInfo::set_transfertextinfo(const char* value, size_t size) {
  set_has_transfertextinfo();
  if (transfertextinfo_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    transfertextinfo_ = new ::std::string;
  }
  transfertextinfo_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.TransferInfo.TransferTextInfo)
}
inline ::std::string* TransferInfo::mutable_transfertextinfo() {
  set_has_transfertextinfo();
  if (transfertextinfo_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    transfertextinfo_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.TransferInfo.TransferTextInfo)
  return transfertextinfo_;
}
inline ::std::string* TransferInfo::release_transfertextinfo() {
  clear_has_transfertextinfo();
  if (transfertextinfo_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = transfertextinfo_;
    transfertextinfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TransferInfo::set_allocated_transfertextinfo(::std::string* transfertextinfo) {
  if (transfertextinfo_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete transfertextinfo_;
  }
  if (transfertextinfo) {
    set_has_transfertextinfo();
    transfertextinfo_ = transfertextinfo;
  } else {
    clear_has_transfertextinfo();
    transfertextinfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.TransferInfo.TransferTextInfo)
}

// repeated .Diadoc.Api.Proto.Invoicing.Waybill Waybill = 6;
inline int TransferInfo::waybill_size() const {
  return waybill_.size();
}
inline void TransferInfo::clear_waybill() {
  waybill_.Clear();
}
inline const ::Diadoc::Api::Proto::Invoicing::Waybill& TransferInfo::waybill(int index) const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.TransferInfo.Waybill)
  return waybill_.Get(index);
}
inline ::Diadoc::Api::Proto::Invoicing::Waybill* TransferInfo::mutable_waybill(int index) {
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.TransferInfo.Waybill)
  return waybill_.Mutable(index);
}
inline ::Diadoc::Api::Proto::Invoicing::Waybill* TransferInfo::add_waybill() {
  // @@protoc_insertion_point(field_add:Diadoc.Api.Proto.Invoicing.TransferInfo.Waybill)
  return waybill_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::Waybill >&
TransferInfo::waybill() const {
  // @@protoc_insertion_point(field_list:Diadoc.Api.Proto.Invoicing.TransferInfo.Waybill)
  return waybill_;
}
inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::Waybill >*
TransferInfo::mutable_waybill() {
  // @@protoc_insertion_point(field_mutable_list:Diadoc.Api.Proto.Invoicing.TransferInfo.Waybill)
  return &waybill_;
}

// optional .Diadoc.Api.Proto.Invoicing.Organizations.ExtendedOrganizationInfo Carrier = 7;
inline bool TransferInfo::has_carrier() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TransferInfo::set_has_carrier() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TransferInfo::clear_has_carrier() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TransferInfo::clear_carrier() {
  if (carrier_ != NULL) carrier_->::Diadoc::Api::Proto::Invoicing::Organizations::ExtendedOrganizationInfo::Clear();
  clear_has_carrier();
}
inline const ::Diadoc::Api::Proto::Invoicing::Organizations::ExtendedOrganizationInfo& TransferInfo::carrier() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.TransferInfo.Carrier)
  return carrier_ != NULL ? *carrier_ : *default_instance_->carrier_;
}
inline ::Diadoc::Api::Proto::Invoicing::Organizations::ExtendedOrganizationInfo* TransferInfo::mutable_carrier() {
  set_has_carrier();
  if (carrier_ == NULL) carrier_ = new ::Diadoc::Api::Proto::Invoicing::Organizations::ExtendedOrganizationInfo;
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.TransferInfo.Carrier)
  return carrier_;
}
inline ::Diadoc::Api::Proto::Invoicing::Organizations::ExtendedOrganizationInfo* TransferInfo::release_carrier() {
  clear_has_carrier();
  ::Diadoc::Api::Proto::Invoicing::Organizations::ExtendedOrganizationInfo* temp = carrier_;
  carrier_ = NULL;
  return temp;
}
inline void TransferInfo::set_allocated_carrier(::Diadoc::Api::Proto::Invoicing::Organizations::ExtendedOrganizationInfo* carrier) {
  delete carrier_;
  carrier_ = carrier;
  if (carrier) {
    set_has_carrier();
  } else {
    clear_has_carrier();
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.TransferInfo.Carrier)
}

// optional .Diadoc.Api.Proto.Invoicing.Employee Employee = 8;
inline bool TransferInfo::has_employee() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TransferInfo::set_has_employee() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TransferInfo::clear_has_employee() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TransferInfo::clear_employee() {
  if (employee_ != NULL) employee_->::Diadoc::Api::Proto::Invoicing::Employee::Clear();
  clear_has_employee();
}
inline const ::Diadoc::Api::Proto::Invoicing::Employee& TransferInfo::employee() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.TransferInfo.Employee)
  return employee_ != NULL ? *employee_ : *default_instance_->employee_;
}
inline ::Diadoc::Api::Proto::Invoicing::Employee* TransferInfo::mutable_employee() {
  set_has_employee();
  if (employee_ == NULL) employee_ = new ::Diadoc::Api::Proto::Invoicing::Employee;
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.TransferInfo.Employee)
  return employee_;
}
inline ::Diadoc::Api::Proto::Invoicing::Employee* TransferInfo::release_employee() {
  clear_has_employee();
  ::Diadoc::Api::Proto::Invoicing::Employee* temp = employee_;
  employee_ = NULL;
  return temp;
}
inline void TransferInfo::set_allocated_employee(::Diadoc::Api::Proto::Invoicing::Employee* employee) {
  delete employee_;
  employee_ = employee;
  if (employee) {
    set_has_employee();
  } else {
    clear_has_employee();
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.TransferInfo.Employee)
}

// optional .Diadoc.Api.Proto.Invoicing.OtherIssuer OtherIssuer = 9;
inline bool TransferInfo::has_otherissuer() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TransferInfo::set_has_otherissuer() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TransferInfo::clear_has_otherissuer() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TransferInfo::clear_otherissuer() {
  if (otherissuer_ != NULL) otherissuer_->::Diadoc::Api::Proto::Invoicing::OtherIssuer::Clear();
  clear_has_otherissuer();
}
inline const ::Diadoc::Api::Proto::Invoicing::OtherIssuer& TransferInfo::otherissuer() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.TransferInfo.OtherIssuer)
  return otherissuer_ != NULL ? *otherissuer_ : *default_instance_->otherissuer_;
}
inline ::Diadoc::Api::Proto::Invoicing::OtherIssuer* TransferInfo::mutable_otherissuer() {
  set_has_otherissuer();
  if (otherissuer_ == NULL) otherissuer_ = new ::Diadoc::Api::Proto::Invoicing::OtherIssuer;
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.TransferInfo.OtherIssuer)
  return otherissuer_;
}
inline ::Diadoc::Api::Proto::Invoicing::OtherIssuer* TransferInfo::release_otherissuer() {
  clear_has_otherissuer();
  ::Diadoc::Api::Proto::Invoicing::OtherIssuer* temp = otherissuer_;
  otherissuer_ = NULL;
  return temp;
}
inline void TransferInfo::set_allocated_otherissuer(::Diadoc::Api::Proto::Invoicing::OtherIssuer* otherissuer) {
  delete otherissuer_;
  otherissuer_ = otherissuer;
  if (otherissuer) {
    set_has_otherissuer();
  } else {
    clear_has_otherissuer();
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.TransferInfo.OtherIssuer)
}

// optional string CreatedThingTransferDate = 10;
inline bool TransferInfo::has_createdthingtransferdate() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TransferInfo::set_has_createdthingtransferdate() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TransferInfo::clear_has_createdthingtransferdate() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TransferInfo::clear_createdthingtransferdate() {
  if (createdthingtransferdate_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    createdthingtransferdate_->clear();
  }
  clear_has_createdthingtransferdate();
}
inline const ::std::string& TransferInfo::createdthingtransferdate() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.TransferInfo.CreatedThingTransferDate)
  return *createdthingtransferdate_;
}
inline void TransferInfo::set_createdthingtransferdate(const ::std::string& value) {
  set_has_createdthingtransferdate();
  if (createdthingtransferdate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    createdthingtransferdate_ = new ::std::string;
  }
  createdthingtransferdate_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.TransferInfo.CreatedThingTransferDate)
}
inline void TransferInfo::set_createdthingtransferdate(const char* value) {
  set_has_createdthingtransferdate();
  if (createdthingtransferdate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    createdthingtransferdate_ = new ::std::string;
  }
  createdthingtransferdate_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.TransferInfo.CreatedThingTransferDate)
}
inline void TransferInfo::set_createdthingtransferdate(const char* value, size_t size) {
  set_has_createdthingtransferdate();
  if (createdthingtransferdate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    createdthingtransferdate_ = new ::std::string;
  }
  createdthingtransferdate_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.TransferInfo.CreatedThingTransferDate)
}
inline ::std::string* TransferInfo::mutable_createdthingtransferdate() {
  set_has_createdthingtransferdate();
  if (createdthingtransferdate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    createdthingtransferdate_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.TransferInfo.CreatedThingTransferDate)
  return createdthingtransferdate_;
}
inline ::std::string* TransferInfo::release_createdthingtransferdate() {
  clear_has_createdthingtransferdate();
  if (createdthingtransferdate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = createdthingtransferdate_;
    createdthingtransferdate_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TransferInfo::set_allocated_createdthingtransferdate(::std::string* createdthingtransferdate) {
  if (createdthingtransferdate_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete createdthingtransferdate_;
  }
  if (createdthingtransferdate) {
    set_has_createdthingtransferdate();
    createdthingtransferdate_ = createdthingtransferdate;
  } else {
    clear_has_createdthingtransferdate();
    createdthingtransferdate_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.TransferInfo.CreatedThingTransferDate)
}

// optional string CreatedThingInfo = 11;
inline bool TransferInfo::has_createdthinginfo() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void TransferInfo::set_has_createdthinginfo() {
  _has_bits_[0] |= 0x00000400u;
}
inline void TransferInfo::clear_has_createdthinginfo() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void TransferInfo::clear_createdthinginfo() {
  if (createdthinginfo_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    createdthinginfo_->clear();
  }
  clear_has_createdthinginfo();
}
inline const ::std::string& TransferInfo::createdthinginfo() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.TransferInfo.CreatedThingInfo)
  return *createdthinginfo_;
}
inline void TransferInfo::set_createdthinginfo(const ::std::string& value) {
  set_has_createdthinginfo();
  if (createdthinginfo_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    createdthinginfo_ = new ::std::string;
  }
  createdthinginfo_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.TransferInfo.CreatedThingInfo)
}
inline void TransferInfo::set_createdthinginfo(const char* value) {
  set_has_createdthinginfo();
  if (createdthinginfo_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    createdthinginfo_ = new ::std::string;
  }
  createdthinginfo_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.TransferInfo.CreatedThingInfo)
}
inline void TransferInfo::set_createdthinginfo(const char* value, size_t size) {
  set_has_createdthinginfo();
  if (createdthinginfo_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    createdthinginfo_ = new ::std::string;
  }
  createdthinginfo_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.TransferInfo.CreatedThingInfo)
}
inline ::std::string* TransferInfo::mutable_createdthinginfo() {
  set_has_createdthinginfo();
  if (createdthinginfo_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    createdthinginfo_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.TransferInfo.CreatedThingInfo)
  return createdthinginfo_;
}
inline ::std::string* TransferInfo::release_createdthinginfo() {
  clear_has_createdthinginfo();
  if (createdthinginfo_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = createdthinginfo_;
    createdthinginfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TransferInfo::set_allocated_createdthinginfo(::std::string* createdthinginfo) {
  if (createdthinginfo_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete createdthinginfo_;
  }
  if (createdthinginfo) {
    set_has_createdthinginfo();
    createdthinginfo_ = createdthinginfo;
  } else {
    clear_has_createdthinginfo();
    createdthinginfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.TransferInfo.CreatedThingInfo)
}

// optional .Diadoc.Api.Proto.Invoicing.AdditionalInfoId AdditionalInfoId = 12;
inline bool TransferInfo::has_additionalinfoid() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void TransferInfo::set_has_additionalinfoid() {
  _has_bits_[0] |= 0x00000800u;
}
inline void TransferInfo::clear_has_additionalinfoid() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void TransferInfo::clear_additionalinfoid() {
  if (additionalinfoid_ != NULL) additionalinfoid_->::Diadoc::Api::Proto::Invoicing::AdditionalInfoId::Clear();
  clear_has_additionalinfoid();
}
inline const ::Diadoc::Api::Proto::Invoicing::AdditionalInfoId& TransferInfo::additionalinfoid() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.TransferInfo.AdditionalInfoId)
  return additionalinfoid_ != NULL ? *additionalinfoid_ : *default_instance_->additionalinfoid_;
}
inline ::Diadoc::Api::Proto::Invoicing::AdditionalInfoId* TransferInfo::mutable_additionalinfoid() {
  set_has_additionalinfoid();
  if (additionalinfoid_ == NULL) additionalinfoid_ = new ::Diadoc::Api::Proto::Invoicing::AdditionalInfoId;
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.TransferInfo.AdditionalInfoId)
  return additionalinfoid_;
}
inline ::Diadoc::Api::Proto::Invoicing::AdditionalInfoId* TransferInfo::release_additionalinfoid() {
  clear_has_additionalinfoid();
  ::Diadoc::Api::Proto::Invoicing::AdditionalInfoId* temp = additionalinfoid_;
  additionalinfoid_ = NULL;
  return temp;
}
inline void TransferInfo::set_allocated_additionalinfoid(::Diadoc::Api::Proto::Invoicing::AdditionalInfoId* additionalinfoid) {
  delete additionalinfoid_;
  additionalinfoid_ = additionalinfoid;
  if (additionalinfoid) {
    set_has_additionalinfoid();
  } else {
    clear_has_additionalinfoid();
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.TransferInfo.AdditionalInfoId)
}

// -------------------------------------------------------------------

// TransferBase

// required string BaseDocumentName = 1;
inline bool TransferBase::has_basedocumentname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TransferBase::set_has_basedocumentname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TransferBase::clear_has_basedocumentname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TransferBase::clear_basedocumentname() {
  if (basedocumentname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    basedocumentname_->clear();
  }
  clear_has_basedocumentname();
}
inline const ::std::string& TransferBase::basedocumentname() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.TransferBase.BaseDocumentName)
  return *basedocumentname_;
}
inline void TransferBase::set_basedocumentname(const ::std::string& value) {
  set_has_basedocumentname();
  if (basedocumentname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    basedocumentname_ = new ::std::string;
  }
  basedocumentname_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.TransferBase.BaseDocumentName)
}
inline void TransferBase::set_basedocumentname(const char* value) {
  set_has_basedocumentname();
  if (basedocumentname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    basedocumentname_ = new ::std::string;
  }
  basedocumentname_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.TransferBase.BaseDocumentName)
}
inline void TransferBase::set_basedocumentname(const char* value, size_t size) {
  set_has_basedocumentname();
  if (basedocumentname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    basedocumentname_ = new ::std::string;
  }
  basedocumentname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.TransferBase.BaseDocumentName)
}
inline ::std::string* TransferBase::mutable_basedocumentname() {
  set_has_basedocumentname();
  if (basedocumentname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    basedocumentname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.TransferBase.BaseDocumentName)
  return basedocumentname_;
}
inline ::std::string* TransferBase::release_basedocumentname() {
  clear_has_basedocumentname();
  if (basedocumentname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = basedocumentname_;
    basedocumentname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TransferBase::set_allocated_basedocumentname(::std::string* basedocumentname) {
  if (basedocumentname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete basedocumentname_;
  }
  if (basedocumentname) {
    set_has_basedocumentname();
    basedocumentname_ = basedocumentname;
  } else {
    clear_has_basedocumentname();
    basedocumentname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.TransferBase.BaseDocumentName)
}

// optional string BaseDocumentNumber = 2;
inline bool TransferBase::has_basedocumentnumber() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TransferBase::set_has_basedocumentnumber() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TransferBase::clear_has_basedocumentnumber() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TransferBase::clear_basedocumentnumber() {
  if (basedocumentnumber_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    basedocumentnumber_->clear();
  }
  clear_has_basedocumentnumber();
}
inline const ::std::string& TransferBase::basedocumentnumber() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.TransferBase.BaseDocumentNumber)
  return *basedocumentnumber_;
}
inline void TransferBase::set_basedocumentnumber(const ::std::string& value) {
  set_has_basedocumentnumber();
  if (basedocumentnumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    basedocumentnumber_ = new ::std::string;
  }
  basedocumentnumber_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.TransferBase.BaseDocumentNumber)
}
inline void TransferBase::set_basedocumentnumber(const char* value) {
  set_has_basedocumentnumber();
  if (basedocumentnumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    basedocumentnumber_ = new ::std::string;
  }
  basedocumentnumber_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.TransferBase.BaseDocumentNumber)
}
inline void TransferBase::set_basedocumentnumber(const char* value, size_t size) {
  set_has_basedocumentnumber();
  if (basedocumentnumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    basedocumentnumber_ = new ::std::string;
  }
  basedocumentnumber_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.TransferBase.BaseDocumentNumber)
}
inline ::std::string* TransferBase::mutable_basedocumentnumber() {
  set_has_basedocumentnumber();
  if (basedocumentnumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    basedocumentnumber_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.TransferBase.BaseDocumentNumber)
  return basedocumentnumber_;
}
inline ::std::string* TransferBase::release_basedocumentnumber() {
  clear_has_basedocumentnumber();
  if (basedocumentnumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = basedocumentnumber_;
    basedocumentnumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TransferBase::set_allocated_basedocumentnumber(::std::string* basedocumentnumber) {
  if (basedocumentnumber_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete basedocumentnumber_;
  }
  if (basedocumentnumber) {
    set_has_basedocumentnumber();
    basedocumentnumber_ = basedocumentnumber;
  } else {
    clear_has_basedocumentnumber();
    basedocumentnumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.TransferBase.BaseDocumentNumber)
}

// optional string BaseDocumentDate = 3;
inline bool TransferBase::has_basedocumentdate() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TransferBase::set_has_basedocumentdate() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TransferBase::clear_has_basedocumentdate() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TransferBase::clear_basedocumentdate() {
  if (basedocumentdate_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    basedocumentdate_->clear();
  }
  clear_has_basedocumentdate();
}
inline const ::std::string& TransferBase::basedocumentdate() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.TransferBase.BaseDocumentDate)
  return *basedocumentdate_;
}
inline void TransferBase::set_basedocumentdate(const ::std::string& value) {
  set_has_basedocumentdate();
  if (basedocumentdate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    basedocumentdate_ = new ::std::string;
  }
  basedocumentdate_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.TransferBase.BaseDocumentDate)
}
inline void TransferBase::set_basedocumentdate(const char* value) {
  set_has_basedocumentdate();
  if (basedocumentdate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    basedocumentdate_ = new ::std::string;
  }
  basedocumentdate_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.TransferBase.BaseDocumentDate)
}
inline void TransferBase::set_basedocumentdate(const char* value, size_t size) {
  set_has_basedocumentdate();
  if (basedocumentdate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    basedocumentdate_ = new ::std::string;
  }
  basedocumentdate_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.TransferBase.BaseDocumentDate)
}
inline ::std::string* TransferBase::mutable_basedocumentdate() {
  set_has_basedocumentdate();
  if (basedocumentdate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    basedocumentdate_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.TransferBase.BaseDocumentDate)
  return basedocumentdate_;
}
inline ::std::string* TransferBase::release_basedocumentdate() {
  clear_has_basedocumentdate();
  if (basedocumentdate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = basedocumentdate_;
    basedocumentdate_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TransferBase::set_allocated_basedocumentdate(::std::string* basedocumentdate) {
  if (basedocumentdate_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete basedocumentdate_;
  }
  if (basedocumentdate) {
    set_has_basedocumentdate();
    basedocumentdate_ = basedocumentdate;
  } else {
    clear_has_basedocumentdate();
    basedocumentdate_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.TransferBase.BaseDocumentDate)
}

// optional string BaseDocumentInfo = 4;
inline bool TransferBase::has_basedocumentinfo() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TransferBase::set_has_basedocumentinfo() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TransferBase::clear_has_basedocumentinfo() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TransferBase::clear_basedocumentinfo() {
  if (basedocumentinfo_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    basedocumentinfo_->clear();
  }
  clear_has_basedocumentinfo();
}
inline const ::std::string& TransferBase::basedocumentinfo() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.TransferBase.BaseDocumentInfo)
  return *basedocumentinfo_;
}
inline void TransferBase::set_basedocumentinfo(const ::std::string& value) {
  set_has_basedocumentinfo();
  if (basedocumentinfo_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    basedocumentinfo_ = new ::std::string;
  }
  basedocumentinfo_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.TransferBase.BaseDocumentInfo)
}
inline void TransferBase::set_basedocumentinfo(const char* value) {
  set_has_basedocumentinfo();
  if (basedocumentinfo_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    basedocumentinfo_ = new ::std::string;
  }
  basedocumentinfo_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.TransferBase.BaseDocumentInfo)
}
inline void TransferBase::set_basedocumentinfo(const char* value, size_t size) {
  set_has_basedocumentinfo();
  if (basedocumentinfo_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    basedocumentinfo_ = new ::std::string;
  }
  basedocumentinfo_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.TransferBase.BaseDocumentInfo)
}
inline ::std::string* TransferBase::mutable_basedocumentinfo() {
  set_has_basedocumentinfo();
  if (basedocumentinfo_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    basedocumentinfo_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.TransferBase.BaseDocumentInfo)
  return basedocumentinfo_;
}
inline ::std::string* TransferBase::release_basedocumentinfo() {
  clear_has_basedocumentinfo();
  if (basedocumentinfo_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = basedocumentinfo_;
    basedocumentinfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TransferBase::set_allocated_basedocumentinfo(::std::string* basedocumentinfo) {
  if (basedocumentinfo_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete basedocumentinfo_;
  }
  if (basedocumentinfo) {
    set_has_basedocumentinfo();
    basedocumentinfo_ = basedocumentinfo;
  } else {
    clear_has_basedocumentinfo();
    basedocumentinfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.TransferBase.BaseDocumentInfo)
}

// -------------------------------------------------------------------

// Waybill

// required string TransferDocumentNumber = 1;
inline bool Waybill::has_transferdocumentnumber() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Waybill::set_has_transferdocumentnumber() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Waybill::clear_has_transferdocumentnumber() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Waybill::clear_transferdocumentnumber() {
  if (transferdocumentnumber_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    transferdocumentnumber_->clear();
  }
  clear_has_transferdocumentnumber();
}
inline const ::std::string& Waybill::transferdocumentnumber() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.Waybill.TransferDocumentNumber)
  return *transferdocumentnumber_;
}
inline void Waybill::set_transferdocumentnumber(const ::std::string& value) {
  set_has_transferdocumentnumber();
  if (transferdocumentnumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    transferdocumentnumber_ = new ::std::string;
  }
  transferdocumentnumber_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.Waybill.TransferDocumentNumber)
}
inline void Waybill::set_transferdocumentnumber(const char* value) {
  set_has_transferdocumentnumber();
  if (transferdocumentnumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    transferdocumentnumber_ = new ::std::string;
  }
  transferdocumentnumber_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.Waybill.TransferDocumentNumber)
}
inline void Waybill::set_transferdocumentnumber(const char* value, size_t size) {
  set_has_transferdocumentnumber();
  if (transferdocumentnumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    transferdocumentnumber_ = new ::std::string;
  }
  transferdocumentnumber_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.Waybill.TransferDocumentNumber)
}
inline ::std::string* Waybill::mutable_transferdocumentnumber() {
  set_has_transferdocumentnumber();
  if (transferdocumentnumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    transferdocumentnumber_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.Waybill.TransferDocumentNumber)
  return transferdocumentnumber_;
}
inline ::std::string* Waybill::release_transferdocumentnumber() {
  clear_has_transferdocumentnumber();
  if (transferdocumentnumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = transferdocumentnumber_;
    transferdocumentnumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Waybill::set_allocated_transferdocumentnumber(::std::string* transferdocumentnumber) {
  if (transferdocumentnumber_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete transferdocumentnumber_;
  }
  if (transferdocumentnumber) {
    set_has_transferdocumentnumber();
    transferdocumentnumber_ = transferdocumentnumber;
  } else {
    clear_has_transferdocumentnumber();
    transferdocumentnumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.Waybill.TransferDocumentNumber)
}

// required string TransferDocumentDate = 2;
inline bool Waybill::has_transferdocumentdate() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Waybill::set_has_transferdocumentdate() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Waybill::clear_has_transferdocumentdate() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Waybill::clear_transferdocumentdate() {
  if (transferdocumentdate_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    transferdocumentdate_->clear();
  }
  clear_has_transferdocumentdate();
}
inline const ::std::string& Waybill::transferdocumentdate() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.Waybill.TransferDocumentDate)
  return *transferdocumentdate_;
}
inline void Waybill::set_transferdocumentdate(const ::std::string& value) {
  set_has_transferdocumentdate();
  if (transferdocumentdate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    transferdocumentdate_ = new ::std::string;
  }
  transferdocumentdate_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.Waybill.TransferDocumentDate)
}
inline void Waybill::set_transferdocumentdate(const char* value) {
  set_has_transferdocumentdate();
  if (transferdocumentdate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    transferdocumentdate_ = new ::std::string;
  }
  transferdocumentdate_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.Waybill.TransferDocumentDate)
}
inline void Waybill::set_transferdocumentdate(const char* value, size_t size) {
  set_has_transferdocumentdate();
  if (transferdocumentdate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    transferdocumentdate_ = new ::std::string;
  }
  transferdocumentdate_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.Waybill.TransferDocumentDate)
}
inline ::std::string* Waybill::mutable_transferdocumentdate() {
  set_has_transferdocumentdate();
  if (transferdocumentdate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    transferdocumentdate_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.Waybill.TransferDocumentDate)
  return transferdocumentdate_;
}
inline ::std::string* Waybill::release_transferdocumentdate() {
  clear_has_transferdocumentdate();
  if (transferdocumentdate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = transferdocumentdate_;
    transferdocumentdate_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Waybill::set_allocated_transferdocumentdate(::std::string* transferdocumentdate) {
  if (transferdocumentdate_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete transferdocumentdate_;
  }
  if (transferdocumentdate) {
    set_has_transferdocumentdate();
    transferdocumentdate_ = transferdocumentdate;
  } else {
    clear_has_transferdocumentdate();
    transferdocumentdate_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.Waybill.TransferDocumentDate)
}

// -------------------------------------------------------------------

// Employee

// required string EmployeePosition = 1;
inline bool Employee::has_employeeposition() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Employee::set_has_employeeposition() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Employee::clear_has_employeeposition() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Employee::clear_employeeposition() {
  if (employeeposition_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    employeeposition_->clear();
  }
  clear_has_employeeposition();
}
inline const ::std::string& Employee::employeeposition() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.Employee.EmployeePosition)
  return *employeeposition_;
}
inline void Employee::set_employeeposition(const ::std::string& value) {
  set_has_employeeposition();
  if (employeeposition_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    employeeposition_ = new ::std::string;
  }
  employeeposition_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.Employee.EmployeePosition)
}
inline void Employee::set_employeeposition(const char* value) {
  set_has_employeeposition();
  if (employeeposition_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    employeeposition_ = new ::std::string;
  }
  employeeposition_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.Employee.EmployeePosition)
}
inline void Employee::set_employeeposition(const char* value, size_t size) {
  set_has_employeeposition();
  if (employeeposition_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    employeeposition_ = new ::std::string;
  }
  employeeposition_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.Employee.EmployeePosition)
}
inline ::std::string* Employee::mutable_employeeposition() {
  set_has_employeeposition();
  if (employeeposition_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    employeeposition_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.Employee.EmployeePosition)
  return employeeposition_;
}
inline ::std::string* Employee::release_employeeposition() {
  clear_has_employeeposition();
  if (employeeposition_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = employeeposition_;
    employeeposition_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Employee::set_allocated_employeeposition(::std::string* employeeposition) {
  if (employeeposition_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete employeeposition_;
  }
  if (employeeposition) {
    set_has_employeeposition();
    employeeposition_ = employeeposition;
  } else {
    clear_has_employeeposition();
    employeeposition_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.Employee.EmployeePosition)
}

// optional string EmployeeInfo = 2;
inline bool Employee::has_employeeinfo() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Employee::set_has_employeeinfo() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Employee::clear_has_employeeinfo() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Employee::clear_employeeinfo() {
  if (employeeinfo_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    employeeinfo_->clear();
  }
  clear_has_employeeinfo();
}
inline const ::std::string& Employee::employeeinfo() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.Employee.EmployeeInfo)
  return *employeeinfo_;
}
inline void Employee::set_employeeinfo(const ::std::string& value) {
  set_has_employeeinfo();
  if (employeeinfo_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    employeeinfo_ = new ::std::string;
  }
  employeeinfo_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.Employee.EmployeeInfo)
}
inline void Employee::set_employeeinfo(const char* value) {
  set_has_employeeinfo();
  if (employeeinfo_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    employeeinfo_ = new ::std::string;
  }
  employeeinfo_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.Employee.EmployeeInfo)
}
inline void Employee::set_employeeinfo(const char* value, size_t size) {
  set_has_employeeinfo();
  if (employeeinfo_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    employeeinfo_ = new ::std::string;
  }
  employeeinfo_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.Employee.EmployeeInfo)
}
inline ::std::string* Employee::mutable_employeeinfo() {
  set_has_employeeinfo();
  if (employeeinfo_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    employeeinfo_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.Employee.EmployeeInfo)
  return employeeinfo_;
}
inline ::std::string* Employee::release_employeeinfo() {
  clear_has_employeeinfo();
  if (employeeinfo_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = employeeinfo_;
    employeeinfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Employee::set_allocated_employeeinfo(::std::string* employeeinfo) {
  if (employeeinfo_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete employeeinfo_;
  }
  if (employeeinfo) {
    set_has_employeeinfo();
    employeeinfo_ = employeeinfo;
  } else {
    clear_has_employeeinfo();
    employeeinfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.Employee.EmployeeInfo)
}

// optional string EmployeeBase = 3;
inline bool Employee::has_employeebase() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Employee::set_has_employeebase() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Employee::clear_has_employeebase() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Employee::clear_employeebase() {
  if (employeebase_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    employeebase_->clear();
  }
  clear_has_employeebase();
}
inline const ::std::string& Employee::employeebase() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.Employee.EmployeeBase)
  return *employeebase_;
}
inline void Employee::set_employeebase(const ::std::string& value) {
  set_has_employeebase();
  if (employeebase_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    employeebase_ = new ::std::string;
  }
  employeebase_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.Employee.EmployeeBase)
}
inline void Employee::set_employeebase(const char* value) {
  set_has_employeebase();
  if (employeebase_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    employeebase_ = new ::std::string;
  }
  employeebase_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.Employee.EmployeeBase)
}
inline void Employee::set_employeebase(const char* value, size_t size) {
  set_has_employeebase();
  if (employeebase_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    employeebase_ = new ::std::string;
  }
  employeebase_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.Employee.EmployeeBase)
}
inline ::std::string* Employee::mutable_employeebase() {
  set_has_employeebase();
  if (employeebase_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    employeebase_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.Employee.EmployeeBase)
  return employeebase_;
}
inline ::std::string* Employee::release_employeebase() {
  clear_has_employeebase();
  if (employeebase_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = employeebase_;
    employeebase_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Employee::set_allocated_employeebase(::std::string* employeebase) {
  if (employeebase_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete employeebase_;
  }
  if (employeebase) {
    set_has_employeebase();
    employeebase_ = employeebase;
  } else {
    clear_has_employeebase();
    employeebase_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.Employee.EmployeeBase)
}

// required string TransferSurname = 4;
inline bool Employee::has_transfersurname() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Employee::set_has_transfersurname() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Employee::clear_has_transfersurname() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Employee::clear_transfersurname() {
  if (transfersurname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    transfersurname_->clear();
  }
  clear_has_transfersurname();
}
inline const ::std::string& Employee::transfersurname() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.Employee.TransferSurname)
  return *transfersurname_;
}
inline void Employee::set_transfersurname(const ::std::string& value) {
  set_has_transfersurname();
  if (transfersurname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    transfersurname_ = new ::std::string;
  }
  transfersurname_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.Employee.TransferSurname)
}
inline void Employee::set_transfersurname(const char* value) {
  set_has_transfersurname();
  if (transfersurname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    transfersurname_ = new ::std::string;
  }
  transfersurname_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.Employee.TransferSurname)
}
inline void Employee::set_transfersurname(const char* value, size_t size) {
  set_has_transfersurname();
  if (transfersurname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    transfersurname_ = new ::std::string;
  }
  transfersurname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.Employee.TransferSurname)
}
inline ::std::string* Employee::mutable_transfersurname() {
  set_has_transfersurname();
  if (transfersurname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    transfersurname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.Employee.TransferSurname)
  return transfersurname_;
}
inline ::std::string* Employee::release_transfersurname() {
  clear_has_transfersurname();
  if (transfersurname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = transfersurname_;
    transfersurname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Employee::set_allocated_transfersurname(::std::string* transfersurname) {
  if (transfersurname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete transfersurname_;
  }
  if (transfersurname) {
    set_has_transfersurname();
    transfersurname_ = transfersurname;
  } else {
    clear_has_transfersurname();
    transfersurname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.Employee.TransferSurname)
}

// required string TransferFirstName = 5;
inline bool Employee::has_transferfirstname() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Employee::set_has_transferfirstname() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Employee::clear_has_transferfirstname() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Employee::clear_transferfirstname() {
  if (transferfirstname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    transferfirstname_->clear();
  }
  clear_has_transferfirstname();
}
inline const ::std::string& Employee::transferfirstname() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.Employee.TransferFirstName)
  return *transferfirstname_;
}
inline void Employee::set_transferfirstname(const ::std::string& value) {
  set_has_transferfirstname();
  if (transferfirstname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    transferfirstname_ = new ::std::string;
  }
  transferfirstname_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.Employee.TransferFirstName)
}
inline void Employee::set_transferfirstname(const char* value) {
  set_has_transferfirstname();
  if (transferfirstname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    transferfirstname_ = new ::std::string;
  }
  transferfirstname_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.Employee.TransferFirstName)
}
inline void Employee::set_transferfirstname(const char* value, size_t size) {
  set_has_transferfirstname();
  if (transferfirstname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    transferfirstname_ = new ::std::string;
  }
  transferfirstname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.Employee.TransferFirstName)
}
inline ::std::string* Employee::mutable_transferfirstname() {
  set_has_transferfirstname();
  if (transferfirstname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    transferfirstname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.Employee.TransferFirstName)
  return transferfirstname_;
}
inline ::std::string* Employee::release_transferfirstname() {
  clear_has_transferfirstname();
  if (transferfirstname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = transferfirstname_;
    transferfirstname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Employee::set_allocated_transferfirstname(::std::string* transferfirstname) {
  if (transferfirstname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete transferfirstname_;
  }
  if (transferfirstname) {
    set_has_transferfirstname();
    transferfirstname_ = transferfirstname;
  } else {
    clear_has_transferfirstname();
    transferfirstname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.Employee.TransferFirstName)
}

// optional string TransferPatronymic = 6;
inline bool Employee::has_transferpatronymic() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Employee::set_has_transferpatronymic() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Employee::clear_has_transferpatronymic() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Employee::clear_transferpatronymic() {
  if (transferpatronymic_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    transferpatronymic_->clear();
  }
  clear_has_transferpatronymic();
}
inline const ::std::string& Employee::transferpatronymic() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.Employee.TransferPatronymic)
  return *transferpatronymic_;
}
inline void Employee::set_transferpatronymic(const ::std::string& value) {
  set_has_transferpatronymic();
  if (transferpatronymic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    transferpatronymic_ = new ::std::string;
  }
  transferpatronymic_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.Employee.TransferPatronymic)
}
inline void Employee::set_transferpatronymic(const char* value) {
  set_has_transferpatronymic();
  if (transferpatronymic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    transferpatronymic_ = new ::std::string;
  }
  transferpatronymic_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.Employee.TransferPatronymic)
}
inline void Employee::set_transferpatronymic(const char* value, size_t size) {
  set_has_transferpatronymic();
  if (transferpatronymic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    transferpatronymic_ = new ::std::string;
  }
  transferpatronymic_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.Employee.TransferPatronymic)
}
inline ::std::string* Employee::mutable_transferpatronymic() {
  set_has_transferpatronymic();
  if (transferpatronymic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    transferpatronymic_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.Employee.TransferPatronymic)
  return transferpatronymic_;
}
inline ::std::string* Employee::release_transferpatronymic() {
  clear_has_transferpatronymic();
  if (transferpatronymic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = transferpatronymic_;
    transferpatronymic_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Employee::set_allocated_transferpatronymic(::std::string* transferpatronymic) {
  if (transferpatronymic_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete transferpatronymic_;
  }
  if (transferpatronymic) {
    set_has_transferpatronymic();
    transferpatronymic_ = transferpatronymic;
  } else {
    clear_has_transferpatronymic();
    transferpatronymic_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.Employee.TransferPatronymic)
}

// -------------------------------------------------------------------

// OtherIssuer

// optional string TransferEmployeePosition = 1;
inline bool OtherIssuer::has_transferemployeeposition() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OtherIssuer::set_has_transferemployeeposition() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OtherIssuer::clear_has_transferemployeeposition() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OtherIssuer::clear_transferemployeeposition() {
  if (transferemployeeposition_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    transferemployeeposition_->clear();
  }
  clear_has_transferemployeeposition();
}
inline const ::std::string& OtherIssuer::transferemployeeposition() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.OtherIssuer.TransferEmployeePosition)
  return *transferemployeeposition_;
}
inline void OtherIssuer::set_transferemployeeposition(const ::std::string& value) {
  set_has_transferemployeeposition();
  if (transferemployeeposition_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    transferemployeeposition_ = new ::std::string;
  }
  transferemployeeposition_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.OtherIssuer.TransferEmployeePosition)
}
inline void OtherIssuer::set_transferemployeeposition(const char* value) {
  set_has_transferemployeeposition();
  if (transferemployeeposition_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    transferemployeeposition_ = new ::std::string;
  }
  transferemployeeposition_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.OtherIssuer.TransferEmployeePosition)
}
inline void OtherIssuer::set_transferemployeeposition(const char* value, size_t size) {
  set_has_transferemployeeposition();
  if (transferemployeeposition_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    transferemployeeposition_ = new ::std::string;
  }
  transferemployeeposition_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.OtherIssuer.TransferEmployeePosition)
}
inline ::std::string* OtherIssuer::mutable_transferemployeeposition() {
  set_has_transferemployeeposition();
  if (transferemployeeposition_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    transferemployeeposition_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.OtherIssuer.TransferEmployeePosition)
  return transferemployeeposition_;
}
inline ::std::string* OtherIssuer::release_transferemployeeposition() {
  clear_has_transferemployeeposition();
  if (transferemployeeposition_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = transferemployeeposition_;
    transferemployeeposition_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void OtherIssuer::set_allocated_transferemployeeposition(::std::string* transferemployeeposition) {
  if (transferemployeeposition_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete transferemployeeposition_;
  }
  if (transferemployeeposition) {
    set_has_transferemployeeposition();
    transferemployeeposition_ = transferemployeeposition;
  } else {
    clear_has_transferemployeeposition();
    transferemployeeposition_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.OtherIssuer.TransferEmployeePosition)
}

// optional string TransferEmployeeInfo = 2;
inline bool OtherIssuer::has_transferemployeeinfo() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OtherIssuer::set_has_transferemployeeinfo() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OtherIssuer::clear_has_transferemployeeinfo() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OtherIssuer::clear_transferemployeeinfo() {
  if (transferemployeeinfo_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    transferemployeeinfo_->clear();
  }
  clear_has_transferemployeeinfo();
}
inline const ::std::string& OtherIssuer::transferemployeeinfo() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.OtherIssuer.TransferEmployeeInfo)
  return *transferemployeeinfo_;
}
inline void OtherIssuer::set_transferemployeeinfo(const ::std::string& value) {
  set_has_transferemployeeinfo();
  if (transferemployeeinfo_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    transferemployeeinfo_ = new ::std::string;
  }
  transferemployeeinfo_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.OtherIssuer.TransferEmployeeInfo)
}
inline void OtherIssuer::set_transferemployeeinfo(const char* value) {
  set_has_transferemployeeinfo();
  if (transferemployeeinfo_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    transferemployeeinfo_ = new ::std::string;
  }
  transferemployeeinfo_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.OtherIssuer.TransferEmployeeInfo)
}
inline void OtherIssuer::set_transferemployeeinfo(const char* value, size_t size) {
  set_has_transferemployeeinfo();
  if (transferemployeeinfo_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    transferemployeeinfo_ = new ::std::string;
  }
  transferemployeeinfo_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.OtherIssuer.TransferEmployeeInfo)
}
inline ::std::string* OtherIssuer::mutable_transferemployeeinfo() {
  set_has_transferemployeeinfo();
  if (transferemployeeinfo_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    transferemployeeinfo_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.OtherIssuer.TransferEmployeeInfo)
  return transferemployeeinfo_;
}
inline ::std::string* OtherIssuer::release_transferemployeeinfo() {
  clear_has_transferemployeeinfo();
  if (transferemployeeinfo_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = transferemployeeinfo_;
    transferemployeeinfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void OtherIssuer::set_allocated_transferemployeeinfo(::std::string* transferemployeeinfo) {
  if (transferemployeeinfo_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete transferemployeeinfo_;
  }
  if (transferemployeeinfo) {
    set_has_transferemployeeinfo();
    transferemployeeinfo_ = transferemployeeinfo;
  } else {
    clear_has_transferemployeeinfo();
    transferemployeeinfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.OtherIssuer.TransferEmployeeInfo)
}

// optional string TransferOrganizationName = 3;
inline bool OtherIssuer::has_transferorganizationname() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void OtherIssuer::set_has_transferorganizationname() {
  _has_bits_[0] |= 0x00000004u;
}
inline void OtherIssuer::clear_has_transferorganizationname() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void OtherIssuer::clear_transferorganizationname() {
  if (transferorganizationname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    transferorganizationname_->clear();
  }
  clear_has_transferorganizationname();
}
inline const ::std::string& OtherIssuer::transferorganizationname() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.OtherIssuer.TransferOrganizationName)
  return *transferorganizationname_;
}
inline void OtherIssuer::set_transferorganizationname(const ::std::string& value) {
  set_has_transferorganizationname();
  if (transferorganizationname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    transferorganizationname_ = new ::std::string;
  }
  transferorganizationname_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.OtherIssuer.TransferOrganizationName)
}
inline void OtherIssuer::set_transferorganizationname(const char* value) {
  set_has_transferorganizationname();
  if (transferorganizationname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    transferorganizationname_ = new ::std::string;
  }
  transferorganizationname_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.OtherIssuer.TransferOrganizationName)
}
inline void OtherIssuer::set_transferorganizationname(const char* value, size_t size) {
  set_has_transferorganizationname();
  if (transferorganizationname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    transferorganizationname_ = new ::std::string;
  }
  transferorganizationname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.OtherIssuer.TransferOrganizationName)
}
inline ::std::string* OtherIssuer::mutable_transferorganizationname() {
  set_has_transferorganizationname();
  if (transferorganizationname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    transferorganizationname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.OtherIssuer.TransferOrganizationName)
  return transferorganizationname_;
}
inline ::std::string* OtherIssuer::release_transferorganizationname() {
  clear_has_transferorganizationname();
  if (transferorganizationname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = transferorganizationname_;
    transferorganizationname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void OtherIssuer::set_allocated_transferorganizationname(::std::string* transferorganizationname) {
  if (transferorganizationname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete transferorganizationname_;
  }
  if (transferorganizationname) {
    set_has_transferorganizationname();
    transferorganizationname_ = transferorganizationname;
  } else {
    clear_has_transferorganizationname();
    transferorganizationname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.OtherIssuer.TransferOrganizationName)
}

// optional string TransferOrganizationBase = 4;
inline bool OtherIssuer::has_transferorganizationbase() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void OtherIssuer::set_has_transferorganizationbase() {
  _has_bits_[0] |= 0x00000008u;
}
inline void OtherIssuer::clear_has_transferorganizationbase() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void OtherIssuer::clear_transferorganizationbase() {
  if (transferorganizationbase_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    transferorganizationbase_->clear();
  }
  clear_has_transferorganizationbase();
}
inline const ::std::string& OtherIssuer::transferorganizationbase() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.OtherIssuer.TransferOrganizationBase)
  return *transferorganizationbase_;
}
inline void OtherIssuer::set_transferorganizationbase(const ::std::string& value) {
  set_has_transferorganizationbase();
  if (transferorganizationbase_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    transferorganizationbase_ = new ::std::string;
  }
  transferorganizationbase_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.OtherIssuer.TransferOrganizationBase)
}
inline void OtherIssuer::set_transferorganizationbase(const char* value) {
  set_has_transferorganizationbase();
  if (transferorganizationbase_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    transferorganizationbase_ = new ::std::string;
  }
  transferorganizationbase_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.OtherIssuer.TransferOrganizationBase)
}
inline void OtherIssuer::set_transferorganizationbase(const char* value, size_t size) {
  set_has_transferorganizationbase();
  if (transferorganizationbase_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    transferorganizationbase_ = new ::std::string;
  }
  transferorganizationbase_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.OtherIssuer.TransferOrganizationBase)
}
inline ::std::string* OtherIssuer::mutable_transferorganizationbase() {
  set_has_transferorganizationbase();
  if (transferorganizationbase_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    transferorganizationbase_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.OtherIssuer.TransferOrganizationBase)
  return transferorganizationbase_;
}
inline ::std::string* OtherIssuer::release_transferorganizationbase() {
  clear_has_transferorganizationbase();
  if (transferorganizationbase_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = transferorganizationbase_;
    transferorganizationbase_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void OtherIssuer::set_allocated_transferorganizationbase(::std::string* transferorganizationbase) {
  if (transferorganizationbase_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete transferorganizationbase_;
  }
  if (transferorganizationbase) {
    set_has_transferorganizationbase();
    transferorganizationbase_ = transferorganizationbase;
  } else {
    clear_has_transferorganizationbase();
    transferorganizationbase_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.OtherIssuer.TransferOrganizationBase)
}

// optional string TransferEmployeeBase = 5;
inline bool OtherIssuer::has_transferemployeebase() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void OtherIssuer::set_has_transferemployeebase() {
  _has_bits_[0] |= 0x00000010u;
}
inline void OtherIssuer::clear_has_transferemployeebase() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void OtherIssuer::clear_transferemployeebase() {
  if (transferemployeebase_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    transferemployeebase_->clear();
  }
  clear_has_transferemployeebase();
}
inline const ::std::string& OtherIssuer::transferemployeebase() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.OtherIssuer.TransferEmployeeBase)
  return *transferemployeebase_;
}
inline void OtherIssuer::set_transferemployeebase(const ::std::string& value) {
  set_has_transferemployeebase();
  if (transferemployeebase_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    transferemployeebase_ = new ::std::string;
  }
  transferemployeebase_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.OtherIssuer.TransferEmployeeBase)
}
inline void OtherIssuer::set_transferemployeebase(const char* value) {
  set_has_transferemployeebase();
  if (transferemployeebase_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    transferemployeebase_ = new ::std::string;
  }
  transferemployeebase_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.OtherIssuer.TransferEmployeeBase)
}
inline void OtherIssuer::set_transferemployeebase(const char* value, size_t size) {
  set_has_transferemployeebase();
  if (transferemployeebase_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    transferemployeebase_ = new ::std::string;
  }
  transferemployeebase_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.OtherIssuer.TransferEmployeeBase)
}
inline ::std::string* OtherIssuer::mutable_transferemployeebase() {
  set_has_transferemployeebase();
  if (transferemployeebase_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    transferemployeebase_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.OtherIssuer.TransferEmployeeBase)
  return transferemployeebase_;
}
inline ::std::string* OtherIssuer::release_transferemployeebase() {
  clear_has_transferemployeebase();
  if (transferemployeebase_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = transferemployeebase_;
    transferemployeebase_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void OtherIssuer::set_allocated_transferemployeebase(::std::string* transferemployeebase) {
  if (transferemployeebase_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete transferemployeebase_;
  }
  if (transferemployeebase) {
    set_has_transferemployeebase();
    transferemployeebase_ = transferemployeebase;
  } else {
    clear_has_transferemployeebase();
    transferemployeebase_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.OtherIssuer.TransferEmployeeBase)
}

// required string TransferSurname = 6;
inline bool OtherIssuer::has_transfersurname() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void OtherIssuer::set_has_transfersurname() {
  _has_bits_[0] |= 0x00000020u;
}
inline void OtherIssuer::clear_has_transfersurname() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void OtherIssuer::clear_transfersurname() {
  if (transfersurname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    transfersurname_->clear();
  }
  clear_has_transfersurname();
}
inline const ::std::string& OtherIssuer::transfersurname() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.OtherIssuer.TransferSurname)
  return *transfersurname_;
}
inline void OtherIssuer::set_transfersurname(const ::std::string& value) {
  set_has_transfersurname();
  if (transfersurname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    transfersurname_ = new ::std::string;
  }
  transfersurname_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.OtherIssuer.TransferSurname)
}
inline void OtherIssuer::set_transfersurname(const char* value) {
  set_has_transfersurname();
  if (transfersurname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    transfersurname_ = new ::std::string;
  }
  transfersurname_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.OtherIssuer.TransferSurname)
}
inline void OtherIssuer::set_transfersurname(const char* value, size_t size) {
  set_has_transfersurname();
  if (transfersurname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    transfersurname_ = new ::std::string;
  }
  transfersurname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.OtherIssuer.TransferSurname)
}
inline ::std::string* OtherIssuer::mutable_transfersurname() {
  set_has_transfersurname();
  if (transfersurname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    transfersurname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.OtherIssuer.TransferSurname)
  return transfersurname_;
}
inline ::std::string* OtherIssuer::release_transfersurname() {
  clear_has_transfersurname();
  if (transfersurname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = transfersurname_;
    transfersurname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void OtherIssuer::set_allocated_transfersurname(::std::string* transfersurname) {
  if (transfersurname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete transfersurname_;
  }
  if (transfersurname) {
    set_has_transfersurname();
    transfersurname_ = transfersurname;
  } else {
    clear_has_transfersurname();
    transfersurname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.OtherIssuer.TransferSurname)
}

// required string TransferFirstName = 7;
inline bool OtherIssuer::has_transferfirstname() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void OtherIssuer::set_has_transferfirstname() {
  _has_bits_[0] |= 0x00000040u;
}
inline void OtherIssuer::clear_has_transferfirstname() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void OtherIssuer::clear_transferfirstname() {
  if (transferfirstname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    transferfirstname_->clear();
  }
  clear_has_transferfirstname();
}
inline const ::std::string& OtherIssuer::transferfirstname() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.OtherIssuer.TransferFirstName)
  return *transferfirstname_;
}
inline void OtherIssuer::set_transferfirstname(const ::std::string& value) {
  set_has_transferfirstname();
  if (transferfirstname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    transferfirstname_ = new ::std::string;
  }
  transferfirstname_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.OtherIssuer.TransferFirstName)
}
inline void OtherIssuer::set_transferfirstname(const char* value) {
  set_has_transferfirstname();
  if (transferfirstname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    transferfirstname_ = new ::std::string;
  }
  transferfirstname_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.OtherIssuer.TransferFirstName)
}
inline void OtherIssuer::set_transferfirstname(const char* value, size_t size) {
  set_has_transferfirstname();
  if (transferfirstname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    transferfirstname_ = new ::std::string;
  }
  transferfirstname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.OtherIssuer.TransferFirstName)
}
inline ::std::string* OtherIssuer::mutable_transferfirstname() {
  set_has_transferfirstname();
  if (transferfirstname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    transferfirstname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.OtherIssuer.TransferFirstName)
  return transferfirstname_;
}
inline ::std::string* OtherIssuer::release_transferfirstname() {
  clear_has_transferfirstname();
  if (transferfirstname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = transferfirstname_;
    transferfirstname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void OtherIssuer::set_allocated_transferfirstname(::std::string* transferfirstname) {
  if (transferfirstname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete transferfirstname_;
  }
  if (transferfirstname) {
    set_has_transferfirstname();
    transferfirstname_ = transferfirstname;
  } else {
    clear_has_transferfirstname();
    transferfirstname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.OtherIssuer.TransferFirstName)
}

// optional string TransferPatronymic = 8;
inline bool OtherIssuer::has_transferpatronymic() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void OtherIssuer::set_has_transferpatronymic() {
  _has_bits_[0] |= 0x00000080u;
}
inline void OtherIssuer::clear_has_transferpatronymic() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void OtherIssuer::clear_transferpatronymic() {
  if (transferpatronymic_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    transferpatronymic_->clear();
  }
  clear_has_transferpatronymic();
}
inline const ::std::string& OtherIssuer::transferpatronymic() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.OtherIssuer.TransferPatronymic)
  return *transferpatronymic_;
}
inline void OtherIssuer::set_transferpatronymic(const ::std::string& value) {
  set_has_transferpatronymic();
  if (transferpatronymic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    transferpatronymic_ = new ::std::string;
  }
  transferpatronymic_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.OtherIssuer.TransferPatronymic)
}
inline void OtherIssuer::set_transferpatronymic(const char* value) {
  set_has_transferpatronymic();
  if (transferpatronymic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    transferpatronymic_ = new ::std::string;
  }
  transferpatronymic_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.OtherIssuer.TransferPatronymic)
}
inline void OtherIssuer::set_transferpatronymic(const char* value, size_t size) {
  set_has_transferpatronymic();
  if (transferpatronymic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    transferpatronymic_ = new ::std::string;
  }
  transferpatronymic_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.OtherIssuer.TransferPatronymic)
}
inline ::std::string* OtherIssuer::mutable_transferpatronymic() {
  set_has_transferpatronymic();
  if (transferpatronymic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    transferpatronymic_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.OtherIssuer.TransferPatronymic)
  return transferpatronymic_;
}
inline ::std::string* OtherIssuer::release_transferpatronymic() {
  clear_has_transferpatronymic();
  if (transferpatronymic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = transferpatronymic_;
    transferpatronymic_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void OtherIssuer::set_allocated_transferpatronymic(::std::string* transferpatronymic) {
  if (transferpatronymic_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete transferpatronymic_;
  }
  if (transferpatronymic) {
    set_has_transferpatronymic();
    transferpatronymic_ = transferpatronymic;
  } else {
    clear_has_transferpatronymic();
    transferpatronymic_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.OtherIssuer.TransferPatronymic)
}

// -------------------------------------------------------------------

// AdditionalInfoId

// optional string InfoFileId = 1;
inline bool AdditionalInfoId::has_infofileid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AdditionalInfoId::set_has_infofileid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AdditionalInfoId::clear_has_infofileid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AdditionalInfoId::clear_infofileid() {
  if (infofileid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    infofileid_->clear();
  }
  clear_has_infofileid();
}
inline const ::std::string& AdditionalInfoId::infofileid() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.AdditionalInfoId.InfoFileId)
  return *infofileid_;
}
inline void AdditionalInfoId::set_infofileid(const ::std::string& value) {
  set_has_infofileid();
  if (infofileid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    infofileid_ = new ::std::string;
  }
  infofileid_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.AdditionalInfoId.InfoFileId)
}
inline void AdditionalInfoId::set_infofileid(const char* value) {
  set_has_infofileid();
  if (infofileid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    infofileid_ = new ::std::string;
  }
  infofileid_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.AdditionalInfoId.InfoFileId)
}
inline void AdditionalInfoId::set_infofileid(const char* value, size_t size) {
  set_has_infofileid();
  if (infofileid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    infofileid_ = new ::std::string;
  }
  infofileid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.AdditionalInfoId.InfoFileId)
}
inline ::std::string* AdditionalInfoId::mutable_infofileid() {
  set_has_infofileid();
  if (infofileid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    infofileid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.AdditionalInfoId.InfoFileId)
  return infofileid_;
}
inline ::std::string* AdditionalInfoId::release_infofileid() {
  clear_has_infofileid();
  if (infofileid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = infofileid_;
    infofileid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AdditionalInfoId::set_allocated_infofileid(::std::string* infofileid) {
  if (infofileid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete infofileid_;
  }
  if (infofileid) {
    set_has_infofileid();
    infofileid_ = infofileid;
  } else {
    clear_has_infofileid();
    infofileid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.AdditionalInfoId.InfoFileId)
}

// repeated .Diadoc.Api.Proto.Invoicing.AdditionalInfo AdditionalInfo = 2;
inline int AdditionalInfoId::additionalinfo_size() const {
  return additionalinfo_.size();
}
inline void AdditionalInfoId::clear_additionalinfo() {
  additionalinfo_.Clear();
}
inline const ::Diadoc::Api::Proto::Invoicing::AdditionalInfo& AdditionalInfoId::additionalinfo(int index) const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.AdditionalInfoId.AdditionalInfo)
  return additionalinfo_.Get(index);
}
inline ::Diadoc::Api::Proto::Invoicing::AdditionalInfo* AdditionalInfoId::mutable_additionalinfo(int index) {
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.AdditionalInfoId.AdditionalInfo)
  return additionalinfo_.Mutable(index);
}
inline ::Diadoc::Api::Proto::Invoicing::AdditionalInfo* AdditionalInfoId::add_additionalinfo() {
  // @@protoc_insertion_point(field_add:Diadoc.Api.Proto.Invoicing.AdditionalInfoId.AdditionalInfo)
  return additionalinfo_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::AdditionalInfo >&
AdditionalInfoId::additionalinfo() const {
  // @@protoc_insertion_point(field_list:Diadoc.Api.Proto.Invoicing.AdditionalInfoId.AdditionalInfo)
  return additionalinfo_;
}
inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::AdditionalInfo >*
AdditionalInfoId::mutable_additionalinfo() {
  // @@protoc_insertion_point(field_mutable_list:Diadoc.Api.Proto.Invoicing.AdditionalInfoId.AdditionalInfo)
  return &additionalinfo_;
}

// -------------------------------------------------------------------

// UniversalTransferDocumentBuyerTitleInfo

// required string DocumentCreator = 1;
inline bool UniversalTransferDocumentBuyerTitleInfo::has_documentcreator() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UniversalTransferDocumentBuyerTitleInfo::set_has_documentcreator() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UniversalTransferDocumentBuyerTitleInfo::clear_has_documentcreator() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UniversalTransferDocumentBuyerTitleInfo::clear_documentcreator() {
  if (documentcreator_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    documentcreator_->clear();
  }
  clear_has_documentcreator();
}
inline const ::std::string& UniversalTransferDocumentBuyerTitleInfo::documentcreator() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.UniversalTransferDocumentBuyerTitleInfo.DocumentCreator)
  return *documentcreator_;
}
inline void UniversalTransferDocumentBuyerTitleInfo::set_documentcreator(const ::std::string& value) {
  set_has_documentcreator();
  if (documentcreator_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    documentcreator_ = new ::std::string;
  }
  documentcreator_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.UniversalTransferDocumentBuyerTitleInfo.DocumentCreator)
}
inline void UniversalTransferDocumentBuyerTitleInfo::set_documentcreator(const char* value) {
  set_has_documentcreator();
  if (documentcreator_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    documentcreator_ = new ::std::string;
  }
  documentcreator_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.UniversalTransferDocumentBuyerTitleInfo.DocumentCreator)
}
inline void UniversalTransferDocumentBuyerTitleInfo::set_documentcreator(const char* value, size_t size) {
  set_has_documentcreator();
  if (documentcreator_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    documentcreator_ = new ::std::string;
  }
  documentcreator_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.UniversalTransferDocumentBuyerTitleInfo.DocumentCreator)
}
inline ::std::string* UniversalTransferDocumentBuyerTitleInfo::mutable_documentcreator() {
  set_has_documentcreator();
  if (documentcreator_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    documentcreator_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.UniversalTransferDocumentBuyerTitleInfo.DocumentCreator)
  return documentcreator_;
}
inline ::std::string* UniversalTransferDocumentBuyerTitleInfo::release_documentcreator() {
  clear_has_documentcreator();
  if (documentcreator_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = documentcreator_;
    documentcreator_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UniversalTransferDocumentBuyerTitleInfo::set_allocated_documentcreator(::std::string* documentcreator) {
  if (documentcreator_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete documentcreator_;
  }
  if (documentcreator) {
    set_has_documentcreator();
    documentcreator_ = documentcreator;
  } else {
    clear_has_documentcreator();
    documentcreator_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.UniversalTransferDocumentBuyerTitleInfo.DocumentCreator)
}

// optional string DocumentCreatorBase = 2;
inline bool UniversalTransferDocumentBuyerTitleInfo::has_documentcreatorbase() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UniversalTransferDocumentBuyerTitleInfo::set_has_documentcreatorbase() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UniversalTransferDocumentBuyerTitleInfo::clear_has_documentcreatorbase() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UniversalTransferDocumentBuyerTitleInfo::clear_documentcreatorbase() {
  if (documentcreatorbase_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    documentcreatorbase_->clear();
  }
  clear_has_documentcreatorbase();
}
inline const ::std::string& UniversalTransferDocumentBuyerTitleInfo::documentcreatorbase() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.UniversalTransferDocumentBuyerTitleInfo.DocumentCreatorBase)
  return *documentcreatorbase_;
}
inline void UniversalTransferDocumentBuyerTitleInfo::set_documentcreatorbase(const ::std::string& value) {
  set_has_documentcreatorbase();
  if (documentcreatorbase_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    documentcreatorbase_ = new ::std::string;
  }
  documentcreatorbase_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.UniversalTransferDocumentBuyerTitleInfo.DocumentCreatorBase)
}
inline void UniversalTransferDocumentBuyerTitleInfo::set_documentcreatorbase(const char* value) {
  set_has_documentcreatorbase();
  if (documentcreatorbase_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    documentcreatorbase_ = new ::std::string;
  }
  documentcreatorbase_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.UniversalTransferDocumentBuyerTitleInfo.DocumentCreatorBase)
}
inline void UniversalTransferDocumentBuyerTitleInfo::set_documentcreatorbase(const char* value, size_t size) {
  set_has_documentcreatorbase();
  if (documentcreatorbase_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    documentcreatorbase_ = new ::std::string;
  }
  documentcreatorbase_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.UniversalTransferDocumentBuyerTitleInfo.DocumentCreatorBase)
}
inline ::std::string* UniversalTransferDocumentBuyerTitleInfo::mutable_documentcreatorbase() {
  set_has_documentcreatorbase();
  if (documentcreatorbase_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    documentcreatorbase_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.UniversalTransferDocumentBuyerTitleInfo.DocumentCreatorBase)
  return documentcreatorbase_;
}
inline ::std::string* UniversalTransferDocumentBuyerTitleInfo::release_documentcreatorbase() {
  clear_has_documentcreatorbase();
  if (documentcreatorbase_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = documentcreatorbase_;
    documentcreatorbase_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UniversalTransferDocumentBuyerTitleInfo::set_allocated_documentcreatorbase(::std::string* documentcreatorbase) {
  if (documentcreatorbase_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete documentcreatorbase_;
  }
  if (documentcreatorbase) {
    set_has_documentcreatorbase();
    documentcreatorbase_ = documentcreatorbase;
  } else {
    clear_has_documentcreatorbase();
    documentcreatorbase_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.UniversalTransferDocumentBuyerTitleInfo.DocumentCreatorBase)
}

// optional string OperationCode = 3;
inline bool UniversalTransferDocumentBuyerTitleInfo::has_operationcode() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UniversalTransferDocumentBuyerTitleInfo::set_has_operationcode() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UniversalTransferDocumentBuyerTitleInfo::clear_has_operationcode() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UniversalTransferDocumentBuyerTitleInfo::clear_operationcode() {
  if (operationcode_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    operationcode_->clear();
  }
  clear_has_operationcode();
}
inline const ::std::string& UniversalTransferDocumentBuyerTitleInfo::operationcode() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.UniversalTransferDocumentBuyerTitleInfo.OperationCode)
  return *operationcode_;
}
inline void UniversalTransferDocumentBuyerTitleInfo::set_operationcode(const ::std::string& value) {
  set_has_operationcode();
  if (operationcode_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    operationcode_ = new ::std::string;
  }
  operationcode_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.UniversalTransferDocumentBuyerTitleInfo.OperationCode)
}
inline void UniversalTransferDocumentBuyerTitleInfo::set_operationcode(const char* value) {
  set_has_operationcode();
  if (operationcode_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    operationcode_ = new ::std::string;
  }
  operationcode_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.UniversalTransferDocumentBuyerTitleInfo.OperationCode)
}
inline void UniversalTransferDocumentBuyerTitleInfo::set_operationcode(const char* value, size_t size) {
  set_has_operationcode();
  if (operationcode_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    operationcode_ = new ::std::string;
  }
  operationcode_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.UniversalTransferDocumentBuyerTitleInfo.OperationCode)
}
inline ::std::string* UniversalTransferDocumentBuyerTitleInfo::mutable_operationcode() {
  set_has_operationcode();
  if (operationcode_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    operationcode_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.UniversalTransferDocumentBuyerTitleInfo.OperationCode)
  return operationcode_;
}
inline ::std::string* UniversalTransferDocumentBuyerTitleInfo::release_operationcode() {
  clear_has_operationcode();
  if (operationcode_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = operationcode_;
    operationcode_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UniversalTransferDocumentBuyerTitleInfo::set_allocated_operationcode(::std::string* operationcode) {
  if (operationcode_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete operationcode_;
  }
  if (operationcode) {
    set_has_operationcode();
    operationcode_ = operationcode;
  } else {
    clear_has_operationcode();
    operationcode_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.UniversalTransferDocumentBuyerTitleInfo.OperationCode)
}

// required string OperationContent = 4;
inline bool UniversalTransferDocumentBuyerTitleInfo::has_operationcontent() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UniversalTransferDocumentBuyerTitleInfo::set_has_operationcontent() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UniversalTransferDocumentBuyerTitleInfo::clear_has_operationcontent() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UniversalTransferDocumentBuyerTitleInfo::clear_operationcontent() {
  if (operationcontent_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    operationcontent_->clear();
  }
  clear_has_operationcontent();
}
inline const ::std::string& UniversalTransferDocumentBuyerTitleInfo::operationcontent() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.UniversalTransferDocumentBuyerTitleInfo.OperationContent)
  return *operationcontent_;
}
inline void UniversalTransferDocumentBuyerTitleInfo::set_operationcontent(const ::std::string& value) {
  set_has_operationcontent();
  if (operationcontent_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    operationcontent_ = new ::std::string;
  }
  operationcontent_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.UniversalTransferDocumentBuyerTitleInfo.OperationContent)
}
inline void UniversalTransferDocumentBuyerTitleInfo::set_operationcontent(const char* value) {
  set_has_operationcontent();
  if (operationcontent_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    operationcontent_ = new ::std::string;
  }
  operationcontent_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.UniversalTransferDocumentBuyerTitleInfo.OperationContent)
}
inline void UniversalTransferDocumentBuyerTitleInfo::set_operationcontent(const char* value, size_t size) {
  set_has_operationcontent();
  if (operationcontent_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    operationcontent_ = new ::std::string;
  }
  operationcontent_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.UniversalTransferDocumentBuyerTitleInfo.OperationContent)
}
inline ::std::string* UniversalTransferDocumentBuyerTitleInfo::mutable_operationcontent() {
  set_has_operationcontent();
  if (operationcontent_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    operationcontent_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.UniversalTransferDocumentBuyerTitleInfo.OperationContent)
  return operationcontent_;
}
inline ::std::string* UniversalTransferDocumentBuyerTitleInfo::release_operationcontent() {
  clear_has_operationcontent();
  if (operationcontent_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = operationcontent_;
    operationcontent_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UniversalTransferDocumentBuyerTitleInfo::set_allocated_operationcontent(::std::string* operationcontent) {
  if (operationcontent_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete operationcontent_;
  }
  if (operationcontent) {
    set_has_operationcontent();
    operationcontent_ = operationcontent;
  } else {
    clear_has_operationcontent();
    operationcontent_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.UniversalTransferDocumentBuyerTitleInfo.OperationContent)
}

// optional string AcceptanceDate = 5;
inline bool UniversalTransferDocumentBuyerTitleInfo::has_acceptancedate() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UniversalTransferDocumentBuyerTitleInfo::set_has_acceptancedate() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UniversalTransferDocumentBuyerTitleInfo::clear_has_acceptancedate() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UniversalTransferDocumentBuyerTitleInfo::clear_acceptancedate() {
  if (acceptancedate_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    acceptancedate_->clear();
  }
  clear_has_acceptancedate();
}
inline const ::std::string& UniversalTransferDocumentBuyerTitleInfo::acceptancedate() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.UniversalTransferDocumentBuyerTitleInfo.AcceptanceDate)
  return *acceptancedate_;
}
inline void UniversalTransferDocumentBuyerTitleInfo::set_acceptancedate(const ::std::string& value) {
  set_has_acceptancedate();
  if (acceptancedate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    acceptancedate_ = new ::std::string;
  }
  acceptancedate_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.UniversalTransferDocumentBuyerTitleInfo.AcceptanceDate)
}
inline void UniversalTransferDocumentBuyerTitleInfo::set_acceptancedate(const char* value) {
  set_has_acceptancedate();
  if (acceptancedate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    acceptancedate_ = new ::std::string;
  }
  acceptancedate_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.UniversalTransferDocumentBuyerTitleInfo.AcceptanceDate)
}
inline void UniversalTransferDocumentBuyerTitleInfo::set_acceptancedate(const char* value, size_t size) {
  set_has_acceptancedate();
  if (acceptancedate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    acceptancedate_ = new ::std::string;
  }
  acceptancedate_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.UniversalTransferDocumentBuyerTitleInfo.AcceptanceDate)
}
inline ::std::string* UniversalTransferDocumentBuyerTitleInfo::mutable_acceptancedate() {
  set_has_acceptancedate();
  if (acceptancedate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    acceptancedate_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.UniversalTransferDocumentBuyerTitleInfo.AcceptanceDate)
  return acceptancedate_;
}
inline ::std::string* UniversalTransferDocumentBuyerTitleInfo::release_acceptancedate() {
  clear_has_acceptancedate();
  if (acceptancedate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = acceptancedate_;
    acceptancedate_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UniversalTransferDocumentBuyerTitleInfo::set_allocated_acceptancedate(::std::string* acceptancedate) {
  if (acceptancedate_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete acceptancedate_;
  }
  if (acceptancedate) {
    set_has_acceptancedate();
    acceptancedate_ = acceptancedate;
  } else {
    clear_has_acceptancedate();
    acceptancedate_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.UniversalTransferDocumentBuyerTitleInfo.AcceptanceDate)
}

// optional .Diadoc.Api.Proto.Invoicing.Employee Employee = 6;
inline bool UniversalTransferDocumentBuyerTitleInfo::has_employee() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UniversalTransferDocumentBuyerTitleInfo::set_has_employee() {
  _has_bits_[0] |= 0x00000020u;
}
inline void UniversalTransferDocumentBuyerTitleInfo::clear_has_employee() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void UniversalTransferDocumentBuyerTitleInfo::clear_employee() {
  if (employee_ != NULL) employee_->::Diadoc::Api::Proto::Invoicing::Employee::Clear();
  clear_has_employee();
}
inline const ::Diadoc::Api::Proto::Invoicing::Employee& UniversalTransferDocumentBuyerTitleInfo::employee() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.UniversalTransferDocumentBuyerTitleInfo.Employee)
  return employee_ != NULL ? *employee_ : *default_instance_->employee_;
}
inline ::Diadoc::Api::Proto::Invoicing::Employee* UniversalTransferDocumentBuyerTitleInfo::mutable_employee() {
  set_has_employee();
  if (employee_ == NULL) employee_ = new ::Diadoc::Api::Proto::Invoicing::Employee;
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.UniversalTransferDocumentBuyerTitleInfo.Employee)
  return employee_;
}
inline ::Diadoc::Api::Proto::Invoicing::Employee* UniversalTransferDocumentBuyerTitleInfo::release_employee() {
  clear_has_employee();
  ::Diadoc::Api::Proto::Invoicing::Employee* temp = employee_;
  employee_ = NULL;
  return temp;
}
inline void UniversalTransferDocumentBuyerTitleInfo::set_allocated_employee(::Diadoc::Api::Proto::Invoicing::Employee* employee) {
  delete employee_;
  employee_ = employee;
  if (employee) {
    set_has_employee();
  } else {
    clear_has_employee();
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.UniversalTransferDocumentBuyerTitleInfo.Employee)
}

// optional .Diadoc.Api.Proto.Invoicing.OtherIssuer OtherIssuer = 7;
inline bool UniversalTransferDocumentBuyerTitleInfo::has_otherissuer() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void UniversalTransferDocumentBuyerTitleInfo::set_has_otherissuer() {
  _has_bits_[0] |= 0x00000040u;
}
inline void UniversalTransferDocumentBuyerTitleInfo::clear_has_otherissuer() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void UniversalTransferDocumentBuyerTitleInfo::clear_otherissuer() {
  if (otherissuer_ != NULL) otherissuer_->::Diadoc::Api::Proto::Invoicing::OtherIssuer::Clear();
  clear_has_otherissuer();
}
inline const ::Diadoc::Api::Proto::Invoicing::OtherIssuer& UniversalTransferDocumentBuyerTitleInfo::otherissuer() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.UniversalTransferDocumentBuyerTitleInfo.OtherIssuer)
  return otherissuer_ != NULL ? *otherissuer_ : *default_instance_->otherissuer_;
}
inline ::Diadoc::Api::Proto::Invoicing::OtherIssuer* UniversalTransferDocumentBuyerTitleInfo::mutable_otherissuer() {
  set_has_otherissuer();
  if (otherissuer_ == NULL) otherissuer_ = new ::Diadoc::Api::Proto::Invoicing::OtherIssuer;
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.UniversalTransferDocumentBuyerTitleInfo.OtherIssuer)
  return otherissuer_;
}
inline ::Diadoc::Api::Proto::Invoicing::OtherIssuer* UniversalTransferDocumentBuyerTitleInfo::release_otherissuer() {
  clear_has_otherissuer();
  ::Diadoc::Api::Proto::Invoicing::OtherIssuer* temp = otherissuer_;
  otherissuer_ = NULL;
  return temp;
}
inline void UniversalTransferDocumentBuyerTitleInfo::set_allocated_otherissuer(::Diadoc::Api::Proto::Invoicing::OtherIssuer* otherissuer) {
  delete otherissuer_;
  otherissuer_ = otherissuer;
  if (otherissuer) {
    set_has_otherissuer();
  } else {
    clear_has_otherissuer();
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.UniversalTransferDocumentBuyerTitleInfo.OtherIssuer)
}

// optional .Diadoc.Api.Proto.Invoicing.AdditionalInfoId AdditionalInfoId = 8;
inline bool UniversalTransferDocumentBuyerTitleInfo::has_additionalinfoid() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void UniversalTransferDocumentBuyerTitleInfo::set_has_additionalinfoid() {
  _has_bits_[0] |= 0x00000080u;
}
inline void UniversalTransferDocumentBuyerTitleInfo::clear_has_additionalinfoid() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void UniversalTransferDocumentBuyerTitleInfo::clear_additionalinfoid() {
  if (additionalinfoid_ != NULL) additionalinfoid_->::Diadoc::Api::Proto::Invoicing::AdditionalInfoId::Clear();
  clear_has_additionalinfoid();
}
inline const ::Diadoc::Api::Proto::Invoicing::AdditionalInfoId& UniversalTransferDocumentBuyerTitleInfo::additionalinfoid() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.UniversalTransferDocumentBuyerTitleInfo.AdditionalInfoId)
  return additionalinfoid_ != NULL ? *additionalinfoid_ : *default_instance_->additionalinfoid_;
}
inline ::Diadoc::Api::Proto::Invoicing::AdditionalInfoId* UniversalTransferDocumentBuyerTitleInfo::mutable_additionalinfoid() {
  set_has_additionalinfoid();
  if (additionalinfoid_ == NULL) additionalinfoid_ = new ::Diadoc::Api::Proto::Invoicing::AdditionalInfoId;
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.UniversalTransferDocumentBuyerTitleInfo.AdditionalInfoId)
  return additionalinfoid_;
}
inline ::Diadoc::Api::Proto::Invoicing::AdditionalInfoId* UniversalTransferDocumentBuyerTitleInfo::release_additionalinfoid() {
  clear_has_additionalinfoid();
  ::Diadoc::Api::Proto::Invoicing::AdditionalInfoId* temp = additionalinfoid_;
  additionalinfoid_ = NULL;
  return temp;
}
inline void UniversalTransferDocumentBuyerTitleInfo::set_allocated_additionalinfoid(::Diadoc::Api::Proto::Invoicing::AdditionalInfoId* additionalinfoid) {
  delete additionalinfoid_;
  additionalinfoid_ = additionalinfoid;
  if (additionalinfoid) {
    set_has_additionalinfoid();
  } else {
    clear_has_additionalinfoid();
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.UniversalTransferDocumentBuyerTitleInfo.AdditionalInfoId)
}

// repeated .Diadoc.Api.Proto.Invoicing.Signers.ExtendedSigner Signers = 9;
inline int UniversalTransferDocumentBuyerTitleInfo::signers_size() const {
  return signers_.size();
}
inline void UniversalTransferDocumentBuyerTitleInfo::clear_signers() {
  signers_.Clear();
}
inline const ::Diadoc::Api::Proto::Invoicing::Signers::ExtendedSigner& UniversalTransferDocumentBuyerTitleInfo::signers(int index) const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.UniversalTransferDocumentBuyerTitleInfo.Signers)
  return signers_.Get(index);
}
inline ::Diadoc::Api::Proto::Invoicing::Signers::ExtendedSigner* UniversalTransferDocumentBuyerTitleInfo::mutable_signers(int index) {
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.UniversalTransferDocumentBuyerTitleInfo.Signers)
  return signers_.Mutable(index);
}
inline ::Diadoc::Api::Proto::Invoicing::Signers::ExtendedSigner* UniversalTransferDocumentBuyerTitleInfo::add_signers() {
  // @@protoc_insertion_point(field_add:Diadoc.Api.Proto.Invoicing.UniversalTransferDocumentBuyerTitleInfo.Signers)
  return signers_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::Signers::ExtendedSigner >&
UniversalTransferDocumentBuyerTitleInfo::signers() const {
  // @@protoc_insertion_point(field_list:Diadoc.Api.Proto.Invoicing.UniversalTransferDocumentBuyerTitleInfo.Signers)
  return signers_;
}
inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::Signers::ExtendedSigner >*
UniversalTransferDocumentBuyerTitleInfo::mutable_signers() {
  // @@protoc_insertion_point(field_mutable_list:Diadoc.Api.Proto.Invoicing.UniversalTransferDocumentBuyerTitleInfo.Signers)
  return &signers_;
}

// -------------------------------------------------------------------

// UniversalCorrectionDocumentSellerTitleInfo

// required .Diadoc.Api.Proto.Invoicing.FunctionType Function = 1;
inline bool UniversalCorrectionDocumentSellerTitleInfo::has_function() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UniversalCorrectionDocumentSellerTitleInfo::set_has_function() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UniversalCorrectionDocumentSellerTitleInfo::clear_has_function() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UniversalCorrectionDocumentSellerTitleInfo::clear_function() {
  function_ = 0;
  clear_has_function();
}
inline ::Diadoc::Api::Proto::Invoicing::FunctionType UniversalCorrectionDocumentSellerTitleInfo::function() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.UniversalCorrectionDocumentSellerTitleInfo.Function)
  return static_cast< ::Diadoc::Api::Proto::Invoicing::FunctionType >(function_);
}
inline void UniversalCorrectionDocumentSellerTitleInfo::set_function(::Diadoc::Api::Proto::Invoicing::FunctionType value) {
  assert(::Diadoc::Api::Proto::Invoicing::FunctionType_IsValid(value));
  set_has_function();
  function_ = value;
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.UniversalCorrectionDocumentSellerTitleInfo.Function)
}

// optional string DocumentName = 2;
inline bool UniversalCorrectionDocumentSellerTitleInfo::has_documentname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UniversalCorrectionDocumentSellerTitleInfo::set_has_documentname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UniversalCorrectionDocumentSellerTitleInfo::clear_has_documentname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UniversalCorrectionDocumentSellerTitleInfo::clear_documentname() {
  if (documentname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    documentname_->clear();
  }
  clear_has_documentname();
}
inline const ::std::string& UniversalCorrectionDocumentSellerTitleInfo::documentname() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.UniversalCorrectionDocumentSellerTitleInfo.DocumentName)
  return *documentname_;
}
inline void UniversalCorrectionDocumentSellerTitleInfo::set_documentname(const ::std::string& value) {
  set_has_documentname();
  if (documentname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    documentname_ = new ::std::string;
  }
  documentname_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.UniversalCorrectionDocumentSellerTitleInfo.DocumentName)
}
inline void UniversalCorrectionDocumentSellerTitleInfo::set_documentname(const char* value) {
  set_has_documentname();
  if (documentname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    documentname_ = new ::std::string;
  }
  documentname_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.UniversalCorrectionDocumentSellerTitleInfo.DocumentName)
}
inline void UniversalCorrectionDocumentSellerTitleInfo::set_documentname(const char* value, size_t size) {
  set_has_documentname();
  if (documentname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    documentname_ = new ::std::string;
  }
  documentname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.UniversalCorrectionDocumentSellerTitleInfo.DocumentName)
}
inline ::std::string* UniversalCorrectionDocumentSellerTitleInfo::mutable_documentname() {
  set_has_documentname();
  if (documentname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    documentname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.UniversalCorrectionDocumentSellerTitleInfo.DocumentName)
  return documentname_;
}
inline ::std::string* UniversalCorrectionDocumentSellerTitleInfo::release_documentname() {
  clear_has_documentname();
  if (documentname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = documentname_;
    documentname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UniversalCorrectionDocumentSellerTitleInfo::set_allocated_documentname(::std::string* documentname) {
  if (documentname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete documentname_;
  }
  if (documentname) {
    set_has_documentname();
    documentname_ = documentname;
  } else {
    clear_has_documentname();
    documentname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.UniversalCorrectionDocumentSellerTitleInfo.DocumentName)
}

// required string DocumentDate = 3;
inline bool UniversalCorrectionDocumentSellerTitleInfo::has_documentdate() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UniversalCorrectionDocumentSellerTitleInfo::set_has_documentdate() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UniversalCorrectionDocumentSellerTitleInfo::clear_has_documentdate() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UniversalCorrectionDocumentSellerTitleInfo::clear_documentdate() {
  if (documentdate_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    documentdate_->clear();
  }
  clear_has_documentdate();
}
inline const ::std::string& UniversalCorrectionDocumentSellerTitleInfo::documentdate() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.UniversalCorrectionDocumentSellerTitleInfo.DocumentDate)
  return *documentdate_;
}
inline void UniversalCorrectionDocumentSellerTitleInfo::set_documentdate(const ::std::string& value) {
  set_has_documentdate();
  if (documentdate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    documentdate_ = new ::std::string;
  }
  documentdate_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.UniversalCorrectionDocumentSellerTitleInfo.DocumentDate)
}
inline void UniversalCorrectionDocumentSellerTitleInfo::set_documentdate(const char* value) {
  set_has_documentdate();
  if (documentdate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    documentdate_ = new ::std::string;
  }
  documentdate_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.UniversalCorrectionDocumentSellerTitleInfo.DocumentDate)
}
inline void UniversalCorrectionDocumentSellerTitleInfo::set_documentdate(const char* value, size_t size) {
  set_has_documentdate();
  if (documentdate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    documentdate_ = new ::std::string;
  }
  documentdate_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.UniversalCorrectionDocumentSellerTitleInfo.DocumentDate)
}
inline ::std::string* UniversalCorrectionDocumentSellerTitleInfo::mutable_documentdate() {
  set_has_documentdate();
  if (documentdate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    documentdate_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.UniversalCorrectionDocumentSellerTitleInfo.DocumentDate)
  return documentdate_;
}
inline ::std::string* UniversalCorrectionDocumentSellerTitleInfo::release_documentdate() {
  clear_has_documentdate();
  if (documentdate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = documentdate_;
    documentdate_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UniversalCorrectionDocumentSellerTitleInfo::set_allocated_documentdate(::std::string* documentdate) {
  if (documentdate_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete documentdate_;
  }
  if (documentdate) {
    set_has_documentdate();
    documentdate_ = documentdate;
  } else {
    clear_has_documentdate();
    documentdate_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.UniversalCorrectionDocumentSellerTitleInfo.DocumentDate)
}

// required string DocumentNumber = 4;
inline bool UniversalCorrectionDocumentSellerTitleInfo::has_documentnumber() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UniversalCorrectionDocumentSellerTitleInfo::set_has_documentnumber() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UniversalCorrectionDocumentSellerTitleInfo::clear_has_documentnumber() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UniversalCorrectionDocumentSellerTitleInfo::clear_documentnumber() {
  if (documentnumber_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    documentnumber_->clear();
  }
  clear_has_documentnumber();
}
inline const ::std::string& UniversalCorrectionDocumentSellerTitleInfo::documentnumber() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.UniversalCorrectionDocumentSellerTitleInfo.DocumentNumber)
  return *documentnumber_;
}
inline void UniversalCorrectionDocumentSellerTitleInfo::set_documentnumber(const ::std::string& value) {
  set_has_documentnumber();
  if (documentnumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    documentnumber_ = new ::std::string;
  }
  documentnumber_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.UniversalCorrectionDocumentSellerTitleInfo.DocumentNumber)
}
inline void UniversalCorrectionDocumentSellerTitleInfo::set_documentnumber(const char* value) {
  set_has_documentnumber();
  if (documentnumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    documentnumber_ = new ::std::string;
  }
  documentnumber_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.UniversalCorrectionDocumentSellerTitleInfo.DocumentNumber)
}
inline void UniversalCorrectionDocumentSellerTitleInfo::set_documentnumber(const char* value, size_t size) {
  set_has_documentnumber();
  if (documentnumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    documentnumber_ = new ::std::string;
  }
  documentnumber_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.UniversalCorrectionDocumentSellerTitleInfo.DocumentNumber)
}
inline ::std::string* UniversalCorrectionDocumentSellerTitleInfo::mutable_documentnumber() {
  set_has_documentnumber();
  if (documentnumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    documentnumber_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.UniversalCorrectionDocumentSellerTitleInfo.DocumentNumber)
  return documentnumber_;
}
inline ::std::string* UniversalCorrectionDocumentSellerTitleInfo::release_documentnumber() {
  clear_has_documentnumber();
  if (documentnumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = documentnumber_;
    documentnumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UniversalCorrectionDocumentSellerTitleInfo::set_allocated_documentnumber(::std::string* documentnumber) {
  if (documentnumber_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete documentnumber_;
  }
  if (documentnumber) {
    set_has_documentnumber();
    documentnumber_ = documentnumber;
  } else {
    clear_has_documentnumber();
    documentnumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.UniversalCorrectionDocumentSellerTitleInfo.DocumentNumber)
}

// repeated .Diadoc.Api.Proto.Invoicing.InvoiceForCorrectionInfo Invoices = 5;
inline int UniversalCorrectionDocumentSellerTitleInfo::invoices_size() const {
  return invoices_.size();
}
inline void UniversalCorrectionDocumentSellerTitleInfo::clear_invoices() {
  invoices_.Clear();
}
inline const ::Diadoc::Api::Proto::Invoicing::InvoiceForCorrectionInfo& UniversalCorrectionDocumentSellerTitleInfo::invoices(int index) const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.UniversalCorrectionDocumentSellerTitleInfo.Invoices)
  return invoices_.Get(index);
}
inline ::Diadoc::Api::Proto::Invoicing::InvoiceForCorrectionInfo* UniversalCorrectionDocumentSellerTitleInfo::mutable_invoices(int index) {
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.UniversalCorrectionDocumentSellerTitleInfo.Invoices)
  return invoices_.Mutable(index);
}
inline ::Diadoc::Api::Proto::Invoicing::InvoiceForCorrectionInfo* UniversalCorrectionDocumentSellerTitleInfo::add_invoices() {
  // @@protoc_insertion_point(field_add:Diadoc.Api.Proto.Invoicing.UniversalCorrectionDocumentSellerTitleInfo.Invoices)
  return invoices_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::InvoiceForCorrectionInfo >&
UniversalCorrectionDocumentSellerTitleInfo::invoices() const {
  // @@protoc_insertion_point(field_list:Diadoc.Api.Proto.Invoicing.UniversalCorrectionDocumentSellerTitleInfo.Invoices)
  return invoices_;
}
inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::InvoiceForCorrectionInfo >*
UniversalCorrectionDocumentSellerTitleInfo::mutable_invoices() {
  // @@protoc_insertion_point(field_mutable_list:Diadoc.Api.Proto.Invoicing.UniversalCorrectionDocumentSellerTitleInfo.Invoices)
  return &invoices_;
}

// required .Diadoc.Api.Proto.Invoicing.Organizations.ExtendedOrganizationInfo Seller = 6;
inline bool UniversalCorrectionDocumentSellerTitleInfo::has_seller() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UniversalCorrectionDocumentSellerTitleInfo::set_has_seller() {
  _has_bits_[0] |= 0x00000020u;
}
inline void UniversalCorrectionDocumentSellerTitleInfo::clear_has_seller() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void UniversalCorrectionDocumentSellerTitleInfo::clear_seller() {
  if (seller_ != NULL) seller_->::Diadoc::Api::Proto::Invoicing::Organizations::ExtendedOrganizationInfo::Clear();
  clear_has_seller();
}
inline const ::Diadoc::Api::Proto::Invoicing::Organizations::ExtendedOrganizationInfo& UniversalCorrectionDocumentSellerTitleInfo::seller() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.UniversalCorrectionDocumentSellerTitleInfo.Seller)
  return seller_ != NULL ? *seller_ : *default_instance_->seller_;
}
inline ::Diadoc::Api::Proto::Invoicing::Organizations::ExtendedOrganizationInfo* UniversalCorrectionDocumentSellerTitleInfo::mutable_seller() {
  set_has_seller();
  if (seller_ == NULL) seller_ = new ::Diadoc::Api::Proto::Invoicing::Organizations::ExtendedOrganizationInfo;
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.UniversalCorrectionDocumentSellerTitleInfo.Seller)
  return seller_;
}
inline ::Diadoc::Api::Proto::Invoicing::Organizations::ExtendedOrganizationInfo* UniversalCorrectionDocumentSellerTitleInfo::release_seller() {
  clear_has_seller();
  ::Diadoc::Api::Proto::Invoicing::Organizations::ExtendedOrganizationInfo* temp = seller_;
  seller_ = NULL;
  return temp;
}
inline void UniversalCorrectionDocumentSellerTitleInfo::set_allocated_seller(::Diadoc::Api::Proto::Invoicing::Organizations::ExtendedOrganizationInfo* seller) {
  delete seller_;
  seller_ = seller;
  if (seller) {
    set_has_seller();
  } else {
    clear_has_seller();
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.UniversalCorrectionDocumentSellerTitleInfo.Seller)
}

// required .Diadoc.Api.Proto.Invoicing.Organizations.ExtendedOrganizationInfo Buyer = 7;
inline bool UniversalCorrectionDocumentSellerTitleInfo::has_buyer() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void UniversalCorrectionDocumentSellerTitleInfo::set_has_buyer() {
  _has_bits_[0] |= 0x00000040u;
}
inline void UniversalCorrectionDocumentSellerTitleInfo::clear_has_buyer() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void UniversalCorrectionDocumentSellerTitleInfo::clear_buyer() {
  if (buyer_ != NULL) buyer_->::Diadoc::Api::Proto::Invoicing::Organizations::ExtendedOrganizationInfo::Clear();
  clear_has_buyer();
}
inline const ::Diadoc::Api::Proto::Invoicing::Organizations::ExtendedOrganizationInfo& UniversalCorrectionDocumentSellerTitleInfo::buyer() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.UniversalCorrectionDocumentSellerTitleInfo.Buyer)
  return buyer_ != NULL ? *buyer_ : *default_instance_->buyer_;
}
inline ::Diadoc::Api::Proto::Invoicing::Organizations::ExtendedOrganizationInfo* UniversalCorrectionDocumentSellerTitleInfo::mutable_buyer() {
  set_has_buyer();
  if (buyer_ == NULL) buyer_ = new ::Diadoc::Api::Proto::Invoicing::Organizations::ExtendedOrganizationInfo;
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.UniversalCorrectionDocumentSellerTitleInfo.Buyer)
  return buyer_;
}
inline ::Diadoc::Api::Proto::Invoicing::Organizations::ExtendedOrganizationInfo* UniversalCorrectionDocumentSellerTitleInfo::release_buyer() {
  clear_has_buyer();
  ::Diadoc::Api::Proto::Invoicing::Organizations::ExtendedOrganizationInfo* temp = buyer_;
  buyer_ = NULL;
  return temp;
}
inline void UniversalCorrectionDocumentSellerTitleInfo::set_allocated_buyer(::Diadoc::Api::Proto::Invoicing::Organizations::ExtendedOrganizationInfo* buyer) {
  delete buyer_;
  buyer_ = buyer;
  if (buyer) {
    set_has_buyer();
  } else {
    clear_has_buyer();
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.UniversalCorrectionDocumentSellerTitleInfo.Buyer)
}

// repeated .Diadoc.Api.Proto.Invoicing.Signers.ExtendedSigner Signers = 8;
inline int UniversalCorrectionDocumentSellerTitleInfo::signers_size() const {
  return signers_.size();
}
inline void UniversalCorrectionDocumentSellerTitleInfo::clear_signers() {
  signers_.Clear();
}
inline const ::Diadoc::Api::Proto::Invoicing::Signers::ExtendedSigner& UniversalCorrectionDocumentSellerTitleInfo::signers(int index) const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.UniversalCorrectionDocumentSellerTitleInfo.Signers)
  return signers_.Get(index);
}
inline ::Diadoc::Api::Proto::Invoicing::Signers::ExtendedSigner* UniversalCorrectionDocumentSellerTitleInfo::mutable_signers(int index) {
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.UniversalCorrectionDocumentSellerTitleInfo.Signers)
  return signers_.Mutable(index);
}
inline ::Diadoc::Api::Proto::Invoicing::Signers::ExtendedSigner* UniversalCorrectionDocumentSellerTitleInfo::add_signers() {
  // @@protoc_insertion_point(field_add:Diadoc.Api.Proto.Invoicing.UniversalCorrectionDocumentSellerTitleInfo.Signers)
  return signers_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::Signers::ExtendedSigner >&
UniversalCorrectionDocumentSellerTitleInfo::signers() const {
  // @@protoc_insertion_point(field_list:Diadoc.Api.Proto.Invoicing.UniversalCorrectionDocumentSellerTitleInfo.Signers)
  return signers_;
}
inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::Signers::ExtendedSigner >*
UniversalCorrectionDocumentSellerTitleInfo::mutable_signers() {
  // @@protoc_insertion_point(field_mutable_list:Diadoc.Api.Proto.Invoicing.UniversalCorrectionDocumentSellerTitleInfo.Signers)
  return &signers_;
}

// required .Diadoc.Api.Proto.Invoicing.EventContent EventContent = 9;
inline bool UniversalCorrectionDocumentSellerTitleInfo::has_eventcontent() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void UniversalCorrectionDocumentSellerTitleInfo::set_has_eventcontent() {
  _has_bits_[0] |= 0x00000100u;
}
inline void UniversalCorrectionDocumentSellerTitleInfo::clear_has_eventcontent() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void UniversalCorrectionDocumentSellerTitleInfo::clear_eventcontent() {
  if (eventcontent_ != NULL) eventcontent_->::Diadoc::Api::Proto::Invoicing::EventContent::Clear();
  clear_has_eventcontent();
}
inline const ::Diadoc::Api::Proto::Invoicing::EventContent& UniversalCorrectionDocumentSellerTitleInfo::eventcontent() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.UniversalCorrectionDocumentSellerTitleInfo.EventContent)
  return eventcontent_ != NULL ? *eventcontent_ : *default_instance_->eventcontent_;
}
inline ::Diadoc::Api::Proto::Invoicing::EventContent* UniversalCorrectionDocumentSellerTitleInfo::mutable_eventcontent() {
  set_has_eventcontent();
  if (eventcontent_ == NULL) eventcontent_ = new ::Diadoc::Api::Proto::Invoicing::EventContent;
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.UniversalCorrectionDocumentSellerTitleInfo.EventContent)
  return eventcontent_;
}
inline ::Diadoc::Api::Proto::Invoicing::EventContent* UniversalCorrectionDocumentSellerTitleInfo::release_eventcontent() {
  clear_has_eventcontent();
  ::Diadoc::Api::Proto::Invoicing::EventContent* temp = eventcontent_;
  eventcontent_ = NULL;
  return temp;
}
inline void UniversalCorrectionDocumentSellerTitleInfo::set_allocated_eventcontent(::Diadoc::Api::Proto::Invoicing::EventContent* eventcontent) {
  delete eventcontent_;
  eventcontent_ = eventcontent;
  if (eventcontent) {
    set_has_eventcontent();
  } else {
    clear_has_eventcontent();
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.UniversalCorrectionDocumentSellerTitleInfo.EventContent)
}

// required .Diadoc.Api.Proto.Invoicing.InvoiceCorrectionTable InvoiceCorrectionTable = 10;
inline bool UniversalCorrectionDocumentSellerTitleInfo::has_invoicecorrectiontable() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void UniversalCorrectionDocumentSellerTitleInfo::set_has_invoicecorrectiontable() {
  _has_bits_[0] |= 0x00000200u;
}
inline void UniversalCorrectionDocumentSellerTitleInfo::clear_has_invoicecorrectiontable() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void UniversalCorrectionDocumentSellerTitleInfo::clear_invoicecorrectiontable() {
  if (invoicecorrectiontable_ != NULL) invoicecorrectiontable_->::Diadoc::Api::Proto::Invoicing::InvoiceCorrectionTable::Clear();
  clear_has_invoicecorrectiontable();
}
inline const ::Diadoc::Api::Proto::Invoicing::InvoiceCorrectionTable& UniversalCorrectionDocumentSellerTitleInfo::invoicecorrectiontable() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.UniversalCorrectionDocumentSellerTitleInfo.InvoiceCorrectionTable)
  return invoicecorrectiontable_ != NULL ? *invoicecorrectiontable_ : *default_instance_->invoicecorrectiontable_;
}
inline ::Diadoc::Api::Proto::Invoicing::InvoiceCorrectionTable* UniversalCorrectionDocumentSellerTitleInfo::mutable_invoicecorrectiontable() {
  set_has_invoicecorrectiontable();
  if (invoicecorrectiontable_ == NULL) invoicecorrectiontable_ = new ::Diadoc::Api::Proto::Invoicing::InvoiceCorrectionTable;
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.UniversalCorrectionDocumentSellerTitleInfo.InvoiceCorrectionTable)
  return invoicecorrectiontable_;
}
inline ::Diadoc::Api::Proto::Invoicing::InvoiceCorrectionTable* UniversalCorrectionDocumentSellerTitleInfo::release_invoicecorrectiontable() {
  clear_has_invoicecorrectiontable();
  ::Diadoc::Api::Proto::Invoicing::InvoiceCorrectionTable* temp = invoicecorrectiontable_;
  invoicecorrectiontable_ = NULL;
  return temp;
}
inline void UniversalCorrectionDocumentSellerTitleInfo::set_allocated_invoicecorrectiontable(::Diadoc::Api::Proto::Invoicing::InvoiceCorrectionTable* invoicecorrectiontable) {
  delete invoicecorrectiontable_;
  invoicecorrectiontable_ = invoicecorrectiontable;
  if (invoicecorrectiontable) {
    set_has_invoicecorrectiontable();
  } else {
    clear_has_invoicecorrectiontable();
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.UniversalCorrectionDocumentSellerTitleInfo.InvoiceCorrectionTable)
}

// required string Currency = 11;
inline bool UniversalCorrectionDocumentSellerTitleInfo::has_currency() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void UniversalCorrectionDocumentSellerTitleInfo::set_has_currency() {
  _has_bits_[0] |= 0x00000400u;
}
inline void UniversalCorrectionDocumentSellerTitleInfo::clear_has_currency() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void UniversalCorrectionDocumentSellerTitleInfo::clear_currency() {
  if (currency_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    currency_->clear();
  }
  clear_has_currency();
}
inline const ::std::string& UniversalCorrectionDocumentSellerTitleInfo::currency() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.UniversalCorrectionDocumentSellerTitleInfo.Currency)
  return *currency_;
}
inline void UniversalCorrectionDocumentSellerTitleInfo::set_currency(const ::std::string& value) {
  set_has_currency();
  if (currency_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    currency_ = new ::std::string;
  }
  currency_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.UniversalCorrectionDocumentSellerTitleInfo.Currency)
}
inline void UniversalCorrectionDocumentSellerTitleInfo::set_currency(const char* value) {
  set_has_currency();
  if (currency_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    currency_ = new ::std::string;
  }
  currency_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.UniversalCorrectionDocumentSellerTitleInfo.Currency)
}
inline void UniversalCorrectionDocumentSellerTitleInfo::set_currency(const char* value, size_t size) {
  set_has_currency();
  if (currency_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    currency_ = new ::std::string;
  }
  currency_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.UniversalCorrectionDocumentSellerTitleInfo.Currency)
}
inline ::std::string* UniversalCorrectionDocumentSellerTitleInfo::mutable_currency() {
  set_has_currency();
  if (currency_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    currency_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.UniversalCorrectionDocumentSellerTitleInfo.Currency)
  return currency_;
}
inline ::std::string* UniversalCorrectionDocumentSellerTitleInfo::release_currency() {
  clear_has_currency();
  if (currency_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = currency_;
    currency_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UniversalCorrectionDocumentSellerTitleInfo::set_allocated_currency(::std::string* currency) {
  if (currency_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete currency_;
  }
  if (currency) {
    set_has_currency();
    currency_ = currency;
  } else {
    clear_has_currency();
    currency_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.UniversalCorrectionDocumentSellerTitleInfo.Currency)
}

// optional string CurrencyRate = 12;
inline bool UniversalCorrectionDocumentSellerTitleInfo::has_currencyrate() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void UniversalCorrectionDocumentSellerTitleInfo::set_has_currencyrate() {
  _has_bits_[0] |= 0x00000800u;
}
inline void UniversalCorrectionDocumentSellerTitleInfo::clear_has_currencyrate() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void UniversalCorrectionDocumentSellerTitleInfo::clear_currencyrate() {
  if (currencyrate_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    currencyrate_->clear();
  }
  clear_has_currencyrate();
}
inline const ::std::string& UniversalCorrectionDocumentSellerTitleInfo::currencyrate() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.UniversalCorrectionDocumentSellerTitleInfo.CurrencyRate)
  return *currencyrate_;
}
inline void UniversalCorrectionDocumentSellerTitleInfo::set_currencyrate(const ::std::string& value) {
  set_has_currencyrate();
  if (currencyrate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    currencyrate_ = new ::std::string;
  }
  currencyrate_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.UniversalCorrectionDocumentSellerTitleInfo.CurrencyRate)
}
inline void UniversalCorrectionDocumentSellerTitleInfo::set_currencyrate(const char* value) {
  set_has_currencyrate();
  if (currencyrate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    currencyrate_ = new ::std::string;
  }
  currencyrate_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.UniversalCorrectionDocumentSellerTitleInfo.CurrencyRate)
}
inline void UniversalCorrectionDocumentSellerTitleInfo::set_currencyrate(const char* value, size_t size) {
  set_has_currencyrate();
  if (currencyrate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    currencyrate_ = new ::std::string;
  }
  currencyrate_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.UniversalCorrectionDocumentSellerTitleInfo.CurrencyRate)
}
inline ::std::string* UniversalCorrectionDocumentSellerTitleInfo::mutable_currencyrate() {
  set_has_currencyrate();
  if (currencyrate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    currencyrate_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.UniversalCorrectionDocumentSellerTitleInfo.CurrencyRate)
  return currencyrate_;
}
inline ::std::string* UniversalCorrectionDocumentSellerTitleInfo::release_currencyrate() {
  clear_has_currencyrate();
  if (currencyrate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = currencyrate_;
    currencyrate_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UniversalCorrectionDocumentSellerTitleInfo::set_allocated_currencyrate(::std::string* currencyrate) {
  if (currencyrate_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete currencyrate_;
  }
  if (currencyrate) {
    set_has_currencyrate();
    currencyrate_ = currencyrate;
  } else {
    clear_has_currencyrate();
    currencyrate_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.UniversalCorrectionDocumentSellerTitleInfo.CurrencyRate)
}

// optional string CorrectionRevisionDate = 13;
inline bool UniversalCorrectionDocumentSellerTitleInfo::has_correctionrevisiondate() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void UniversalCorrectionDocumentSellerTitleInfo::set_has_correctionrevisiondate() {
  _has_bits_[0] |= 0x00001000u;
}
inline void UniversalCorrectionDocumentSellerTitleInfo::clear_has_correctionrevisiondate() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void UniversalCorrectionDocumentSellerTitleInfo::clear_correctionrevisiondate() {
  if (correctionrevisiondate_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    correctionrevisiondate_->clear();
  }
  clear_has_correctionrevisiondate();
}
inline const ::std::string& UniversalCorrectionDocumentSellerTitleInfo::correctionrevisiondate() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.UniversalCorrectionDocumentSellerTitleInfo.CorrectionRevisionDate)
  return *correctionrevisiondate_;
}
inline void UniversalCorrectionDocumentSellerTitleInfo::set_correctionrevisiondate(const ::std::string& value) {
  set_has_correctionrevisiondate();
  if (correctionrevisiondate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    correctionrevisiondate_ = new ::std::string;
  }
  correctionrevisiondate_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.UniversalCorrectionDocumentSellerTitleInfo.CorrectionRevisionDate)
}
inline void UniversalCorrectionDocumentSellerTitleInfo::set_correctionrevisiondate(const char* value) {
  set_has_correctionrevisiondate();
  if (correctionrevisiondate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    correctionrevisiondate_ = new ::std::string;
  }
  correctionrevisiondate_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.UniversalCorrectionDocumentSellerTitleInfo.CorrectionRevisionDate)
}
inline void UniversalCorrectionDocumentSellerTitleInfo::set_correctionrevisiondate(const char* value, size_t size) {
  set_has_correctionrevisiondate();
  if (correctionrevisiondate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    correctionrevisiondate_ = new ::std::string;
  }
  correctionrevisiondate_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.UniversalCorrectionDocumentSellerTitleInfo.CorrectionRevisionDate)
}
inline ::std::string* UniversalCorrectionDocumentSellerTitleInfo::mutable_correctionrevisiondate() {
  set_has_correctionrevisiondate();
  if (correctionrevisiondate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    correctionrevisiondate_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.UniversalCorrectionDocumentSellerTitleInfo.CorrectionRevisionDate)
  return correctionrevisiondate_;
}
inline ::std::string* UniversalCorrectionDocumentSellerTitleInfo::release_correctionrevisiondate() {
  clear_has_correctionrevisiondate();
  if (correctionrevisiondate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = correctionrevisiondate_;
    correctionrevisiondate_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UniversalCorrectionDocumentSellerTitleInfo::set_allocated_correctionrevisiondate(::std::string* correctionrevisiondate) {
  if (correctionrevisiondate_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete correctionrevisiondate_;
  }
  if (correctionrevisiondate) {
    set_has_correctionrevisiondate();
    correctionrevisiondate_ = correctionrevisiondate;
  } else {
    clear_has_correctionrevisiondate();
    correctionrevisiondate_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.UniversalCorrectionDocumentSellerTitleInfo.CorrectionRevisionDate)
}

// optional string CorrectionRevisionNumber = 14;
inline bool UniversalCorrectionDocumentSellerTitleInfo::has_correctionrevisionnumber() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void UniversalCorrectionDocumentSellerTitleInfo::set_has_correctionrevisionnumber() {
  _has_bits_[0] |= 0x00002000u;
}
inline void UniversalCorrectionDocumentSellerTitleInfo::clear_has_correctionrevisionnumber() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void UniversalCorrectionDocumentSellerTitleInfo::clear_correctionrevisionnumber() {
  if (correctionrevisionnumber_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    correctionrevisionnumber_->clear();
  }
  clear_has_correctionrevisionnumber();
}
inline const ::std::string& UniversalCorrectionDocumentSellerTitleInfo::correctionrevisionnumber() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.UniversalCorrectionDocumentSellerTitleInfo.CorrectionRevisionNumber)
  return *correctionrevisionnumber_;
}
inline void UniversalCorrectionDocumentSellerTitleInfo::set_correctionrevisionnumber(const ::std::string& value) {
  set_has_correctionrevisionnumber();
  if (correctionrevisionnumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    correctionrevisionnumber_ = new ::std::string;
  }
  correctionrevisionnumber_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.UniversalCorrectionDocumentSellerTitleInfo.CorrectionRevisionNumber)
}
inline void UniversalCorrectionDocumentSellerTitleInfo::set_correctionrevisionnumber(const char* value) {
  set_has_correctionrevisionnumber();
  if (correctionrevisionnumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    correctionrevisionnumber_ = new ::std::string;
  }
  correctionrevisionnumber_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.UniversalCorrectionDocumentSellerTitleInfo.CorrectionRevisionNumber)
}
inline void UniversalCorrectionDocumentSellerTitleInfo::set_correctionrevisionnumber(const char* value, size_t size) {
  set_has_correctionrevisionnumber();
  if (correctionrevisionnumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    correctionrevisionnumber_ = new ::std::string;
  }
  correctionrevisionnumber_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.UniversalCorrectionDocumentSellerTitleInfo.CorrectionRevisionNumber)
}
inline ::std::string* UniversalCorrectionDocumentSellerTitleInfo::mutable_correctionrevisionnumber() {
  set_has_correctionrevisionnumber();
  if (correctionrevisionnumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    correctionrevisionnumber_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.UniversalCorrectionDocumentSellerTitleInfo.CorrectionRevisionNumber)
  return correctionrevisionnumber_;
}
inline ::std::string* UniversalCorrectionDocumentSellerTitleInfo::release_correctionrevisionnumber() {
  clear_has_correctionrevisionnumber();
  if (correctionrevisionnumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = correctionrevisionnumber_;
    correctionrevisionnumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UniversalCorrectionDocumentSellerTitleInfo::set_allocated_correctionrevisionnumber(::std::string* correctionrevisionnumber) {
  if (correctionrevisionnumber_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete correctionrevisionnumber_;
  }
  if (correctionrevisionnumber) {
    set_has_correctionrevisionnumber();
    correctionrevisionnumber_ = correctionrevisionnumber;
  } else {
    clear_has_correctionrevisionnumber();
    correctionrevisionnumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.UniversalCorrectionDocumentSellerTitleInfo.CorrectionRevisionNumber)
}

// optional .Diadoc.Api.Proto.Invoicing.AdditionalInfoId AdditionalInfoId = 15;
inline bool UniversalCorrectionDocumentSellerTitleInfo::has_additionalinfoid() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void UniversalCorrectionDocumentSellerTitleInfo::set_has_additionalinfoid() {
  _has_bits_[0] |= 0x00004000u;
}
inline void UniversalCorrectionDocumentSellerTitleInfo::clear_has_additionalinfoid() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void UniversalCorrectionDocumentSellerTitleInfo::clear_additionalinfoid() {
  if (additionalinfoid_ != NULL) additionalinfoid_->::Diadoc::Api::Proto::Invoicing::AdditionalInfoId::Clear();
  clear_has_additionalinfoid();
}
inline const ::Diadoc::Api::Proto::Invoicing::AdditionalInfoId& UniversalCorrectionDocumentSellerTitleInfo::additionalinfoid() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.UniversalCorrectionDocumentSellerTitleInfo.AdditionalInfoId)
  return additionalinfoid_ != NULL ? *additionalinfoid_ : *default_instance_->additionalinfoid_;
}
inline ::Diadoc::Api::Proto::Invoicing::AdditionalInfoId* UniversalCorrectionDocumentSellerTitleInfo::mutable_additionalinfoid() {
  set_has_additionalinfoid();
  if (additionalinfoid_ == NULL) additionalinfoid_ = new ::Diadoc::Api::Proto::Invoicing::AdditionalInfoId;
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.UniversalCorrectionDocumentSellerTitleInfo.AdditionalInfoId)
  return additionalinfoid_;
}
inline ::Diadoc::Api::Proto::Invoicing::AdditionalInfoId* UniversalCorrectionDocumentSellerTitleInfo::release_additionalinfoid() {
  clear_has_additionalinfoid();
  ::Diadoc::Api::Proto::Invoicing::AdditionalInfoId* temp = additionalinfoid_;
  additionalinfoid_ = NULL;
  return temp;
}
inline void UniversalCorrectionDocumentSellerTitleInfo::set_allocated_additionalinfoid(::Diadoc::Api::Proto::Invoicing::AdditionalInfoId* additionalinfoid) {
  delete additionalinfoid_;
  additionalinfoid_ = additionalinfoid;
  if (additionalinfoid) {
    set_has_additionalinfoid();
  } else {
    clear_has_additionalinfoid();
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.UniversalCorrectionDocumentSellerTitleInfo.AdditionalInfoId)
}

// required string DocumentCreator = 16;
inline bool UniversalCorrectionDocumentSellerTitleInfo::has_documentcreator() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void UniversalCorrectionDocumentSellerTitleInfo::set_has_documentcreator() {
  _has_bits_[0] |= 0x00008000u;
}
inline void UniversalCorrectionDocumentSellerTitleInfo::clear_has_documentcreator() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void UniversalCorrectionDocumentSellerTitleInfo::clear_documentcreator() {
  if (documentcreator_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    documentcreator_->clear();
  }
  clear_has_documentcreator();
}
inline const ::std::string& UniversalCorrectionDocumentSellerTitleInfo::documentcreator() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.UniversalCorrectionDocumentSellerTitleInfo.DocumentCreator)
  return *documentcreator_;
}
inline void UniversalCorrectionDocumentSellerTitleInfo::set_documentcreator(const ::std::string& value) {
  set_has_documentcreator();
  if (documentcreator_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    documentcreator_ = new ::std::string;
  }
  documentcreator_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.UniversalCorrectionDocumentSellerTitleInfo.DocumentCreator)
}
inline void UniversalCorrectionDocumentSellerTitleInfo::set_documentcreator(const char* value) {
  set_has_documentcreator();
  if (documentcreator_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    documentcreator_ = new ::std::string;
  }
  documentcreator_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.UniversalCorrectionDocumentSellerTitleInfo.DocumentCreator)
}
inline void UniversalCorrectionDocumentSellerTitleInfo::set_documentcreator(const char* value, size_t size) {
  set_has_documentcreator();
  if (documentcreator_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    documentcreator_ = new ::std::string;
  }
  documentcreator_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.UniversalCorrectionDocumentSellerTitleInfo.DocumentCreator)
}
inline ::std::string* UniversalCorrectionDocumentSellerTitleInfo::mutable_documentcreator() {
  set_has_documentcreator();
  if (documentcreator_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    documentcreator_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.UniversalCorrectionDocumentSellerTitleInfo.DocumentCreator)
  return documentcreator_;
}
inline ::std::string* UniversalCorrectionDocumentSellerTitleInfo::release_documentcreator() {
  clear_has_documentcreator();
  if (documentcreator_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = documentcreator_;
    documentcreator_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UniversalCorrectionDocumentSellerTitleInfo::set_allocated_documentcreator(::std::string* documentcreator) {
  if (documentcreator_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete documentcreator_;
  }
  if (documentcreator) {
    set_has_documentcreator();
    documentcreator_ = documentcreator;
  } else {
    clear_has_documentcreator();
    documentcreator_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.UniversalCorrectionDocumentSellerTitleInfo.DocumentCreator)
}

// optional string DocumentCreatorBase = 17;
inline bool UniversalCorrectionDocumentSellerTitleInfo::has_documentcreatorbase() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void UniversalCorrectionDocumentSellerTitleInfo::set_has_documentcreatorbase() {
  _has_bits_[0] |= 0x00010000u;
}
inline void UniversalCorrectionDocumentSellerTitleInfo::clear_has_documentcreatorbase() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void UniversalCorrectionDocumentSellerTitleInfo::clear_documentcreatorbase() {
  if (documentcreatorbase_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    documentcreatorbase_->clear();
  }
  clear_has_documentcreatorbase();
}
inline const ::std::string& UniversalCorrectionDocumentSellerTitleInfo::documentcreatorbase() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.UniversalCorrectionDocumentSellerTitleInfo.DocumentCreatorBase)
  return *documentcreatorbase_;
}
inline void UniversalCorrectionDocumentSellerTitleInfo::set_documentcreatorbase(const ::std::string& value) {
  set_has_documentcreatorbase();
  if (documentcreatorbase_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    documentcreatorbase_ = new ::std::string;
  }
  documentcreatorbase_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.UniversalCorrectionDocumentSellerTitleInfo.DocumentCreatorBase)
}
inline void UniversalCorrectionDocumentSellerTitleInfo::set_documentcreatorbase(const char* value) {
  set_has_documentcreatorbase();
  if (documentcreatorbase_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    documentcreatorbase_ = new ::std::string;
  }
  documentcreatorbase_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.UniversalCorrectionDocumentSellerTitleInfo.DocumentCreatorBase)
}
inline void UniversalCorrectionDocumentSellerTitleInfo::set_documentcreatorbase(const char* value, size_t size) {
  set_has_documentcreatorbase();
  if (documentcreatorbase_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    documentcreatorbase_ = new ::std::string;
  }
  documentcreatorbase_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.UniversalCorrectionDocumentSellerTitleInfo.DocumentCreatorBase)
}
inline ::std::string* UniversalCorrectionDocumentSellerTitleInfo::mutable_documentcreatorbase() {
  set_has_documentcreatorbase();
  if (documentcreatorbase_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    documentcreatorbase_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.UniversalCorrectionDocumentSellerTitleInfo.DocumentCreatorBase)
  return documentcreatorbase_;
}
inline ::std::string* UniversalCorrectionDocumentSellerTitleInfo::release_documentcreatorbase() {
  clear_has_documentcreatorbase();
  if (documentcreatorbase_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = documentcreatorbase_;
    documentcreatorbase_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UniversalCorrectionDocumentSellerTitleInfo::set_allocated_documentcreatorbase(::std::string* documentcreatorbase) {
  if (documentcreatorbase_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete documentcreatorbase_;
  }
  if (documentcreatorbase) {
    set_has_documentcreatorbase();
    documentcreatorbase_ = documentcreatorbase;
  } else {
    clear_has_documentcreatorbase();
    documentcreatorbase_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.UniversalCorrectionDocumentSellerTitleInfo.DocumentCreatorBase)
}

// optional string GovernmentContractInfo = 18;
inline bool UniversalCorrectionDocumentSellerTitleInfo::has_governmentcontractinfo() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void UniversalCorrectionDocumentSellerTitleInfo::set_has_governmentcontractinfo() {
  _has_bits_[0] |= 0x00020000u;
}
inline void UniversalCorrectionDocumentSellerTitleInfo::clear_has_governmentcontractinfo() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void UniversalCorrectionDocumentSellerTitleInfo::clear_governmentcontractinfo() {
  if (governmentcontractinfo_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    governmentcontractinfo_->clear();
  }
  clear_has_governmentcontractinfo();
}
inline const ::std::string& UniversalCorrectionDocumentSellerTitleInfo::governmentcontractinfo() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.UniversalCorrectionDocumentSellerTitleInfo.GovernmentContractInfo)
  return *governmentcontractinfo_;
}
inline void UniversalCorrectionDocumentSellerTitleInfo::set_governmentcontractinfo(const ::std::string& value) {
  set_has_governmentcontractinfo();
  if (governmentcontractinfo_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    governmentcontractinfo_ = new ::std::string;
  }
  governmentcontractinfo_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.UniversalCorrectionDocumentSellerTitleInfo.GovernmentContractInfo)
}
inline void UniversalCorrectionDocumentSellerTitleInfo::set_governmentcontractinfo(const char* value) {
  set_has_governmentcontractinfo();
  if (governmentcontractinfo_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    governmentcontractinfo_ = new ::std::string;
  }
  governmentcontractinfo_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.UniversalCorrectionDocumentSellerTitleInfo.GovernmentContractInfo)
}
inline void UniversalCorrectionDocumentSellerTitleInfo::set_governmentcontractinfo(const char* value, size_t size) {
  set_has_governmentcontractinfo();
  if (governmentcontractinfo_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    governmentcontractinfo_ = new ::std::string;
  }
  governmentcontractinfo_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.UniversalCorrectionDocumentSellerTitleInfo.GovernmentContractInfo)
}
inline ::std::string* UniversalCorrectionDocumentSellerTitleInfo::mutable_governmentcontractinfo() {
  set_has_governmentcontractinfo();
  if (governmentcontractinfo_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    governmentcontractinfo_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.UniversalCorrectionDocumentSellerTitleInfo.GovernmentContractInfo)
  return governmentcontractinfo_;
}
inline ::std::string* UniversalCorrectionDocumentSellerTitleInfo::release_governmentcontractinfo() {
  clear_has_governmentcontractinfo();
  if (governmentcontractinfo_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = governmentcontractinfo_;
    governmentcontractinfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UniversalCorrectionDocumentSellerTitleInfo::set_allocated_governmentcontractinfo(::std::string* governmentcontractinfo) {
  if (governmentcontractinfo_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete governmentcontractinfo_;
  }
  if (governmentcontractinfo) {
    set_has_governmentcontractinfo();
    governmentcontractinfo_ = governmentcontractinfo;
  } else {
    clear_has_governmentcontractinfo();
    governmentcontractinfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.UniversalCorrectionDocumentSellerTitleInfo.GovernmentContractInfo)
}

// -------------------------------------------------------------------

// InvoiceForCorrectionInfo

// required string InvoiceDate = 1;
inline bool InvoiceForCorrectionInfo::has_invoicedate() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InvoiceForCorrectionInfo::set_has_invoicedate() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InvoiceForCorrectionInfo::clear_has_invoicedate() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InvoiceForCorrectionInfo::clear_invoicedate() {
  if (invoicedate_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    invoicedate_->clear();
  }
  clear_has_invoicedate();
}
inline const ::std::string& InvoiceForCorrectionInfo::invoicedate() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.InvoiceForCorrectionInfo.InvoiceDate)
  return *invoicedate_;
}
inline void InvoiceForCorrectionInfo::set_invoicedate(const ::std::string& value) {
  set_has_invoicedate();
  if (invoicedate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    invoicedate_ = new ::std::string;
  }
  invoicedate_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.InvoiceForCorrectionInfo.InvoiceDate)
}
inline void InvoiceForCorrectionInfo::set_invoicedate(const char* value) {
  set_has_invoicedate();
  if (invoicedate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    invoicedate_ = new ::std::string;
  }
  invoicedate_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.InvoiceForCorrectionInfo.InvoiceDate)
}
inline void InvoiceForCorrectionInfo::set_invoicedate(const char* value, size_t size) {
  set_has_invoicedate();
  if (invoicedate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    invoicedate_ = new ::std::string;
  }
  invoicedate_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.InvoiceForCorrectionInfo.InvoiceDate)
}
inline ::std::string* InvoiceForCorrectionInfo::mutable_invoicedate() {
  set_has_invoicedate();
  if (invoicedate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    invoicedate_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.InvoiceForCorrectionInfo.InvoiceDate)
  return invoicedate_;
}
inline ::std::string* InvoiceForCorrectionInfo::release_invoicedate() {
  clear_has_invoicedate();
  if (invoicedate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = invoicedate_;
    invoicedate_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void InvoiceForCorrectionInfo::set_allocated_invoicedate(::std::string* invoicedate) {
  if (invoicedate_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete invoicedate_;
  }
  if (invoicedate) {
    set_has_invoicedate();
    invoicedate_ = invoicedate;
  } else {
    clear_has_invoicedate();
    invoicedate_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.InvoiceForCorrectionInfo.InvoiceDate)
}

// required string InvoiceNumber = 2;
inline bool InvoiceForCorrectionInfo::has_invoicenumber() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InvoiceForCorrectionInfo::set_has_invoicenumber() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InvoiceForCorrectionInfo::clear_has_invoicenumber() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InvoiceForCorrectionInfo::clear_invoicenumber() {
  if (invoicenumber_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    invoicenumber_->clear();
  }
  clear_has_invoicenumber();
}
inline const ::std::string& InvoiceForCorrectionInfo::invoicenumber() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.InvoiceForCorrectionInfo.InvoiceNumber)
  return *invoicenumber_;
}
inline void InvoiceForCorrectionInfo::set_invoicenumber(const ::std::string& value) {
  set_has_invoicenumber();
  if (invoicenumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    invoicenumber_ = new ::std::string;
  }
  invoicenumber_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.InvoiceForCorrectionInfo.InvoiceNumber)
}
inline void InvoiceForCorrectionInfo::set_invoicenumber(const char* value) {
  set_has_invoicenumber();
  if (invoicenumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    invoicenumber_ = new ::std::string;
  }
  invoicenumber_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.InvoiceForCorrectionInfo.InvoiceNumber)
}
inline void InvoiceForCorrectionInfo::set_invoicenumber(const char* value, size_t size) {
  set_has_invoicenumber();
  if (invoicenumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    invoicenumber_ = new ::std::string;
  }
  invoicenumber_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.InvoiceForCorrectionInfo.InvoiceNumber)
}
inline ::std::string* InvoiceForCorrectionInfo::mutable_invoicenumber() {
  set_has_invoicenumber();
  if (invoicenumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    invoicenumber_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.InvoiceForCorrectionInfo.InvoiceNumber)
  return invoicenumber_;
}
inline ::std::string* InvoiceForCorrectionInfo::release_invoicenumber() {
  clear_has_invoicenumber();
  if (invoicenumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = invoicenumber_;
    invoicenumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void InvoiceForCorrectionInfo::set_allocated_invoicenumber(::std::string* invoicenumber) {
  if (invoicenumber_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete invoicenumber_;
  }
  if (invoicenumber) {
    set_has_invoicenumber();
    invoicenumber_ = invoicenumber;
  } else {
    clear_has_invoicenumber();
    invoicenumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.InvoiceForCorrectionInfo.InvoiceNumber)
}

// repeated .Diadoc.Api.Proto.Invoicing.InvoiceRevisionInfo InvoiceRevisions = 3;
inline int InvoiceForCorrectionInfo::invoicerevisions_size() const {
  return invoicerevisions_.size();
}
inline void InvoiceForCorrectionInfo::clear_invoicerevisions() {
  invoicerevisions_.Clear();
}
inline const ::Diadoc::Api::Proto::Invoicing::InvoiceRevisionInfo& InvoiceForCorrectionInfo::invoicerevisions(int index) const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.InvoiceForCorrectionInfo.InvoiceRevisions)
  return invoicerevisions_.Get(index);
}
inline ::Diadoc::Api::Proto::Invoicing::InvoiceRevisionInfo* InvoiceForCorrectionInfo::mutable_invoicerevisions(int index) {
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.InvoiceForCorrectionInfo.InvoiceRevisions)
  return invoicerevisions_.Mutable(index);
}
inline ::Diadoc::Api::Proto::Invoicing::InvoiceRevisionInfo* InvoiceForCorrectionInfo::add_invoicerevisions() {
  // @@protoc_insertion_point(field_add:Diadoc.Api.Proto.Invoicing.InvoiceForCorrectionInfo.InvoiceRevisions)
  return invoicerevisions_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::InvoiceRevisionInfo >&
InvoiceForCorrectionInfo::invoicerevisions() const {
  // @@protoc_insertion_point(field_list:Diadoc.Api.Proto.Invoicing.InvoiceForCorrectionInfo.InvoiceRevisions)
  return invoicerevisions_;
}
inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::InvoiceRevisionInfo >*
InvoiceForCorrectionInfo::mutable_invoicerevisions() {
  // @@protoc_insertion_point(field_mutable_list:Diadoc.Api.Proto.Invoicing.InvoiceForCorrectionInfo.InvoiceRevisions)
  return &invoicerevisions_;
}

// -------------------------------------------------------------------

// InvoiceRevisionInfo

// required string InvoiceRevisionDate = 1;
inline bool InvoiceRevisionInfo::has_invoicerevisiondate() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InvoiceRevisionInfo::set_has_invoicerevisiondate() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InvoiceRevisionInfo::clear_has_invoicerevisiondate() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InvoiceRevisionInfo::clear_invoicerevisiondate() {
  if (invoicerevisiondate_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    invoicerevisiondate_->clear();
  }
  clear_has_invoicerevisiondate();
}
inline const ::std::string& InvoiceRevisionInfo::invoicerevisiondate() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.InvoiceRevisionInfo.InvoiceRevisionDate)
  return *invoicerevisiondate_;
}
inline void InvoiceRevisionInfo::set_invoicerevisiondate(const ::std::string& value) {
  set_has_invoicerevisiondate();
  if (invoicerevisiondate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    invoicerevisiondate_ = new ::std::string;
  }
  invoicerevisiondate_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.InvoiceRevisionInfo.InvoiceRevisionDate)
}
inline void InvoiceRevisionInfo::set_invoicerevisiondate(const char* value) {
  set_has_invoicerevisiondate();
  if (invoicerevisiondate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    invoicerevisiondate_ = new ::std::string;
  }
  invoicerevisiondate_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.InvoiceRevisionInfo.InvoiceRevisionDate)
}
inline void InvoiceRevisionInfo::set_invoicerevisiondate(const char* value, size_t size) {
  set_has_invoicerevisiondate();
  if (invoicerevisiondate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    invoicerevisiondate_ = new ::std::string;
  }
  invoicerevisiondate_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.InvoiceRevisionInfo.InvoiceRevisionDate)
}
inline ::std::string* InvoiceRevisionInfo::mutable_invoicerevisiondate() {
  set_has_invoicerevisiondate();
  if (invoicerevisiondate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    invoicerevisiondate_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.InvoiceRevisionInfo.InvoiceRevisionDate)
  return invoicerevisiondate_;
}
inline ::std::string* InvoiceRevisionInfo::release_invoicerevisiondate() {
  clear_has_invoicerevisiondate();
  if (invoicerevisiondate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = invoicerevisiondate_;
    invoicerevisiondate_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void InvoiceRevisionInfo::set_allocated_invoicerevisiondate(::std::string* invoicerevisiondate) {
  if (invoicerevisiondate_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete invoicerevisiondate_;
  }
  if (invoicerevisiondate) {
    set_has_invoicerevisiondate();
    invoicerevisiondate_ = invoicerevisiondate;
  } else {
    clear_has_invoicerevisiondate();
    invoicerevisiondate_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.InvoiceRevisionInfo.InvoiceRevisionDate)
}

// required string InvoiceRevisionNumber = 2;
inline bool InvoiceRevisionInfo::has_invoicerevisionnumber() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InvoiceRevisionInfo::set_has_invoicerevisionnumber() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InvoiceRevisionInfo::clear_has_invoicerevisionnumber() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InvoiceRevisionInfo::clear_invoicerevisionnumber() {
  if (invoicerevisionnumber_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    invoicerevisionnumber_->clear();
  }
  clear_has_invoicerevisionnumber();
}
inline const ::std::string& InvoiceRevisionInfo::invoicerevisionnumber() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.InvoiceRevisionInfo.InvoiceRevisionNumber)
  return *invoicerevisionnumber_;
}
inline void InvoiceRevisionInfo::set_invoicerevisionnumber(const ::std::string& value) {
  set_has_invoicerevisionnumber();
  if (invoicerevisionnumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    invoicerevisionnumber_ = new ::std::string;
  }
  invoicerevisionnumber_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.InvoiceRevisionInfo.InvoiceRevisionNumber)
}
inline void InvoiceRevisionInfo::set_invoicerevisionnumber(const char* value) {
  set_has_invoicerevisionnumber();
  if (invoicerevisionnumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    invoicerevisionnumber_ = new ::std::string;
  }
  invoicerevisionnumber_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.InvoiceRevisionInfo.InvoiceRevisionNumber)
}
inline void InvoiceRevisionInfo::set_invoicerevisionnumber(const char* value, size_t size) {
  set_has_invoicerevisionnumber();
  if (invoicerevisionnumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    invoicerevisionnumber_ = new ::std::string;
  }
  invoicerevisionnumber_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.InvoiceRevisionInfo.InvoiceRevisionNumber)
}
inline ::std::string* InvoiceRevisionInfo::mutable_invoicerevisionnumber() {
  set_has_invoicerevisionnumber();
  if (invoicerevisionnumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    invoicerevisionnumber_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.InvoiceRevisionInfo.InvoiceRevisionNumber)
  return invoicerevisionnumber_;
}
inline ::std::string* InvoiceRevisionInfo::release_invoicerevisionnumber() {
  clear_has_invoicerevisionnumber();
  if (invoicerevisionnumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = invoicerevisionnumber_;
    invoicerevisionnumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void InvoiceRevisionInfo::set_allocated_invoicerevisionnumber(::std::string* invoicerevisionnumber) {
  if (invoicerevisionnumber_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete invoicerevisionnumber_;
  }
  if (invoicerevisionnumber) {
    set_has_invoicerevisionnumber();
    invoicerevisionnumber_ = invoicerevisionnumber;
  } else {
    clear_has_invoicerevisionnumber();
    invoicerevisionnumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.InvoiceRevisionInfo.InvoiceRevisionNumber)
}

// -------------------------------------------------------------------

// EventContent

// optional string CostChangeInfo = 1;
inline bool EventContent::has_costchangeinfo() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EventContent::set_has_costchangeinfo() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EventContent::clear_has_costchangeinfo() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EventContent::clear_costchangeinfo() {
  if (costchangeinfo_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    costchangeinfo_->clear();
  }
  clear_has_costchangeinfo();
}
inline const ::std::string& EventContent::costchangeinfo() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.EventContent.CostChangeInfo)
  return *costchangeinfo_;
}
inline void EventContent::set_costchangeinfo(const ::std::string& value) {
  set_has_costchangeinfo();
  if (costchangeinfo_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    costchangeinfo_ = new ::std::string;
  }
  costchangeinfo_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.EventContent.CostChangeInfo)
}
inline void EventContent::set_costchangeinfo(const char* value) {
  set_has_costchangeinfo();
  if (costchangeinfo_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    costchangeinfo_ = new ::std::string;
  }
  costchangeinfo_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.EventContent.CostChangeInfo)
}
inline void EventContent::set_costchangeinfo(const char* value, size_t size) {
  set_has_costchangeinfo();
  if (costchangeinfo_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    costchangeinfo_ = new ::std::string;
  }
  costchangeinfo_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.EventContent.CostChangeInfo)
}
inline ::std::string* EventContent::mutable_costchangeinfo() {
  set_has_costchangeinfo();
  if (costchangeinfo_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    costchangeinfo_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.EventContent.CostChangeInfo)
  return costchangeinfo_;
}
inline ::std::string* EventContent::release_costchangeinfo() {
  clear_has_costchangeinfo();
  if (costchangeinfo_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = costchangeinfo_;
    costchangeinfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void EventContent::set_allocated_costchangeinfo(::std::string* costchangeinfo) {
  if (costchangeinfo_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete costchangeinfo_;
  }
  if (costchangeinfo) {
    set_has_costchangeinfo();
    costchangeinfo_ = costchangeinfo;
  } else {
    clear_has_costchangeinfo();
    costchangeinfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.EventContent.CostChangeInfo)
}

// optional string TransferDocDetails = 2;
inline bool EventContent::has_transferdocdetails() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EventContent::set_has_transferdocdetails() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EventContent::clear_has_transferdocdetails() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EventContent::clear_transferdocdetails() {
  if (transferdocdetails_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    transferdocdetails_->clear();
  }
  clear_has_transferdocdetails();
}
inline const ::std::string& EventContent::transferdocdetails() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.EventContent.TransferDocDetails)
  return *transferdocdetails_;
}
inline void EventContent::set_transferdocdetails(const ::std::string& value) {
  set_has_transferdocdetails();
  if (transferdocdetails_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    transferdocdetails_ = new ::std::string;
  }
  transferdocdetails_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.EventContent.TransferDocDetails)
}
inline void EventContent::set_transferdocdetails(const char* value) {
  set_has_transferdocdetails();
  if (transferdocdetails_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    transferdocdetails_ = new ::std::string;
  }
  transferdocdetails_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.EventContent.TransferDocDetails)
}
inline void EventContent::set_transferdocdetails(const char* value, size_t size) {
  set_has_transferdocdetails();
  if (transferdocdetails_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    transferdocdetails_ = new ::std::string;
  }
  transferdocdetails_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.EventContent.TransferDocDetails)
}
inline ::std::string* EventContent::mutable_transferdocdetails() {
  set_has_transferdocdetails();
  if (transferdocdetails_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    transferdocdetails_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.EventContent.TransferDocDetails)
  return transferdocdetails_;
}
inline ::std::string* EventContent::release_transferdocdetails() {
  clear_has_transferdocdetails();
  if (transferdocdetails_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = transferdocdetails_;
    transferdocdetails_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void EventContent::set_allocated_transferdocdetails(::std::string* transferdocdetails) {
  if (transferdocdetails_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete transferdocdetails_;
  }
  if (transferdocdetails) {
    set_has_transferdocdetails();
    transferdocdetails_ = transferdocdetails;
  } else {
    clear_has_transferdocdetails();
    transferdocdetails_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.EventContent.TransferDocDetails)
}

// required string OperationContent = 3;
inline bool EventContent::has_operationcontent() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EventContent::set_has_operationcontent() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EventContent::clear_has_operationcontent() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EventContent::clear_operationcontent() {
  if (operationcontent_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    operationcontent_->clear();
  }
  clear_has_operationcontent();
}
inline const ::std::string& EventContent::operationcontent() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.EventContent.OperationContent)
  return *operationcontent_;
}
inline void EventContent::set_operationcontent(const ::std::string& value) {
  set_has_operationcontent();
  if (operationcontent_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    operationcontent_ = new ::std::string;
  }
  operationcontent_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.EventContent.OperationContent)
}
inline void EventContent::set_operationcontent(const char* value) {
  set_has_operationcontent();
  if (operationcontent_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    operationcontent_ = new ::std::string;
  }
  operationcontent_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.EventContent.OperationContent)
}
inline void EventContent::set_operationcontent(const char* value, size_t size) {
  set_has_operationcontent();
  if (operationcontent_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    operationcontent_ = new ::std::string;
  }
  operationcontent_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.EventContent.OperationContent)
}
inline ::std::string* EventContent::mutable_operationcontent() {
  set_has_operationcontent();
  if (operationcontent_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    operationcontent_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.EventContent.OperationContent)
  return operationcontent_;
}
inline ::std::string* EventContent::release_operationcontent() {
  clear_has_operationcontent();
  if (operationcontent_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = operationcontent_;
    operationcontent_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void EventContent::set_allocated_operationcontent(::std::string* operationcontent) {
  if (operationcontent_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete operationcontent_;
  }
  if (operationcontent) {
    set_has_operationcontent();
    operationcontent_ = operationcontent;
  } else {
    clear_has_operationcontent();
    operationcontent_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.EventContent.OperationContent)
}

// optional string NotificationDate = 4;
inline bool EventContent::has_notificationdate() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void EventContent::set_has_notificationdate() {
  _has_bits_[0] |= 0x00000008u;
}
inline void EventContent::clear_has_notificationdate() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void EventContent::clear_notificationdate() {
  if (notificationdate_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    notificationdate_->clear();
  }
  clear_has_notificationdate();
}
inline const ::std::string& EventContent::notificationdate() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.EventContent.NotificationDate)
  return *notificationdate_;
}
inline void EventContent::set_notificationdate(const ::std::string& value) {
  set_has_notificationdate();
  if (notificationdate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    notificationdate_ = new ::std::string;
  }
  notificationdate_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.EventContent.NotificationDate)
}
inline void EventContent::set_notificationdate(const char* value) {
  set_has_notificationdate();
  if (notificationdate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    notificationdate_ = new ::std::string;
  }
  notificationdate_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.EventContent.NotificationDate)
}
inline void EventContent::set_notificationdate(const char* value, size_t size) {
  set_has_notificationdate();
  if (notificationdate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    notificationdate_ = new ::std::string;
  }
  notificationdate_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.EventContent.NotificationDate)
}
inline ::std::string* EventContent::mutable_notificationdate() {
  set_has_notificationdate();
  if (notificationdate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    notificationdate_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.EventContent.NotificationDate)
  return notificationdate_;
}
inline ::std::string* EventContent::release_notificationdate() {
  clear_has_notificationdate();
  if (notificationdate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = notificationdate_;
    notificationdate_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void EventContent::set_allocated_notificationdate(::std::string* notificationdate) {
  if (notificationdate_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete notificationdate_;
  }
  if (notificationdate) {
    set_has_notificationdate();
    notificationdate_ = notificationdate;
  } else {
    clear_has_notificationdate();
    notificationdate_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.EventContent.NotificationDate)
}

// repeated .Diadoc.Api.Proto.Invoicing.CorrectionBase CorrectionBase = 5;
inline int EventContent::correctionbase_size() const {
  return correctionbase_.size();
}
inline void EventContent::clear_correctionbase() {
  correctionbase_.Clear();
}
inline const ::Diadoc::Api::Proto::Invoicing::CorrectionBase& EventContent::correctionbase(int index) const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.EventContent.CorrectionBase)
  return correctionbase_.Get(index);
}
inline ::Diadoc::Api::Proto::Invoicing::CorrectionBase* EventContent::mutable_correctionbase(int index) {
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.EventContent.CorrectionBase)
  return correctionbase_.Mutable(index);
}
inline ::Diadoc::Api::Proto::Invoicing::CorrectionBase* EventContent::add_correctionbase() {
  // @@protoc_insertion_point(field_add:Diadoc.Api.Proto.Invoicing.EventContent.CorrectionBase)
  return correctionbase_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::CorrectionBase >&
EventContent::correctionbase() const {
  // @@protoc_insertion_point(field_list:Diadoc.Api.Proto.Invoicing.EventContent.CorrectionBase)
  return correctionbase_;
}
inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::CorrectionBase >*
EventContent::mutable_correctionbase() {
  // @@protoc_insertion_point(field_mutable_list:Diadoc.Api.Proto.Invoicing.EventContent.CorrectionBase)
  return &correctionbase_;
}

// -------------------------------------------------------------------

// CorrectionBase

// required string BaseDocumentName = 1;
inline bool CorrectionBase::has_basedocumentname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CorrectionBase::set_has_basedocumentname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CorrectionBase::clear_has_basedocumentname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CorrectionBase::clear_basedocumentname() {
  if (basedocumentname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    basedocumentname_->clear();
  }
  clear_has_basedocumentname();
}
inline const ::std::string& CorrectionBase::basedocumentname() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.CorrectionBase.BaseDocumentName)
  return *basedocumentname_;
}
inline void CorrectionBase::set_basedocumentname(const ::std::string& value) {
  set_has_basedocumentname();
  if (basedocumentname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    basedocumentname_ = new ::std::string;
  }
  basedocumentname_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.CorrectionBase.BaseDocumentName)
}
inline void CorrectionBase::set_basedocumentname(const char* value) {
  set_has_basedocumentname();
  if (basedocumentname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    basedocumentname_ = new ::std::string;
  }
  basedocumentname_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.CorrectionBase.BaseDocumentName)
}
inline void CorrectionBase::set_basedocumentname(const char* value, size_t size) {
  set_has_basedocumentname();
  if (basedocumentname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    basedocumentname_ = new ::std::string;
  }
  basedocumentname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.CorrectionBase.BaseDocumentName)
}
inline ::std::string* CorrectionBase::mutable_basedocumentname() {
  set_has_basedocumentname();
  if (basedocumentname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    basedocumentname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.CorrectionBase.BaseDocumentName)
  return basedocumentname_;
}
inline ::std::string* CorrectionBase::release_basedocumentname() {
  clear_has_basedocumentname();
  if (basedocumentname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = basedocumentname_;
    basedocumentname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CorrectionBase::set_allocated_basedocumentname(::std::string* basedocumentname) {
  if (basedocumentname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete basedocumentname_;
  }
  if (basedocumentname) {
    set_has_basedocumentname();
    basedocumentname_ = basedocumentname;
  } else {
    clear_has_basedocumentname();
    basedocumentname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.CorrectionBase.BaseDocumentName)
}

// optional string BaseDocumentNumber = 2;
inline bool CorrectionBase::has_basedocumentnumber() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CorrectionBase::set_has_basedocumentnumber() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CorrectionBase::clear_has_basedocumentnumber() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CorrectionBase::clear_basedocumentnumber() {
  if (basedocumentnumber_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    basedocumentnumber_->clear();
  }
  clear_has_basedocumentnumber();
}
inline const ::std::string& CorrectionBase::basedocumentnumber() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.CorrectionBase.BaseDocumentNumber)
  return *basedocumentnumber_;
}
inline void CorrectionBase::set_basedocumentnumber(const ::std::string& value) {
  set_has_basedocumentnumber();
  if (basedocumentnumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    basedocumentnumber_ = new ::std::string;
  }
  basedocumentnumber_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.CorrectionBase.BaseDocumentNumber)
}
inline void CorrectionBase::set_basedocumentnumber(const char* value) {
  set_has_basedocumentnumber();
  if (basedocumentnumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    basedocumentnumber_ = new ::std::string;
  }
  basedocumentnumber_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.CorrectionBase.BaseDocumentNumber)
}
inline void CorrectionBase::set_basedocumentnumber(const char* value, size_t size) {
  set_has_basedocumentnumber();
  if (basedocumentnumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    basedocumentnumber_ = new ::std::string;
  }
  basedocumentnumber_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.CorrectionBase.BaseDocumentNumber)
}
inline ::std::string* CorrectionBase::mutable_basedocumentnumber() {
  set_has_basedocumentnumber();
  if (basedocumentnumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    basedocumentnumber_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.CorrectionBase.BaseDocumentNumber)
  return basedocumentnumber_;
}
inline ::std::string* CorrectionBase::release_basedocumentnumber() {
  clear_has_basedocumentnumber();
  if (basedocumentnumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = basedocumentnumber_;
    basedocumentnumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CorrectionBase::set_allocated_basedocumentnumber(::std::string* basedocumentnumber) {
  if (basedocumentnumber_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete basedocumentnumber_;
  }
  if (basedocumentnumber) {
    set_has_basedocumentnumber();
    basedocumentnumber_ = basedocumentnumber;
  } else {
    clear_has_basedocumentnumber();
    basedocumentnumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.CorrectionBase.BaseDocumentNumber)
}

// optional string BaseDocumentDate = 3;
inline bool CorrectionBase::has_basedocumentdate() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CorrectionBase::set_has_basedocumentdate() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CorrectionBase::clear_has_basedocumentdate() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CorrectionBase::clear_basedocumentdate() {
  if (basedocumentdate_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    basedocumentdate_->clear();
  }
  clear_has_basedocumentdate();
}
inline const ::std::string& CorrectionBase::basedocumentdate() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.CorrectionBase.BaseDocumentDate)
  return *basedocumentdate_;
}
inline void CorrectionBase::set_basedocumentdate(const ::std::string& value) {
  set_has_basedocumentdate();
  if (basedocumentdate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    basedocumentdate_ = new ::std::string;
  }
  basedocumentdate_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.CorrectionBase.BaseDocumentDate)
}
inline void CorrectionBase::set_basedocumentdate(const char* value) {
  set_has_basedocumentdate();
  if (basedocumentdate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    basedocumentdate_ = new ::std::string;
  }
  basedocumentdate_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.CorrectionBase.BaseDocumentDate)
}
inline void CorrectionBase::set_basedocumentdate(const char* value, size_t size) {
  set_has_basedocumentdate();
  if (basedocumentdate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    basedocumentdate_ = new ::std::string;
  }
  basedocumentdate_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.CorrectionBase.BaseDocumentDate)
}
inline ::std::string* CorrectionBase::mutable_basedocumentdate() {
  set_has_basedocumentdate();
  if (basedocumentdate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    basedocumentdate_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.CorrectionBase.BaseDocumentDate)
  return basedocumentdate_;
}
inline ::std::string* CorrectionBase::release_basedocumentdate() {
  clear_has_basedocumentdate();
  if (basedocumentdate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = basedocumentdate_;
    basedocumentdate_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CorrectionBase::set_allocated_basedocumentdate(::std::string* basedocumentdate) {
  if (basedocumentdate_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete basedocumentdate_;
  }
  if (basedocumentdate) {
    set_has_basedocumentdate();
    basedocumentdate_ = basedocumentdate;
  } else {
    clear_has_basedocumentdate();
    basedocumentdate_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.CorrectionBase.BaseDocumentDate)
}

// optional string AdditionalInfo = 4;
inline bool CorrectionBase::has_additionalinfo() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CorrectionBase::set_has_additionalinfo() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CorrectionBase::clear_has_additionalinfo() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CorrectionBase::clear_additionalinfo() {
  if (additionalinfo_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    additionalinfo_->clear();
  }
  clear_has_additionalinfo();
}
inline const ::std::string& CorrectionBase::additionalinfo() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.CorrectionBase.AdditionalInfo)
  return *additionalinfo_;
}
inline void CorrectionBase::set_additionalinfo(const ::std::string& value) {
  set_has_additionalinfo();
  if (additionalinfo_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    additionalinfo_ = new ::std::string;
  }
  additionalinfo_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.CorrectionBase.AdditionalInfo)
}
inline void CorrectionBase::set_additionalinfo(const char* value) {
  set_has_additionalinfo();
  if (additionalinfo_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    additionalinfo_ = new ::std::string;
  }
  additionalinfo_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.CorrectionBase.AdditionalInfo)
}
inline void CorrectionBase::set_additionalinfo(const char* value, size_t size) {
  set_has_additionalinfo();
  if (additionalinfo_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    additionalinfo_ = new ::std::string;
  }
  additionalinfo_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.CorrectionBase.AdditionalInfo)
}
inline ::std::string* CorrectionBase::mutable_additionalinfo() {
  set_has_additionalinfo();
  if (additionalinfo_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    additionalinfo_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.CorrectionBase.AdditionalInfo)
  return additionalinfo_;
}
inline ::std::string* CorrectionBase::release_additionalinfo() {
  clear_has_additionalinfo();
  if (additionalinfo_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = additionalinfo_;
    additionalinfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CorrectionBase::set_allocated_additionalinfo(::std::string* additionalinfo) {
  if (additionalinfo_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete additionalinfo_;
  }
  if (additionalinfo) {
    set_has_additionalinfo();
    additionalinfo_ = additionalinfo;
  } else {
    clear_has_additionalinfo();
    additionalinfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.CorrectionBase.AdditionalInfo)
}

// -------------------------------------------------------------------

// InvoiceCorrectionTable

// repeated .Diadoc.Api.Proto.Invoicing.ExtendedInvoiceCorrectionItem Items = 1;
inline int InvoiceCorrectionTable::items_size() const {
  return items_.size();
}
inline void InvoiceCorrectionTable::clear_items() {
  items_.Clear();
}
inline const ::Diadoc::Api::Proto::Invoicing::ExtendedInvoiceCorrectionItem& InvoiceCorrectionTable::items(int index) const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.InvoiceCorrectionTable.Items)
  return items_.Get(index);
}
inline ::Diadoc::Api::Proto::Invoicing::ExtendedInvoiceCorrectionItem* InvoiceCorrectionTable::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.InvoiceCorrectionTable.Items)
  return items_.Mutable(index);
}
inline ::Diadoc::Api::Proto::Invoicing::ExtendedInvoiceCorrectionItem* InvoiceCorrectionTable::add_items() {
  // @@protoc_insertion_point(field_add:Diadoc.Api.Proto.Invoicing.InvoiceCorrectionTable.Items)
  return items_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::ExtendedInvoiceCorrectionItem >&
InvoiceCorrectionTable::items() const {
  // @@protoc_insertion_point(field_list:Diadoc.Api.Proto.Invoicing.InvoiceCorrectionTable.Items)
  return items_;
}
inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::ExtendedInvoiceCorrectionItem >*
InvoiceCorrectionTable::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:Diadoc.Api.Proto.Invoicing.InvoiceCorrectionTable.Items)
  return &items_;
}

// optional .Diadoc.Api.Proto.Invoicing.InvoiceTotalsDiff TotalsInc = 2;
inline bool InvoiceCorrectionTable::has_totalsinc() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InvoiceCorrectionTable::set_has_totalsinc() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InvoiceCorrectionTable::clear_has_totalsinc() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InvoiceCorrectionTable::clear_totalsinc() {
  if (totalsinc_ != NULL) totalsinc_->::Diadoc::Api::Proto::Invoicing::InvoiceTotalsDiff::Clear();
  clear_has_totalsinc();
}
inline const ::Diadoc::Api::Proto::Invoicing::InvoiceTotalsDiff& InvoiceCorrectionTable::totalsinc() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.InvoiceCorrectionTable.TotalsInc)
  return totalsinc_ != NULL ? *totalsinc_ : *default_instance_->totalsinc_;
}
inline ::Diadoc::Api::Proto::Invoicing::InvoiceTotalsDiff* InvoiceCorrectionTable::mutable_totalsinc() {
  set_has_totalsinc();
  if (totalsinc_ == NULL) totalsinc_ = new ::Diadoc::Api::Proto::Invoicing::InvoiceTotalsDiff;
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.InvoiceCorrectionTable.TotalsInc)
  return totalsinc_;
}
inline ::Diadoc::Api::Proto::Invoicing::InvoiceTotalsDiff* InvoiceCorrectionTable::release_totalsinc() {
  clear_has_totalsinc();
  ::Diadoc::Api::Proto::Invoicing::InvoiceTotalsDiff* temp = totalsinc_;
  totalsinc_ = NULL;
  return temp;
}
inline void InvoiceCorrectionTable::set_allocated_totalsinc(::Diadoc::Api::Proto::Invoicing::InvoiceTotalsDiff* totalsinc) {
  delete totalsinc_;
  totalsinc_ = totalsinc;
  if (totalsinc) {
    set_has_totalsinc();
  } else {
    clear_has_totalsinc();
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.InvoiceCorrectionTable.TotalsInc)
}

// optional .Diadoc.Api.Proto.Invoicing.InvoiceTotalsDiff TotalsDec = 3;
inline bool InvoiceCorrectionTable::has_totalsdec() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InvoiceCorrectionTable::set_has_totalsdec() {
  _has_bits_[0] |= 0x00000004u;
}
inline void InvoiceCorrectionTable::clear_has_totalsdec() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void InvoiceCorrectionTable::clear_totalsdec() {
  if (totalsdec_ != NULL) totalsdec_->::Diadoc::Api::Proto::Invoicing::InvoiceTotalsDiff::Clear();
  clear_has_totalsdec();
}
inline const ::Diadoc::Api::Proto::Invoicing::InvoiceTotalsDiff& InvoiceCorrectionTable::totalsdec() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.InvoiceCorrectionTable.TotalsDec)
  return totalsdec_ != NULL ? *totalsdec_ : *default_instance_->totalsdec_;
}
inline ::Diadoc::Api::Proto::Invoicing::InvoiceTotalsDiff* InvoiceCorrectionTable::mutable_totalsdec() {
  set_has_totalsdec();
  if (totalsdec_ == NULL) totalsdec_ = new ::Diadoc::Api::Proto::Invoicing::InvoiceTotalsDiff;
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.InvoiceCorrectionTable.TotalsDec)
  return totalsdec_;
}
inline ::Diadoc::Api::Proto::Invoicing::InvoiceTotalsDiff* InvoiceCorrectionTable::release_totalsdec() {
  clear_has_totalsdec();
  ::Diadoc::Api::Proto::Invoicing::InvoiceTotalsDiff* temp = totalsdec_;
  totalsdec_ = NULL;
  return temp;
}
inline void InvoiceCorrectionTable::set_allocated_totalsdec(::Diadoc::Api::Proto::Invoicing::InvoiceTotalsDiff* totalsdec) {
  delete totalsdec_;
  totalsdec_ = totalsdec;
  if (totalsdec) {
    set_has_totalsdec();
  } else {
    clear_has_totalsdec();
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.InvoiceCorrectionTable.TotalsDec)
}

// -------------------------------------------------------------------

// ExtendedInvoiceCorrectionItem

// required string Product = 1;
inline bool ExtendedInvoiceCorrectionItem::has_product() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ExtendedInvoiceCorrectionItem::set_has_product() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ExtendedInvoiceCorrectionItem::clear_has_product() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ExtendedInvoiceCorrectionItem::clear_product() {
  if (product_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    product_->clear();
  }
  clear_has_product();
}
inline const ::std::string& ExtendedInvoiceCorrectionItem::product() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.ExtendedInvoiceCorrectionItem.Product)
  return *product_;
}
inline void ExtendedInvoiceCorrectionItem::set_product(const ::std::string& value) {
  set_has_product();
  if (product_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    product_ = new ::std::string;
  }
  product_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.ExtendedInvoiceCorrectionItem.Product)
}
inline void ExtendedInvoiceCorrectionItem::set_product(const char* value) {
  set_has_product();
  if (product_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    product_ = new ::std::string;
  }
  product_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.ExtendedInvoiceCorrectionItem.Product)
}
inline void ExtendedInvoiceCorrectionItem::set_product(const char* value, size_t size) {
  set_has_product();
  if (product_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    product_ = new ::std::string;
  }
  product_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.ExtendedInvoiceCorrectionItem.Product)
}
inline ::std::string* ExtendedInvoiceCorrectionItem::mutable_product() {
  set_has_product();
  if (product_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    product_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.ExtendedInvoiceCorrectionItem.Product)
  return product_;
}
inline ::std::string* ExtendedInvoiceCorrectionItem::release_product() {
  clear_has_product();
  if (product_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = product_;
    product_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ExtendedInvoiceCorrectionItem::set_allocated_product(::std::string* product) {
  if (product_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete product_;
  }
  if (product) {
    set_has_product();
    product_ = product;
  } else {
    clear_has_product();
    product_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.ExtendedInvoiceCorrectionItem.Product)
}

// required .Diadoc.Api.Proto.Invoicing.CorrectableInvoiceItemFields OriginalValues = 2;
inline bool ExtendedInvoiceCorrectionItem::has_originalvalues() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ExtendedInvoiceCorrectionItem::set_has_originalvalues() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ExtendedInvoiceCorrectionItem::clear_has_originalvalues() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ExtendedInvoiceCorrectionItem::clear_originalvalues() {
  if (originalvalues_ != NULL) originalvalues_->::Diadoc::Api::Proto::Invoicing::CorrectableInvoiceItemFields::Clear();
  clear_has_originalvalues();
}
inline const ::Diadoc::Api::Proto::Invoicing::CorrectableInvoiceItemFields& ExtendedInvoiceCorrectionItem::originalvalues() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.ExtendedInvoiceCorrectionItem.OriginalValues)
  return originalvalues_ != NULL ? *originalvalues_ : *default_instance_->originalvalues_;
}
inline ::Diadoc::Api::Proto::Invoicing::CorrectableInvoiceItemFields* ExtendedInvoiceCorrectionItem::mutable_originalvalues() {
  set_has_originalvalues();
  if (originalvalues_ == NULL) originalvalues_ = new ::Diadoc::Api::Proto::Invoicing::CorrectableInvoiceItemFields;
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.ExtendedInvoiceCorrectionItem.OriginalValues)
  return originalvalues_;
}
inline ::Diadoc::Api::Proto::Invoicing::CorrectableInvoiceItemFields* ExtendedInvoiceCorrectionItem::release_originalvalues() {
  clear_has_originalvalues();
  ::Diadoc::Api::Proto::Invoicing::CorrectableInvoiceItemFields* temp = originalvalues_;
  originalvalues_ = NULL;
  return temp;
}
inline void ExtendedInvoiceCorrectionItem::set_allocated_originalvalues(::Diadoc::Api::Proto::Invoicing::CorrectableInvoiceItemFields* originalvalues) {
  delete originalvalues_;
  originalvalues_ = originalvalues;
  if (originalvalues) {
    set_has_originalvalues();
  } else {
    clear_has_originalvalues();
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.ExtendedInvoiceCorrectionItem.OriginalValues)
}

// required .Diadoc.Api.Proto.Invoicing.CorrectableInvoiceItemFields CorrectedValues = 3;
inline bool ExtendedInvoiceCorrectionItem::has_correctedvalues() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ExtendedInvoiceCorrectionItem::set_has_correctedvalues() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ExtendedInvoiceCorrectionItem::clear_has_correctedvalues() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ExtendedInvoiceCorrectionItem::clear_correctedvalues() {
  if (correctedvalues_ != NULL) correctedvalues_->::Diadoc::Api::Proto::Invoicing::CorrectableInvoiceItemFields::Clear();
  clear_has_correctedvalues();
}
inline const ::Diadoc::Api::Proto::Invoicing::CorrectableInvoiceItemFields& ExtendedInvoiceCorrectionItem::correctedvalues() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.ExtendedInvoiceCorrectionItem.CorrectedValues)
  return correctedvalues_ != NULL ? *correctedvalues_ : *default_instance_->correctedvalues_;
}
inline ::Diadoc::Api::Proto::Invoicing::CorrectableInvoiceItemFields* ExtendedInvoiceCorrectionItem::mutable_correctedvalues() {
  set_has_correctedvalues();
  if (correctedvalues_ == NULL) correctedvalues_ = new ::Diadoc::Api::Proto::Invoicing::CorrectableInvoiceItemFields;
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.ExtendedInvoiceCorrectionItem.CorrectedValues)
  return correctedvalues_;
}
inline ::Diadoc::Api::Proto::Invoicing::CorrectableInvoiceItemFields* ExtendedInvoiceCorrectionItem::release_correctedvalues() {
  clear_has_correctedvalues();
  ::Diadoc::Api::Proto::Invoicing::CorrectableInvoiceItemFields* temp = correctedvalues_;
  correctedvalues_ = NULL;
  return temp;
}
inline void ExtendedInvoiceCorrectionItem::set_allocated_correctedvalues(::Diadoc::Api::Proto::Invoicing::CorrectableInvoiceItemFields* correctedvalues) {
  delete correctedvalues_;
  correctedvalues_ = correctedvalues;
  if (correctedvalues) {
    set_has_correctedvalues();
  } else {
    clear_has_correctedvalues();
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.ExtendedInvoiceCorrectionItem.CorrectedValues)
}

// optional .Diadoc.Api.Proto.Invoicing.InvoiceItemAmountsDiff AmountsInc = 4;
inline bool ExtendedInvoiceCorrectionItem::has_amountsinc() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ExtendedInvoiceCorrectionItem::set_has_amountsinc() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ExtendedInvoiceCorrectionItem::clear_has_amountsinc() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ExtendedInvoiceCorrectionItem::clear_amountsinc() {
  if (amountsinc_ != NULL) amountsinc_->::Diadoc::Api::Proto::Invoicing::InvoiceItemAmountsDiff::Clear();
  clear_has_amountsinc();
}
inline const ::Diadoc::Api::Proto::Invoicing::InvoiceItemAmountsDiff& ExtendedInvoiceCorrectionItem::amountsinc() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.ExtendedInvoiceCorrectionItem.AmountsInc)
  return amountsinc_ != NULL ? *amountsinc_ : *default_instance_->amountsinc_;
}
inline ::Diadoc::Api::Proto::Invoicing::InvoiceItemAmountsDiff* ExtendedInvoiceCorrectionItem::mutable_amountsinc() {
  set_has_amountsinc();
  if (amountsinc_ == NULL) amountsinc_ = new ::Diadoc::Api::Proto::Invoicing::InvoiceItemAmountsDiff;
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.ExtendedInvoiceCorrectionItem.AmountsInc)
  return amountsinc_;
}
inline ::Diadoc::Api::Proto::Invoicing::InvoiceItemAmountsDiff* ExtendedInvoiceCorrectionItem::release_amountsinc() {
  clear_has_amountsinc();
  ::Diadoc::Api::Proto::Invoicing::InvoiceItemAmountsDiff* temp = amountsinc_;
  amountsinc_ = NULL;
  return temp;
}
inline void ExtendedInvoiceCorrectionItem::set_allocated_amountsinc(::Diadoc::Api::Proto::Invoicing::InvoiceItemAmountsDiff* amountsinc) {
  delete amountsinc_;
  amountsinc_ = amountsinc;
  if (amountsinc) {
    set_has_amountsinc();
  } else {
    clear_has_amountsinc();
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.ExtendedInvoiceCorrectionItem.AmountsInc)
}

// optional .Diadoc.Api.Proto.Invoicing.InvoiceItemAmountsDiff AmountsDec = 5;
inline bool ExtendedInvoiceCorrectionItem::has_amountsdec() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ExtendedInvoiceCorrectionItem::set_has_amountsdec() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ExtendedInvoiceCorrectionItem::clear_has_amountsdec() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ExtendedInvoiceCorrectionItem::clear_amountsdec() {
  if (amountsdec_ != NULL) amountsdec_->::Diadoc::Api::Proto::Invoicing::InvoiceItemAmountsDiff::Clear();
  clear_has_amountsdec();
}
inline const ::Diadoc::Api::Proto::Invoicing::InvoiceItemAmountsDiff& ExtendedInvoiceCorrectionItem::amountsdec() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.ExtendedInvoiceCorrectionItem.AmountsDec)
  return amountsdec_ != NULL ? *amountsdec_ : *default_instance_->amountsdec_;
}
inline ::Diadoc::Api::Proto::Invoicing::InvoiceItemAmountsDiff* ExtendedInvoiceCorrectionItem::mutable_amountsdec() {
  set_has_amountsdec();
  if (amountsdec_ == NULL) amountsdec_ = new ::Diadoc::Api::Proto::Invoicing::InvoiceItemAmountsDiff;
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.ExtendedInvoiceCorrectionItem.AmountsDec)
  return amountsdec_;
}
inline ::Diadoc::Api::Proto::Invoicing::InvoiceItemAmountsDiff* ExtendedInvoiceCorrectionItem::release_amountsdec() {
  clear_has_amountsdec();
  ::Diadoc::Api::Proto::Invoicing::InvoiceItemAmountsDiff* temp = amountsdec_;
  amountsdec_ = NULL;
  return temp;
}
inline void ExtendedInvoiceCorrectionItem::set_allocated_amountsdec(::Diadoc::Api::Proto::Invoicing::InvoiceItemAmountsDiff* amountsdec) {
  delete amountsdec_;
  amountsdec_ = amountsdec;
  if (amountsdec) {
    set_has_amountsdec();
  } else {
    clear_has_amountsdec();
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.ExtendedInvoiceCorrectionItem.AmountsDec)
}

// optional string ItemAccountDebit = 6;
inline bool ExtendedInvoiceCorrectionItem::has_itemaccountdebit() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ExtendedInvoiceCorrectionItem::set_has_itemaccountdebit() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ExtendedInvoiceCorrectionItem::clear_has_itemaccountdebit() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ExtendedInvoiceCorrectionItem::clear_itemaccountdebit() {
  if (itemaccountdebit_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    itemaccountdebit_->clear();
  }
  clear_has_itemaccountdebit();
}
inline const ::std::string& ExtendedInvoiceCorrectionItem::itemaccountdebit() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.ExtendedInvoiceCorrectionItem.ItemAccountDebit)
  return *itemaccountdebit_;
}
inline void ExtendedInvoiceCorrectionItem::set_itemaccountdebit(const ::std::string& value) {
  set_has_itemaccountdebit();
  if (itemaccountdebit_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    itemaccountdebit_ = new ::std::string;
  }
  itemaccountdebit_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.ExtendedInvoiceCorrectionItem.ItemAccountDebit)
}
inline void ExtendedInvoiceCorrectionItem::set_itemaccountdebit(const char* value) {
  set_has_itemaccountdebit();
  if (itemaccountdebit_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    itemaccountdebit_ = new ::std::string;
  }
  itemaccountdebit_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.ExtendedInvoiceCorrectionItem.ItemAccountDebit)
}
inline void ExtendedInvoiceCorrectionItem::set_itemaccountdebit(const char* value, size_t size) {
  set_has_itemaccountdebit();
  if (itemaccountdebit_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    itemaccountdebit_ = new ::std::string;
  }
  itemaccountdebit_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.ExtendedInvoiceCorrectionItem.ItemAccountDebit)
}
inline ::std::string* ExtendedInvoiceCorrectionItem::mutable_itemaccountdebit() {
  set_has_itemaccountdebit();
  if (itemaccountdebit_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    itemaccountdebit_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.ExtendedInvoiceCorrectionItem.ItemAccountDebit)
  return itemaccountdebit_;
}
inline ::std::string* ExtendedInvoiceCorrectionItem::release_itemaccountdebit() {
  clear_has_itemaccountdebit();
  if (itemaccountdebit_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = itemaccountdebit_;
    itemaccountdebit_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ExtendedInvoiceCorrectionItem::set_allocated_itemaccountdebit(::std::string* itemaccountdebit) {
  if (itemaccountdebit_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete itemaccountdebit_;
  }
  if (itemaccountdebit) {
    set_has_itemaccountdebit();
    itemaccountdebit_ = itemaccountdebit;
  } else {
    clear_has_itemaccountdebit();
    itemaccountdebit_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.ExtendedInvoiceCorrectionItem.ItemAccountDebit)
}

// optional string ItemAccountCredit = 7;
inline bool ExtendedInvoiceCorrectionItem::has_itemaccountcredit() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ExtendedInvoiceCorrectionItem::set_has_itemaccountcredit() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ExtendedInvoiceCorrectionItem::clear_has_itemaccountcredit() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ExtendedInvoiceCorrectionItem::clear_itemaccountcredit() {
  if (itemaccountcredit_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    itemaccountcredit_->clear();
  }
  clear_has_itemaccountcredit();
}
inline const ::std::string& ExtendedInvoiceCorrectionItem::itemaccountcredit() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.ExtendedInvoiceCorrectionItem.ItemAccountCredit)
  return *itemaccountcredit_;
}
inline void ExtendedInvoiceCorrectionItem::set_itemaccountcredit(const ::std::string& value) {
  set_has_itemaccountcredit();
  if (itemaccountcredit_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    itemaccountcredit_ = new ::std::string;
  }
  itemaccountcredit_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.ExtendedInvoiceCorrectionItem.ItemAccountCredit)
}
inline void ExtendedInvoiceCorrectionItem::set_itemaccountcredit(const char* value) {
  set_has_itemaccountcredit();
  if (itemaccountcredit_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    itemaccountcredit_ = new ::std::string;
  }
  itemaccountcredit_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.ExtendedInvoiceCorrectionItem.ItemAccountCredit)
}
inline void ExtendedInvoiceCorrectionItem::set_itemaccountcredit(const char* value, size_t size) {
  set_has_itemaccountcredit();
  if (itemaccountcredit_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    itemaccountcredit_ = new ::std::string;
  }
  itemaccountcredit_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.ExtendedInvoiceCorrectionItem.ItemAccountCredit)
}
inline ::std::string* ExtendedInvoiceCorrectionItem::mutable_itemaccountcredit() {
  set_has_itemaccountcredit();
  if (itemaccountcredit_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    itemaccountcredit_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.ExtendedInvoiceCorrectionItem.ItemAccountCredit)
  return itemaccountcredit_;
}
inline ::std::string* ExtendedInvoiceCorrectionItem::release_itemaccountcredit() {
  clear_has_itemaccountcredit();
  if (itemaccountcredit_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = itemaccountcredit_;
    itemaccountcredit_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ExtendedInvoiceCorrectionItem::set_allocated_itemaccountcredit(::std::string* itemaccountcredit) {
  if (itemaccountcredit_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete itemaccountcredit_;
  }
  if (itemaccountcredit) {
    set_has_itemaccountcredit();
    itemaccountcredit_ = itemaccountcredit;
  } else {
    clear_has_itemaccountcredit();
    itemaccountcredit_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.ExtendedInvoiceCorrectionItem.ItemAccountCredit)
}

// repeated .Diadoc.Api.Proto.Invoicing.AdditionalInfo AdditionalInfo = 8;
inline int ExtendedInvoiceCorrectionItem::additionalinfo_size() const {
  return additionalinfo_.size();
}
inline void ExtendedInvoiceCorrectionItem::clear_additionalinfo() {
  additionalinfo_.Clear();
}
inline const ::Diadoc::Api::Proto::Invoicing::AdditionalInfo& ExtendedInvoiceCorrectionItem::additionalinfo(int index) const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.ExtendedInvoiceCorrectionItem.AdditionalInfo)
  return additionalinfo_.Get(index);
}
inline ::Diadoc::Api::Proto::Invoicing::AdditionalInfo* ExtendedInvoiceCorrectionItem::mutable_additionalinfo(int index) {
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.ExtendedInvoiceCorrectionItem.AdditionalInfo)
  return additionalinfo_.Mutable(index);
}
inline ::Diadoc::Api::Proto::Invoicing::AdditionalInfo* ExtendedInvoiceCorrectionItem::add_additionalinfo() {
  // @@protoc_insertion_point(field_add:Diadoc.Api.Proto.Invoicing.ExtendedInvoiceCorrectionItem.AdditionalInfo)
  return additionalinfo_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::AdditionalInfo >&
ExtendedInvoiceCorrectionItem::additionalinfo() const {
  // @@protoc_insertion_point(field_list:Diadoc.Api.Proto.Invoicing.ExtendedInvoiceCorrectionItem.AdditionalInfo)
  return additionalinfo_;
}
inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::AdditionalInfo >*
ExtendedInvoiceCorrectionItem::mutable_additionalinfo() {
  // @@protoc_insertion_point(field_mutable_list:Diadoc.Api.Proto.Invoicing.ExtendedInvoiceCorrectionItem.AdditionalInfo)
  return &additionalinfo_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace Invoicing
}  // namespace Proto
}  // namespace Api
}  // namespace Diadoc

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::Diadoc::Api::Proto::Invoicing::FunctionType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Diadoc::Api::Proto::Invoicing::FunctionType>() {
  return ::Diadoc::Api::Proto::Invoicing::FunctionType_descriptor();
}
template <> struct is_proto_enum< ::Diadoc::Api::Proto::Invoicing::ItemMark> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Diadoc::Api::Proto::Invoicing::ItemMark>() {
  return ::Diadoc::Api::Proto::Invoicing::ItemMark_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_Invoicing_2fUniversalTransferDocumentInfo_2eproto__INCLUDED
