// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Invoicing/TovTorgInfo.proto

#ifndef PROTOBUF_Invoicing_2fTovTorgInfo_2eproto__INCLUDED
#define PROTOBUF_Invoicing_2fTovTorgInfo_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include "Invoicing/InvoiceInfo.pb.h"
#include "Invoicing/ExtendedSigner.pb.h"
#include "Invoicing/ExtendedOrganizationInfo.pb.h"
#include "Invoicing/UniversalTransferDocumentInfo.pb.h"
// @@protoc_insertion_point(includes)

namespace Diadoc {
namespace Api {
namespace Proto {
namespace Invoicing {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_Invoicing_2fTovTorgInfo_2eproto();
void protobuf_AssignDesc_Invoicing_2fTovTorgInfo_2eproto();
void protobuf_ShutdownFile_Invoicing_2fTovTorgInfo_2eproto();

class TovTorgSellerTitleInfo;
class TovTorgBuyerTitleInfo;
class TovTorgTable;
class TovTorgItem;
class TovTorgTransferInfo;
class GroundInfo;

// ===================================================================

class TovTorgSellerTitleInfo : public ::google::protobuf::Message {
 public:
  TovTorgSellerTitleInfo();
  virtual ~TovTorgSellerTitleInfo();

  TovTorgSellerTitleInfo(const TovTorgSellerTitleInfo& from);

  inline TovTorgSellerTitleInfo& operator=(const TovTorgSellerTitleInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TovTorgSellerTitleInfo& default_instance();

  void Swap(TovTorgSellerTitleInfo* other);

  // implements Message ----------------------------------------------

  TovTorgSellerTitleInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TovTorgSellerTitleInfo& from);
  void MergeFrom(const TovTorgSellerTitleInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Diadoc.Api.Proto.Invoicing.Organizations.ExtendedOrganizationInfo Seller = 1;
  inline bool has_seller() const;
  inline void clear_seller();
  static const int kSellerFieldNumber = 1;
  inline const ::Diadoc::Api::Proto::Invoicing::Organizations::ExtendedOrganizationInfo& seller() const;
  inline ::Diadoc::Api::Proto::Invoicing::Organizations::ExtendedOrganizationInfo* mutable_seller();
  inline ::Diadoc::Api::Proto::Invoicing::Organizations::ExtendedOrganizationInfo* release_seller();
  inline void set_allocated_seller(::Diadoc::Api::Proto::Invoicing::Organizations::ExtendedOrganizationInfo* seller);

  // required .Diadoc.Api.Proto.Invoicing.Organizations.ExtendedOrganizationInfo Buyer = 2;
  inline bool has_buyer() const;
  inline void clear_buyer();
  static const int kBuyerFieldNumber = 2;
  inline const ::Diadoc::Api::Proto::Invoicing::Organizations::ExtendedOrganizationInfo& buyer() const;
  inline ::Diadoc::Api::Proto::Invoicing::Organizations::ExtendedOrganizationInfo* mutable_buyer();
  inline ::Diadoc::Api::Proto::Invoicing::Organizations::ExtendedOrganizationInfo* release_buyer();
  inline void set_allocated_buyer(::Diadoc::Api::Proto::Invoicing::Organizations::ExtendedOrganizationInfo* buyer);

  // optional .Diadoc.Api.Proto.Invoicing.Organizations.ExtendedOrganizationInfo Shipper = 3;
  inline bool has_shipper() const;
  inline void clear_shipper();
  static const int kShipperFieldNumber = 3;
  inline const ::Diadoc::Api::Proto::Invoicing::Organizations::ExtendedOrganizationInfo& shipper() const;
  inline ::Diadoc::Api::Proto::Invoicing::Organizations::ExtendedOrganizationInfo* mutable_shipper();
  inline ::Diadoc::Api::Proto::Invoicing::Organizations::ExtendedOrganizationInfo* release_shipper();
  inline void set_allocated_shipper(::Diadoc::Api::Proto::Invoicing::Organizations::ExtendedOrganizationInfo* shipper);

  // optional .Diadoc.Api.Proto.Invoicing.Organizations.ExtendedOrganizationInfo Consignee = 4;
  inline bool has_consignee() const;
  inline void clear_consignee();
  static const int kConsigneeFieldNumber = 4;
  inline const ::Diadoc::Api::Proto::Invoicing::Organizations::ExtendedOrganizationInfo& consignee() const;
  inline ::Diadoc::Api::Proto::Invoicing::Organizations::ExtendedOrganizationInfo* mutable_consignee();
  inline ::Diadoc::Api::Proto::Invoicing::Organizations::ExtendedOrganizationInfo* release_consignee();
  inline void set_allocated_consignee(::Diadoc::Api::Proto::Invoicing::Organizations::ExtendedOrganizationInfo* consignee);

  // optional .Diadoc.Api.Proto.Invoicing.Organizations.ExtendedOrganizationInfo Carrier = 5;
  inline bool has_carrier() const;
  inline void clear_carrier();
  static const int kCarrierFieldNumber = 5;
  inline const ::Diadoc::Api::Proto::Invoicing::Organizations::ExtendedOrganizationInfo& carrier() const;
  inline ::Diadoc::Api::Proto::Invoicing::Organizations::ExtendedOrganizationInfo* mutable_carrier();
  inline ::Diadoc::Api::Proto::Invoicing::Organizations::ExtendedOrganizationInfo* release_carrier();
  inline void set_allocated_carrier(::Diadoc::Api::Proto::Invoicing::Organizations::ExtendedOrganizationInfo* carrier);

  // repeated .Diadoc.Api.Proto.Invoicing.Signers.ExtendedSigner Signers = 6;
  inline int signers_size() const;
  inline void clear_signers();
  static const int kSignersFieldNumber = 6;
  inline const ::Diadoc::Api::Proto::Invoicing::Signers::ExtendedSigner& signers(int index) const;
  inline ::Diadoc::Api::Proto::Invoicing::Signers::ExtendedSigner* mutable_signers(int index);
  inline ::Diadoc::Api::Proto::Invoicing::Signers::ExtendedSigner* add_signers();
  inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::Signers::ExtendedSigner >&
      signers() const;
  inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::Signers::ExtendedSigner >*
      mutable_signers();

  // repeated .Diadoc.Api.Proto.Invoicing.GroundInfo Grounds = 7;
  inline int grounds_size() const;
  inline void clear_grounds();
  static const int kGroundsFieldNumber = 7;
  inline const ::Diadoc::Api::Proto::Invoicing::GroundInfo& grounds(int index) const;
  inline ::Diadoc::Api::Proto::Invoicing::GroundInfo* mutable_grounds(int index);
  inline ::Diadoc::Api::Proto::Invoicing::GroundInfo* add_grounds();
  inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::GroundInfo >&
      grounds() const;
  inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::GroundInfo >*
      mutable_grounds();

  // required string Currency = 8;
  inline bool has_currency() const;
  inline void clear_currency();
  static const int kCurrencyFieldNumber = 8;
  inline const ::std::string& currency() const;
  inline void set_currency(const ::std::string& value);
  inline void set_currency(const char* value);
  inline void set_currency(const char* value, size_t size);
  inline ::std::string* mutable_currency();
  inline ::std::string* release_currency();
  inline void set_allocated_currency(::std::string* currency);

  // optional string CurrencyRate = 9;
  inline bool has_currencyrate() const;
  inline void clear_currencyrate();
  static const int kCurrencyRateFieldNumber = 9;
  inline const ::std::string& currencyrate() const;
  inline void set_currencyrate(const ::std::string& value);
  inline void set_currencyrate(const char* value);
  inline void set_currencyrate(const char* value, size_t size);
  inline ::std::string* mutable_currencyrate();
  inline ::std::string* release_currencyrate();
  inline void set_allocated_currencyrate(::std::string* currencyrate);

  // required string DocumentDate = 10;
  inline bool has_documentdate() const;
  inline void clear_documentdate();
  static const int kDocumentDateFieldNumber = 10;
  inline const ::std::string& documentdate() const;
  inline void set_documentdate(const ::std::string& value);
  inline void set_documentdate(const char* value);
  inline void set_documentdate(const char* value, size_t size);
  inline ::std::string* mutable_documentdate();
  inline ::std::string* release_documentdate();
  inline void set_allocated_documentdate(::std::string* documentdate);

  // optional string DocumentNumber = 11;
  inline bool has_documentnumber() const;
  inline void clear_documentnumber();
  static const int kDocumentNumberFieldNumber = 11;
  inline const ::std::string& documentnumber() const;
  inline void set_documentnumber(const ::std::string& value);
  inline void set_documentnumber(const char* value);
  inline void set_documentnumber(const char* value, size_t size);
  inline ::std::string* mutable_documentnumber();
  inline ::std::string* release_documentnumber();
  inline void set_allocated_documentnumber(::std::string* documentnumber);

  // optional string RevisionDate = 12;
  inline bool has_revisiondate() const;
  inline void clear_revisiondate();
  static const int kRevisionDateFieldNumber = 12;
  inline const ::std::string& revisiondate() const;
  inline void set_revisiondate(const ::std::string& value);
  inline void set_revisiondate(const char* value);
  inline void set_revisiondate(const char* value, size_t size);
  inline ::std::string* mutable_revisiondate();
  inline ::std::string* release_revisiondate();
  inline void set_allocated_revisiondate(::std::string* revisiondate);

  // optional string RevisionNumber = 13;
  inline bool has_revisionnumber() const;
  inline void clear_revisionnumber();
  static const int kRevisionNumberFieldNumber = 13;
  inline const ::std::string& revisionnumber() const;
  inline void set_revisionnumber(const ::std::string& value);
  inline void set_revisionnumber(const char* value);
  inline void set_revisionnumber(const char* value, size_t size);
  inline ::std::string* mutable_revisionnumber();
  inline ::std::string* release_revisionnumber();
  inline void set_allocated_revisionnumber(::std::string* revisionnumber);

  // required .Diadoc.Api.Proto.Invoicing.TovTorgTransferInfo TransferInfo = 14;
  inline bool has_transferinfo() const;
  inline void clear_transferinfo();
  static const int kTransferInfoFieldNumber = 14;
  inline const ::Diadoc::Api::Proto::Invoicing::TovTorgTransferInfo& transferinfo() const;
  inline ::Diadoc::Api::Proto::Invoicing::TovTorgTransferInfo* mutable_transferinfo();
  inline ::Diadoc::Api::Proto::Invoicing::TovTorgTransferInfo* release_transferinfo();
  inline void set_allocated_transferinfo(::Diadoc::Api::Proto::Invoicing::TovTorgTransferInfo* transferinfo);

  // required string DocumentCreator = 15;
  inline bool has_documentcreator() const;
  inline void clear_documentcreator();
  static const int kDocumentCreatorFieldNumber = 15;
  inline const ::std::string& documentcreator() const;
  inline void set_documentcreator(const ::std::string& value);
  inline void set_documentcreator(const char* value);
  inline void set_documentcreator(const char* value, size_t size);
  inline ::std::string* mutable_documentcreator();
  inline ::std::string* release_documentcreator();
  inline void set_allocated_documentcreator(::std::string* documentcreator);

  // optional string DocumentCreatorBase = 16;
  inline bool has_documentcreatorbase() const;
  inline void clear_documentcreatorbase();
  static const int kDocumentCreatorBaseFieldNumber = 16;
  inline const ::std::string& documentcreatorbase() const;
  inline void set_documentcreatorbase(const ::std::string& value);
  inline void set_documentcreatorbase(const char* value);
  inline void set_documentcreatorbase(const char* value, size_t size);
  inline ::std::string* mutable_documentcreatorbase();
  inline ::std::string* release_documentcreatorbase();
  inline void set_allocated_documentcreatorbase(::std::string* documentcreatorbase);

  // optional string OperationType = 17;
  inline bool has_operationtype() const;
  inline void clear_operationtype();
  static const int kOperationTypeFieldNumber = 17;
  inline const ::std::string& operationtype() const;
  inline void set_operationtype(const ::std::string& value);
  inline void set_operationtype(const char* value);
  inline void set_operationtype(const char* value, size_t size);
  inline ::std::string* mutable_operationtype();
  inline ::std::string* release_operationtype();
  inline void set_allocated_operationtype(::std::string* operationtype);

  // optional string GovernmentContractInfo = 18;
  inline bool has_governmentcontractinfo() const;
  inline void clear_governmentcontractinfo();
  static const int kGovernmentContractInfoFieldNumber = 18;
  inline const ::std::string& governmentcontractinfo() const;
  inline void set_governmentcontractinfo(const ::std::string& value);
  inline void set_governmentcontractinfo(const char* value);
  inline void set_governmentcontractinfo(const char* value, size_t size);
  inline ::std::string* mutable_governmentcontractinfo();
  inline ::std::string* release_governmentcontractinfo();
  inline void set_allocated_governmentcontractinfo(::std::string* governmentcontractinfo);

  // optional .Diadoc.Api.Proto.Invoicing.TovTorgTable Table = 19;
  inline bool has_table() const;
  inline void clear_table();
  static const int kTableFieldNumber = 19;
  inline const ::Diadoc::Api::Proto::Invoicing::TovTorgTable& table() const;
  inline ::Diadoc::Api::Proto::Invoicing::TovTorgTable* mutable_table();
  inline ::Diadoc::Api::Proto::Invoicing::TovTorgTable* release_table();
  inline void set_allocated_table(::Diadoc::Api::Proto::Invoicing::TovTorgTable* table);

  // optional .Diadoc.Api.Proto.Invoicing.AdditionalInfoId AdditionalInfoId = 20;
  inline bool has_additionalinfoid() const;
  inline void clear_additionalinfoid();
  static const int kAdditionalInfoIdFieldNumber = 20;
  inline const ::Diadoc::Api::Proto::Invoicing::AdditionalInfoId& additionalinfoid() const;
  inline ::Diadoc::Api::Proto::Invoicing::AdditionalInfoId* mutable_additionalinfoid();
  inline ::Diadoc::Api::Proto::Invoicing::AdditionalInfoId* release_additionalinfoid();
  inline void set_allocated_additionalinfoid(::Diadoc::Api::Proto::Invoicing::AdditionalInfoId* additionalinfoid);

  // required string DocumentName = 21;
  inline bool has_documentname() const;
  inline void clear_documentname();
  static const int kDocumentNameFieldNumber = 21;
  inline const ::std::string& documentname() const;
  inline void set_documentname(const ::std::string& value);
  inline void set_documentname(const char* value);
  inline void set_documentname(const char* value, size_t size);
  inline ::std::string* mutable_documentname();
  inline ::std::string* release_documentname();
  inline void set_allocated_documentname(::std::string* documentname);

  // @@protoc_insertion_point(class_scope:Diadoc.Api.Proto.Invoicing.TovTorgSellerTitleInfo)
 private:
  inline void set_has_seller();
  inline void clear_has_seller();
  inline void set_has_buyer();
  inline void clear_has_buyer();
  inline void set_has_shipper();
  inline void clear_has_shipper();
  inline void set_has_consignee();
  inline void clear_has_consignee();
  inline void set_has_carrier();
  inline void clear_has_carrier();
  inline void set_has_currency();
  inline void clear_has_currency();
  inline void set_has_currencyrate();
  inline void clear_has_currencyrate();
  inline void set_has_documentdate();
  inline void clear_has_documentdate();
  inline void set_has_documentnumber();
  inline void clear_has_documentnumber();
  inline void set_has_revisiondate();
  inline void clear_has_revisiondate();
  inline void set_has_revisionnumber();
  inline void clear_has_revisionnumber();
  inline void set_has_transferinfo();
  inline void clear_has_transferinfo();
  inline void set_has_documentcreator();
  inline void clear_has_documentcreator();
  inline void set_has_documentcreatorbase();
  inline void clear_has_documentcreatorbase();
  inline void set_has_operationtype();
  inline void clear_has_operationtype();
  inline void set_has_governmentcontractinfo();
  inline void clear_has_governmentcontractinfo();
  inline void set_has_table();
  inline void clear_has_table();
  inline void set_has_additionalinfoid();
  inline void clear_has_additionalinfoid();
  inline void set_has_documentname();
  inline void clear_has_documentname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::Diadoc::Api::Proto::Invoicing::Organizations::ExtendedOrganizationInfo* seller_;
  ::Diadoc::Api::Proto::Invoicing::Organizations::ExtendedOrganizationInfo* buyer_;
  ::Diadoc::Api::Proto::Invoicing::Organizations::ExtendedOrganizationInfo* shipper_;
  ::Diadoc::Api::Proto::Invoicing::Organizations::ExtendedOrganizationInfo* consignee_;
  ::Diadoc::Api::Proto::Invoicing::Organizations::ExtendedOrganizationInfo* carrier_;
  ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::Signers::ExtendedSigner > signers_;
  ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::GroundInfo > grounds_;
  ::std::string* currency_;
  ::std::string* currencyrate_;
  ::std::string* documentdate_;
  ::std::string* documentnumber_;
  ::std::string* revisiondate_;
  ::std::string* revisionnumber_;
  ::Diadoc::Api::Proto::Invoicing::TovTorgTransferInfo* transferinfo_;
  ::std::string* documentcreator_;
  ::std::string* documentcreatorbase_;
  ::std::string* operationtype_;
  ::std::string* governmentcontractinfo_;
  ::Diadoc::Api::Proto::Invoicing::TovTorgTable* table_;
  ::Diadoc::Api::Proto::Invoicing::AdditionalInfoId* additionalinfoid_;
  ::std::string* documentname_;
  friend void  protobuf_AddDesc_Invoicing_2fTovTorgInfo_2eproto();
  friend void protobuf_AssignDesc_Invoicing_2fTovTorgInfo_2eproto();
  friend void protobuf_ShutdownFile_Invoicing_2fTovTorgInfo_2eproto();

  void InitAsDefaultInstance();
  static TovTorgSellerTitleInfo* default_instance_;
};
// -------------------------------------------------------------------

class TovTorgBuyerTitleInfo : public ::google::protobuf::Message {
 public:
  TovTorgBuyerTitleInfo();
  virtual ~TovTorgBuyerTitleInfo();

  TovTorgBuyerTitleInfo(const TovTorgBuyerTitleInfo& from);

  inline TovTorgBuyerTitleInfo& operator=(const TovTorgBuyerTitleInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TovTorgBuyerTitleInfo& default_instance();

  void Swap(TovTorgBuyerTitleInfo* other);

  // implements Message ----------------------------------------------

  TovTorgBuyerTitleInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TovTorgBuyerTitleInfo& from);
  void MergeFrom(const TovTorgBuyerTitleInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string DocumentCreator = 1;
  inline bool has_documentcreator() const;
  inline void clear_documentcreator();
  static const int kDocumentCreatorFieldNumber = 1;
  inline const ::std::string& documentcreator() const;
  inline void set_documentcreator(const ::std::string& value);
  inline void set_documentcreator(const char* value);
  inline void set_documentcreator(const char* value, size_t size);
  inline ::std::string* mutable_documentcreator();
  inline ::std::string* release_documentcreator();
  inline void set_allocated_documentcreator(::std::string* documentcreator);

  // optional string DocumentCreatorBase = 2;
  inline bool has_documentcreatorbase() const;
  inline void clear_documentcreatorbase();
  static const int kDocumentCreatorBaseFieldNumber = 2;
  inline const ::std::string& documentcreatorbase() const;
  inline void set_documentcreatorbase(const ::std::string& value);
  inline void set_documentcreatorbase(const char* value);
  inline void set_documentcreatorbase(const char* value, size_t size);
  inline ::std::string* mutable_documentcreatorbase();
  inline ::std::string* release_documentcreatorbase();
  inline void set_allocated_documentcreatorbase(::std::string* documentcreatorbase);

  // optional string OperationCode = 3;
  inline bool has_operationcode() const;
  inline void clear_operationcode();
  static const int kOperationCodeFieldNumber = 3;
  inline const ::std::string& operationcode() const;
  inline void set_operationcode(const ::std::string& value);
  inline void set_operationcode(const char* value);
  inline void set_operationcode(const char* value, size_t size);
  inline ::std::string* mutable_operationcode();
  inline ::std::string* release_operationcode();
  inline void set_allocated_operationcode(::std::string* operationcode);

  // required string OperationContent = 4;
  inline bool has_operationcontent() const;
  inline void clear_operationcontent();
  static const int kOperationContentFieldNumber = 4;
  inline const ::std::string& operationcontent() const;
  inline void set_operationcontent(const ::std::string& value);
  inline void set_operationcontent(const char* value);
  inline void set_operationcontent(const char* value, size_t size);
  inline ::std::string* mutable_operationcontent();
  inline ::std::string* release_operationcontent();
  inline void set_allocated_operationcontent(::std::string* operationcontent);

  // optional string AcceptanceDate = 5;
  inline bool has_acceptancedate() const;
  inline void clear_acceptancedate();
  static const int kAcceptanceDateFieldNumber = 5;
  inline const ::std::string& acceptancedate() const;
  inline void set_acceptancedate(const ::std::string& value);
  inline void set_acceptancedate(const char* value);
  inline void set_acceptancedate(const char* value, size_t size);
  inline ::std::string* mutable_acceptancedate();
  inline ::std::string* release_acceptancedate();
  inline void set_allocated_acceptancedate(::std::string* acceptancedate);

  // optional .Diadoc.Api.Proto.Invoicing.Employee Employee = 6;
  inline bool has_employee() const;
  inline void clear_employee();
  static const int kEmployeeFieldNumber = 6;
  inline const ::Diadoc::Api::Proto::Invoicing::Employee& employee() const;
  inline ::Diadoc::Api::Proto::Invoicing::Employee* mutable_employee();
  inline ::Diadoc::Api::Proto::Invoicing::Employee* release_employee();
  inline void set_allocated_employee(::Diadoc::Api::Proto::Invoicing::Employee* employee);

  // optional .Diadoc.Api.Proto.Invoicing.OtherIssuer OtherIssuer = 7;
  inline bool has_otherissuer() const;
  inline void clear_otherissuer();
  static const int kOtherIssuerFieldNumber = 7;
  inline const ::Diadoc::Api::Proto::Invoicing::OtherIssuer& otherissuer() const;
  inline ::Diadoc::Api::Proto::Invoicing::OtherIssuer* mutable_otherissuer();
  inline ::Diadoc::Api::Proto::Invoicing::OtherIssuer* release_otherissuer();
  inline void set_allocated_otherissuer(::Diadoc::Api::Proto::Invoicing::OtherIssuer* otherissuer);

  // optional .Diadoc.Api.Proto.Invoicing.AdditionalInfoId AdditionalInfoId = 8;
  inline bool has_additionalinfoid() const;
  inline void clear_additionalinfoid();
  static const int kAdditionalInfoIdFieldNumber = 8;
  inline const ::Diadoc::Api::Proto::Invoicing::AdditionalInfoId& additionalinfoid() const;
  inline ::Diadoc::Api::Proto::Invoicing::AdditionalInfoId* mutable_additionalinfoid();
  inline ::Diadoc::Api::Proto::Invoicing::AdditionalInfoId* release_additionalinfoid();
  inline void set_allocated_additionalinfoid(::Diadoc::Api::Proto::Invoicing::AdditionalInfoId* additionalinfoid);

  // repeated .Diadoc.Api.Proto.Invoicing.Signers.ExtendedSigner Signers = 9;
  inline int signers_size() const;
  inline void clear_signers();
  static const int kSignersFieldNumber = 9;
  inline const ::Diadoc::Api::Proto::Invoicing::Signers::ExtendedSigner& signers(int index) const;
  inline ::Diadoc::Api::Proto::Invoicing::Signers::ExtendedSigner* mutable_signers(int index);
  inline ::Diadoc::Api::Proto::Invoicing::Signers::ExtendedSigner* add_signers();
  inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::Signers::ExtendedSigner >&
      signers() const;
  inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::Signers::ExtendedSigner >*
      mutable_signers();

  // @@protoc_insertion_point(class_scope:Diadoc.Api.Proto.Invoicing.TovTorgBuyerTitleInfo)
 private:
  inline void set_has_documentcreator();
  inline void clear_has_documentcreator();
  inline void set_has_documentcreatorbase();
  inline void clear_has_documentcreatorbase();
  inline void set_has_operationcode();
  inline void clear_has_operationcode();
  inline void set_has_operationcontent();
  inline void clear_has_operationcontent();
  inline void set_has_acceptancedate();
  inline void clear_has_acceptancedate();
  inline void set_has_employee();
  inline void clear_has_employee();
  inline void set_has_otherissuer();
  inline void clear_has_otherissuer();
  inline void set_has_additionalinfoid();
  inline void clear_has_additionalinfoid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* documentcreator_;
  ::std::string* documentcreatorbase_;
  ::std::string* operationcode_;
  ::std::string* operationcontent_;
  ::std::string* acceptancedate_;
  ::Diadoc::Api::Proto::Invoicing::Employee* employee_;
  ::Diadoc::Api::Proto::Invoicing::OtherIssuer* otherissuer_;
  ::Diadoc::Api::Proto::Invoicing::AdditionalInfoId* additionalinfoid_;
  ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::Signers::ExtendedSigner > signers_;
  friend void  protobuf_AddDesc_Invoicing_2fTovTorgInfo_2eproto();
  friend void protobuf_AssignDesc_Invoicing_2fTovTorgInfo_2eproto();
  friend void protobuf_ShutdownFile_Invoicing_2fTovTorgInfo_2eproto();

  void InitAsDefaultInstance();
  static TovTorgBuyerTitleInfo* default_instance_;
};
// -------------------------------------------------------------------

class TovTorgTable : public ::google::protobuf::Message {
 public:
  TovTorgTable();
  virtual ~TovTorgTable();

  TovTorgTable(const TovTorgTable& from);

  inline TovTorgTable& operator=(const TovTorgTable& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TovTorgTable& default_instance();

  void Swap(TovTorgTable* other);

  // implements Message ----------------------------------------------

  TovTorgTable* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TovTorgTable& from);
  void MergeFrom(const TovTorgTable& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Diadoc.Api.Proto.Invoicing.TovTorgItem Items = 1;
  inline int items_size() const;
  inline void clear_items();
  static const int kItemsFieldNumber = 1;
  inline const ::Diadoc::Api::Proto::Invoicing::TovTorgItem& items(int index) const;
  inline ::Diadoc::Api::Proto::Invoicing::TovTorgItem* mutable_items(int index);
  inline ::Diadoc::Api::Proto::Invoicing::TovTorgItem* add_items();
  inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::TovTorgItem >&
      items() const;
  inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::TovTorgItem >*
      mutable_items();

  // optional string TotalQuantity = 2;
  inline bool has_totalquantity() const;
  inline void clear_totalquantity();
  static const int kTotalQuantityFieldNumber = 2;
  inline const ::std::string& totalquantity() const;
  inline void set_totalquantity(const ::std::string& value);
  inline void set_totalquantity(const char* value);
  inline void set_totalquantity(const char* value, size_t size);
  inline ::std::string* mutable_totalquantity();
  inline ::std::string* release_totalquantity();
  inline void set_allocated_totalquantity(::std::string* totalquantity);

  // optional string TotalGross = 3;
  inline bool has_totalgross() const;
  inline void clear_totalgross();
  static const int kTotalGrossFieldNumber = 3;
  inline const ::std::string& totalgross() const;
  inline void set_totalgross(const ::std::string& value);
  inline void set_totalgross(const char* value);
  inline void set_totalgross(const char* value, size_t size);
  inline ::std::string* mutable_totalgross();
  inline ::std::string* release_totalgross();
  inline void set_allocated_totalgross(::std::string* totalgross);

  // optional string TotalNet = 4;
  inline bool has_totalnet() const;
  inline void clear_totalnet();
  static const int kTotalNetFieldNumber = 4;
  inline const ::std::string& totalnet() const;
  inline void set_totalnet(const ::std::string& value);
  inline void set_totalnet(const char* value);
  inline void set_totalnet(const char* value, size_t size);
  inline ::std::string* mutable_totalnet();
  inline ::std::string* release_totalnet();
  inline void set_allocated_totalnet(::std::string* totalnet);

  // optional string TotalWithVatExcluded = 5;
  inline bool has_totalwithvatexcluded() const;
  inline void clear_totalwithvatexcluded();
  static const int kTotalWithVatExcludedFieldNumber = 5;
  inline const ::std::string& totalwithvatexcluded() const;
  inline void set_totalwithvatexcluded(const ::std::string& value);
  inline void set_totalwithvatexcluded(const char* value);
  inline void set_totalwithvatexcluded(const char* value, size_t size);
  inline ::std::string* mutable_totalwithvatexcluded();
  inline ::std::string* release_totalwithvatexcluded();
  inline void set_allocated_totalwithvatexcluded(::std::string* totalwithvatexcluded);

  // optional string TotalVat = 6;
  inline bool has_totalvat() const;
  inline void clear_totalvat();
  static const int kTotalVatFieldNumber = 6;
  inline const ::std::string& totalvat() const;
  inline void set_totalvat(const ::std::string& value);
  inline void set_totalvat(const char* value);
  inline void set_totalvat(const char* value, size_t size);
  inline ::std::string* mutable_totalvat();
  inline ::std::string* release_totalvat();
  inline void set_allocated_totalvat(::std::string* totalvat);

  // optional string Total = 7;
  inline bool has_total() const;
  inline void clear_total();
  static const int kTotalFieldNumber = 7;
  inline const ::std::string& total() const;
  inline void set_total(const ::std::string& value);
  inline void set_total(const char* value);
  inline void set_total(const char* value, size_t size);
  inline ::std::string* mutable_total();
  inline ::std::string* release_total();
  inline void set_allocated_total(::std::string* total);

  // @@protoc_insertion_point(class_scope:Diadoc.Api.Proto.Invoicing.TovTorgTable)
 private:
  inline void set_has_totalquantity();
  inline void clear_has_totalquantity();
  inline void set_has_totalgross();
  inline void clear_has_totalgross();
  inline void set_has_totalnet();
  inline void clear_has_totalnet();
  inline void set_has_totalwithvatexcluded();
  inline void clear_has_totalwithvatexcluded();
  inline void set_has_totalvat();
  inline void clear_has_totalvat();
  inline void set_has_total();
  inline void clear_has_total();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::TovTorgItem > items_;
  ::std::string* totalquantity_;
  ::std::string* totalgross_;
  ::std::string* totalnet_;
  ::std::string* totalwithvatexcluded_;
  ::std::string* totalvat_;
  ::std::string* total_;
  friend void  protobuf_AddDesc_Invoicing_2fTovTorgInfo_2eproto();
  friend void protobuf_AssignDesc_Invoicing_2fTovTorgInfo_2eproto();
  friend void protobuf_ShutdownFile_Invoicing_2fTovTorgInfo_2eproto();

  void InitAsDefaultInstance();
  static TovTorgTable* default_instance_;
};
// -------------------------------------------------------------------

class TovTorgItem : public ::google::protobuf::Message {
 public:
  TovTorgItem();
  virtual ~TovTorgItem();

  TovTorgItem(const TovTorgItem& from);

  inline TovTorgItem& operator=(const TovTorgItem& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TovTorgItem& default_instance();

  void Swap(TovTorgItem* other);

  // implements Message ----------------------------------------------

  TovTorgItem* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TovTorgItem& from);
  void MergeFrom(const TovTorgItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string Product = 1;
  inline bool has_product() const;
  inline void clear_product();
  static const int kProductFieldNumber = 1;
  inline const ::std::string& product() const;
  inline void set_product(const ::std::string& value);
  inline void set_product(const char* value);
  inline void set_product(const char* value, size_t size);
  inline ::std::string* mutable_product();
  inline ::std::string* release_product();
  inline void set_allocated_product(::std::string* product);

  // optional string Feature = 2;
  inline bool has_feature() const;
  inline void clear_feature();
  static const int kFeatureFieldNumber = 2;
  inline const ::std::string& feature() const;
  inline void set_feature(const ::std::string& value);
  inline void set_feature(const char* value);
  inline void set_feature(const char* value, size_t size);
  inline ::std::string* mutable_feature();
  inline ::std::string* release_feature();
  inline void set_allocated_feature(::std::string* feature);

  // optional string Sort = 3;
  inline bool has_sort() const;
  inline void clear_sort();
  static const int kSortFieldNumber = 3;
  inline const ::std::string& sort() const;
  inline void set_sort(const ::std::string& value);
  inline void set_sort(const char* value);
  inline void set_sort(const char* value, size_t size);
  inline ::std::string* mutable_sort();
  inline ::std::string* release_sort();
  inline void set_allocated_sort(::std::string* sort);

  // optional string VendorCode = 4;
  inline bool has_vendorcode() const;
  inline void clear_vendorcode();
  static const int kVendorCodeFieldNumber = 4;
  inline const ::std::string& vendorcode() const;
  inline void set_vendorcode(const ::std::string& value);
  inline void set_vendorcode(const char* value);
  inline void set_vendorcode(const char* value, size_t size);
  inline ::std::string* mutable_vendorcode();
  inline ::std::string* release_vendorcode();
  inline void set_allocated_vendorcode(::std::string* vendorcode);

  // optional string ProductCode = 5;
  inline bool has_productcode() const;
  inline void clear_productcode();
  static const int kProductCodeFieldNumber = 5;
  inline const ::std::string& productcode() const;
  inline void set_productcode(const ::std::string& value);
  inline void set_productcode(const char* value);
  inline void set_productcode(const char* value, size_t size);
  inline ::std::string* mutable_productcode();
  inline ::std::string* release_productcode();
  inline void set_allocated_productcode(::std::string* productcode);

  // optional string UnitName = 6;
  inline bool has_unitname() const;
  inline void clear_unitname();
  static const int kUnitNameFieldNumber = 6;
  inline const ::std::string& unitname() const;
  inline void set_unitname(const ::std::string& value);
  inline void set_unitname(const char* value);
  inline void set_unitname(const char* value, size_t size);
  inline ::std::string* mutable_unitname();
  inline ::std::string* release_unitname();
  inline void set_allocated_unitname(::std::string* unitname);

  // required string Unit = 7;
  inline bool has_unit() const;
  inline void clear_unit();
  static const int kUnitFieldNumber = 7;
  inline const ::std::string& unit() const;
  inline void set_unit(const ::std::string& value);
  inline void set_unit(const char* value);
  inline void set_unit(const char* value, size_t size);
  inline ::std::string* mutable_unit();
  inline ::std::string* release_unit();
  inline void set_allocated_unit(::std::string* unit);

  // optional string PackageType = 8;
  inline bool has_packagetype() const;
  inline void clear_packagetype();
  static const int kPackageTypeFieldNumber = 8;
  inline const ::std::string& packagetype() const;
  inline void set_packagetype(const ::std::string& value);
  inline void set_packagetype(const char* value);
  inline void set_packagetype(const char* value, size_t size);
  inline ::std::string* mutable_packagetype();
  inline ::std::string* release_packagetype();
  inline void set_allocated_packagetype(::std::string* packagetype);

  // optional string QuantityInPack = 9;
  inline bool has_quantityinpack() const;
  inline void clear_quantityinpack();
  static const int kQuantityInPackFieldNumber = 9;
  inline const ::std::string& quantityinpack() const;
  inline void set_quantityinpack(const ::std::string& value);
  inline void set_quantityinpack(const char* value);
  inline void set_quantityinpack(const char* value, size_t size);
  inline ::std::string* mutable_quantityinpack();
  inline ::std::string* release_quantityinpack();
  inline void set_allocated_quantityinpack(::std::string* quantityinpack);

  // optional string Quantity = 10;
  inline bool has_quantity() const;
  inline void clear_quantity();
  static const int kQuantityFieldNumber = 10;
  inline const ::std::string& quantity() const;
  inline void set_quantity(const ::std::string& value);
  inline void set_quantity(const char* value);
  inline void set_quantity(const char* value, size_t size);
  inline ::std::string* mutable_quantity();
  inline ::std::string* release_quantity();
  inline void set_allocated_quantity(::std::string* quantity);

  // optional string Gross = 11;
  inline bool has_gross() const;
  inline void clear_gross();
  static const int kGrossFieldNumber = 11;
  inline const ::std::string& gross() const;
  inline void set_gross(const ::std::string& value);
  inline void set_gross(const char* value);
  inline void set_gross(const char* value, size_t size);
  inline ::std::string* mutable_gross();
  inline ::std::string* release_gross();
  inline void set_allocated_gross(::std::string* gross);

  // required string Net = 12;
  inline bool has_net() const;
  inline void clear_net();
  static const int kNetFieldNumber = 12;
  inline const ::std::string& net() const;
  inline void set_net(const ::std::string& value);
  inline void set_net(const char* value);
  inline void set_net(const char* value, size_t size);
  inline ::std::string* mutable_net();
  inline ::std::string* release_net();
  inline void set_allocated_net(::std::string* net);

  // optional string ItemToRelease = 13;
  inline bool has_itemtorelease() const;
  inline void clear_itemtorelease();
  static const int kItemToReleaseFieldNumber = 13;
  inline const ::std::string& itemtorelease() const;
  inline void set_itemtorelease(const ::std::string& value);
  inline void set_itemtorelease(const char* value);
  inline void set_itemtorelease(const char* value, size_t size);
  inline ::std::string* mutable_itemtorelease();
  inline ::std::string* release_itemtorelease();
  inline void set_allocated_itemtorelease(::std::string* itemtorelease);

  // optional string Price = 14;
  inline bool has_price() const;
  inline void clear_price();
  static const int kPriceFieldNumber = 14;
  inline const ::std::string& price() const;
  inline void set_price(const ::std::string& value);
  inline void set_price(const char* value);
  inline void set_price(const char* value, size_t size);
  inline ::std::string* mutable_price();
  inline ::std::string* release_price();
  inline void set_allocated_price(::std::string* price);

  // optional string SubtotalWithVatExcluded = 15;
  inline bool has_subtotalwithvatexcluded() const;
  inline void clear_subtotalwithvatexcluded();
  static const int kSubtotalWithVatExcludedFieldNumber = 15;
  inline const ::std::string& subtotalwithvatexcluded() const;
  inline void set_subtotalwithvatexcluded(const ::std::string& value);
  inline void set_subtotalwithvatexcluded(const char* value);
  inline void set_subtotalwithvatexcluded(const char* value, size_t size);
  inline ::std::string* mutable_subtotalwithvatexcluded();
  inline ::std::string* release_subtotalwithvatexcluded();
  inline void set_allocated_subtotalwithvatexcluded(::std::string* subtotalwithvatexcluded);

  // optional .Diadoc.Api.Proto.Invoicing.TaxRate TaxRate = 16 [default = Percent_18];
  inline bool has_taxrate() const;
  inline void clear_taxrate();
  static const int kTaxRateFieldNumber = 16;
  inline ::Diadoc::Api::Proto::Invoicing::TaxRate taxrate() const;
  inline void set_taxrate(::Diadoc::Api::Proto::Invoicing::TaxRate value);

  // optional string Vat = 17;
  inline bool has_vat() const;
  inline void clear_vat();
  static const int kVatFieldNumber = 17;
  inline const ::std::string& vat() const;
  inline void set_vat(const ::std::string& value);
  inline void set_vat(const char* value);
  inline void set_vat(const char* value, size_t size);
  inline ::std::string* mutable_vat();
  inline ::std::string* release_vat();
  inline void set_allocated_vat(::std::string* vat);

  // required string Subtotal = 18;
  inline bool has_subtotal() const;
  inline void clear_subtotal();
  static const int kSubtotalFieldNumber = 18;
  inline const ::std::string& subtotal() const;
  inline void set_subtotal(const ::std::string& value);
  inline void set_subtotal(const char* value);
  inline void set_subtotal(const char* value, size_t size);
  inline ::std::string* mutable_subtotal();
  inline ::std::string* release_subtotal();
  inline void set_allocated_subtotal(::std::string* subtotal);

  // optional string ItemAccountDebit = 19;
  inline bool has_itemaccountdebit() const;
  inline void clear_itemaccountdebit();
  static const int kItemAccountDebitFieldNumber = 19;
  inline const ::std::string& itemaccountdebit() const;
  inline void set_itemaccountdebit(const ::std::string& value);
  inline void set_itemaccountdebit(const char* value);
  inline void set_itemaccountdebit(const char* value, size_t size);
  inline ::std::string* mutable_itemaccountdebit();
  inline ::std::string* release_itemaccountdebit();
  inline void set_allocated_itemaccountdebit(::std::string* itemaccountdebit);

  // optional string ItemAccountCredit = 20;
  inline bool has_itemaccountcredit() const;
  inline void clear_itemaccountcredit();
  static const int kItemAccountCreditFieldNumber = 20;
  inline const ::std::string& itemaccountcredit() const;
  inline void set_itemaccountcredit(const ::std::string& value);
  inline void set_itemaccountcredit(const char* value);
  inline void set_itemaccountcredit(const char* value, size_t size);
  inline ::std::string* mutable_itemaccountcredit();
  inline ::std::string* release_itemaccountcredit();
  inline void set_allocated_itemaccountcredit(::std::string* itemaccountcredit);

  // repeated .Diadoc.Api.Proto.Invoicing.AdditionalInfo AdditionalInfos = 21;
  inline int additionalinfos_size() const;
  inline void clear_additionalinfos();
  static const int kAdditionalInfosFieldNumber = 21;
  inline const ::Diadoc::Api::Proto::Invoicing::AdditionalInfo& additionalinfos(int index) const;
  inline ::Diadoc::Api::Proto::Invoicing::AdditionalInfo* mutable_additionalinfos(int index);
  inline ::Diadoc::Api::Proto::Invoicing::AdditionalInfo* add_additionalinfos();
  inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::AdditionalInfo >&
      additionalinfos() const;
  inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::AdditionalInfo >*
      mutable_additionalinfos();

  // @@protoc_insertion_point(class_scope:Diadoc.Api.Proto.Invoicing.TovTorgItem)
 private:
  inline void set_has_product();
  inline void clear_has_product();
  inline void set_has_feature();
  inline void clear_has_feature();
  inline void set_has_sort();
  inline void clear_has_sort();
  inline void set_has_vendorcode();
  inline void clear_has_vendorcode();
  inline void set_has_productcode();
  inline void clear_has_productcode();
  inline void set_has_unitname();
  inline void clear_has_unitname();
  inline void set_has_unit();
  inline void clear_has_unit();
  inline void set_has_packagetype();
  inline void clear_has_packagetype();
  inline void set_has_quantityinpack();
  inline void clear_has_quantityinpack();
  inline void set_has_quantity();
  inline void clear_has_quantity();
  inline void set_has_gross();
  inline void clear_has_gross();
  inline void set_has_net();
  inline void clear_has_net();
  inline void set_has_itemtorelease();
  inline void clear_has_itemtorelease();
  inline void set_has_price();
  inline void clear_has_price();
  inline void set_has_subtotalwithvatexcluded();
  inline void clear_has_subtotalwithvatexcluded();
  inline void set_has_taxrate();
  inline void clear_has_taxrate();
  inline void set_has_vat();
  inline void clear_has_vat();
  inline void set_has_subtotal();
  inline void clear_has_subtotal();
  inline void set_has_itemaccountdebit();
  inline void clear_has_itemaccountdebit();
  inline void set_has_itemaccountcredit();
  inline void clear_has_itemaccountcredit();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* product_;
  ::std::string* feature_;
  ::std::string* sort_;
  ::std::string* vendorcode_;
  ::std::string* productcode_;
  ::std::string* unitname_;
  ::std::string* unit_;
  ::std::string* packagetype_;
  ::std::string* quantityinpack_;
  ::std::string* quantity_;
  ::std::string* gross_;
  ::std::string* net_;
  ::std::string* itemtorelease_;
  ::std::string* price_;
  ::std::string* subtotalwithvatexcluded_;
  ::std::string* vat_;
  ::std::string* subtotal_;
  ::std::string* itemaccountdebit_;
  ::std::string* itemaccountcredit_;
  ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::AdditionalInfo > additionalinfos_;
  int taxrate_;
  friend void  protobuf_AddDesc_Invoicing_2fTovTorgInfo_2eproto();
  friend void protobuf_AssignDesc_Invoicing_2fTovTorgInfo_2eproto();
  friend void protobuf_ShutdownFile_Invoicing_2fTovTorgInfo_2eproto();

  void InitAsDefaultInstance();
  static TovTorgItem* default_instance_;
};
// -------------------------------------------------------------------

class TovTorgTransferInfo : public ::google::protobuf::Message {
 public:
  TovTorgTransferInfo();
  virtual ~TovTorgTransferInfo();

  TovTorgTransferInfo(const TovTorgTransferInfo& from);

  inline TovTorgTransferInfo& operator=(const TovTorgTransferInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TovTorgTransferInfo& default_instance();

  void Swap(TovTorgTransferInfo* other);

  // implements Message ----------------------------------------------

  TovTorgTransferInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TovTorgTransferInfo& from);
  void MergeFrom(const TovTorgTransferInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string OperationInfo = 1;
  inline bool has_operationinfo() const;
  inline void clear_operationinfo();
  static const int kOperationInfoFieldNumber = 1;
  inline const ::std::string& operationinfo() const;
  inline void set_operationinfo(const ::std::string& value);
  inline void set_operationinfo(const char* value);
  inline void set_operationinfo(const char* value, size_t size);
  inline ::std::string* mutable_operationinfo();
  inline ::std::string* release_operationinfo();
  inline void set_allocated_operationinfo(::std::string* operationinfo);

  // optional string TransferDate = 2;
  inline bool has_transferdate() const;
  inline void clear_transferdate();
  static const int kTransferDateFieldNumber = 2;
  inline const ::std::string& transferdate() const;
  inline void set_transferdate(const ::std::string& value);
  inline void set_transferdate(const char* value);
  inline void set_transferdate(const char* value, size_t size);
  inline ::std::string* mutable_transferdate();
  inline ::std::string* release_transferdate();
  inline void set_allocated_transferdate(::std::string* transferdate);

  // optional string Attachment = 3;
  inline bool has_attachment() const;
  inline void clear_attachment();
  static const int kAttachmentFieldNumber = 3;
  inline const ::std::string& attachment() const;
  inline void set_attachment(const ::std::string& value);
  inline void set_attachment(const char* value);
  inline void set_attachment(const char* value, size_t size);
  inline ::std::string* mutable_attachment();
  inline ::std::string* release_attachment();
  inline void set_allocated_attachment(::std::string* attachment);

  // repeated .Diadoc.Api.Proto.Invoicing.Waybill Waybills = 4;
  inline int waybills_size() const;
  inline void clear_waybills();
  static const int kWaybillsFieldNumber = 4;
  inline const ::Diadoc::Api::Proto::Invoicing::Waybill& waybills(int index) const;
  inline ::Diadoc::Api::Proto::Invoicing::Waybill* mutable_waybills(int index);
  inline ::Diadoc::Api::Proto::Invoicing::Waybill* add_waybills();
  inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::Waybill >&
      waybills() const;
  inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::Waybill >*
      mutable_waybills();

  // optional .Diadoc.Api.Proto.Invoicing.Employee Employee = 5;
  inline bool has_employee() const;
  inline void clear_employee();
  static const int kEmployeeFieldNumber = 5;
  inline const ::Diadoc::Api::Proto::Invoicing::Employee& employee() const;
  inline ::Diadoc::Api::Proto::Invoicing::Employee* mutable_employee();
  inline ::Diadoc::Api::Proto::Invoicing::Employee* release_employee();
  inline void set_allocated_employee(::Diadoc::Api::Proto::Invoicing::Employee* employee);

  // optional .Diadoc.Api.Proto.Invoicing.OtherIssuer OtherIssuer = 6;
  inline bool has_otherissuer() const;
  inline void clear_otherissuer();
  static const int kOtherIssuerFieldNumber = 6;
  inline const ::Diadoc::Api::Proto::Invoicing::OtherIssuer& otherissuer() const;
  inline ::Diadoc::Api::Proto::Invoicing::OtherIssuer* mutable_otherissuer();
  inline ::Diadoc::Api::Proto::Invoicing::OtherIssuer* release_otherissuer();
  inline void set_allocated_otherissuer(::Diadoc::Api::Proto::Invoicing::OtherIssuer* otherissuer);

  // repeated .Diadoc.Api.Proto.Invoicing.AdditionalInfo AdditionalInfos = 7;
  inline int additionalinfos_size() const;
  inline void clear_additionalinfos();
  static const int kAdditionalInfosFieldNumber = 7;
  inline const ::Diadoc::Api::Proto::Invoicing::AdditionalInfo& additionalinfos(int index) const;
  inline ::Diadoc::Api::Proto::Invoicing::AdditionalInfo* mutable_additionalinfos(int index);
  inline ::Diadoc::Api::Proto::Invoicing::AdditionalInfo* add_additionalinfos();
  inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::AdditionalInfo >&
      additionalinfos() const;
  inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::AdditionalInfo >*
      mutable_additionalinfos();

  // @@protoc_insertion_point(class_scope:Diadoc.Api.Proto.Invoicing.TovTorgTransferInfo)
 private:
  inline void set_has_operationinfo();
  inline void clear_has_operationinfo();
  inline void set_has_transferdate();
  inline void clear_has_transferdate();
  inline void set_has_attachment();
  inline void clear_has_attachment();
  inline void set_has_employee();
  inline void clear_has_employee();
  inline void set_has_otherissuer();
  inline void clear_has_otherissuer();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* operationinfo_;
  ::std::string* transferdate_;
  ::std::string* attachment_;
  ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::Waybill > waybills_;
  ::Diadoc::Api::Proto::Invoicing::Employee* employee_;
  ::Diadoc::Api::Proto::Invoicing::OtherIssuer* otherissuer_;
  ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::AdditionalInfo > additionalinfos_;
  friend void  protobuf_AddDesc_Invoicing_2fTovTorgInfo_2eproto();
  friend void protobuf_AssignDesc_Invoicing_2fTovTorgInfo_2eproto();
  friend void protobuf_ShutdownFile_Invoicing_2fTovTorgInfo_2eproto();

  void InitAsDefaultInstance();
  static TovTorgTransferInfo* default_instance_;
};
// -------------------------------------------------------------------

class GroundInfo : public ::google::protobuf::Message {
 public:
  GroundInfo();
  virtual ~GroundInfo();

  GroundInfo(const GroundInfo& from);

  inline GroundInfo& operator=(const GroundInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GroundInfo& default_instance();

  void Swap(GroundInfo* other);

  // implements Message ----------------------------------------------

  GroundInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GroundInfo& from);
  void MergeFrom(const GroundInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string Name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string Number = 2;
  inline bool has_number() const;
  inline void clear_number();
  static const int kNumberFieldNumber = 2;
  inline const ::std::string& number() const;
  inline void set_number(const ::std::string& value);
  inline void set_number(const char* value);
  inline void set_number(const char* value, size_t size);
  inline ::std::string* mutable_number();
  inline ::std::string* release_number();
  inline void set_allocated_number(::std::string* number);

  // optional string Date = 3;
  inline bool has_date() const;
  inline void clear_date();
  static const int kDateFieldNumber = 3;
  inline const ::std::string& date() const;
  inline void set_date(const ::std::string& value);
  inline void set_date(const char* value);
  inline void set_date(const char* value, size_t size);
  inline ::std::string* mutable_date();
  inline ::std::string* release_date();
  inline void set_allocated_date(::std::string* date);

  // optional string Info = 4;
  inline bool has_info() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 4;
  inline const ::std::string& info() const;
  inline void set_info(const ::std::string& value);
  inline void set_info(const char* value);
  inline void set_info(const char* value, size_t size);
  inline ::std::string* mutable_info();
  inline ::std::string* release_info();
  inline void set_allocated_info(::std::string* info);

  // @@protoc_insertion_point(class_scope:Diadoc.Api.Proto.Invoicing.GroundInfo)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_number();
  inline void clear_has_number();
  inline void set_has_date();
  inline void clear_has_date();
  inline void set_has_info();
  inline void clear_has_info();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::std::string* number_;
  ::std::string* date_;
  ::std::string* info_;
  friend void  protobuf_AddDesc_Invoicing_2fTovTorgInfo_2eproto();
  friend void protobuf_AssignDesc_Invoicing_2fTovTorgInfo_2eproto();
  friend void protobuf_ShutdownFile_Invoicing_2fTovTorgInfo_2eproto();

  void InitAsDefaultInstance();
  static GroundInfo* default_instance_;
};
// ===================================================================


// ===================================================================

// TovTorgSellerTitleInfo

// required .Diadoc.Api.Proto.Invoicing.Organizations.ExtendedOrganizationInfo Seller = 1;
inline bool TovTorgSellerTitleInfo::has_seller() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TovTorgSellerTitleInfo::set_has_seller() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TovTorgSellerTitleInfo::clear_has_seller() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TovTorgSellerTitleInfo::clear_seller() {
  if (seller_ != NULL) seller_->::Diadoc::Api::Proto::Invoicing::Organizations::ExtendedOrganizationInfo::Clear();
  clear_has_seller();
}
inline const ::Diadoc::Api::Proto::Invoicing::Organizations::ExtendedOrganizationInfo& TovTorgSellerTitleInfo::seller() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.TovTorgSellerTitleInfo.Seller)
  return seller_ != NULL ? *seller_ : *default_instance_->seller_;
}
inline ::Diadoc::Api::Proto::Invoicing::Organizations::ExtendedOrganizationInfo* TovTorgSellerTitleInfo::mutable_seller() {
  set_has_seller();
  if (seller_ == NULL) seller_ = new ::Diadoc::Api::Proto::Invoicing::Organizations::ExtendedOrganizationInfo;
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.TovTorgSellerTitleInfo.Seller)
  return seller_;
}
inline ::Diadoc::Api::Proto::Invoicing::Organizations::ExtendedOrganizationInfo* TovTorgSellerTitleInfo::release_seller() {
  clear_has_seller();
  ::Diadoc::Api::Proto::Invoicing::Organizations::ExtendedOrganizationInfo* temp = seller_;
  seller_ = NULL;
  return temp;
}
inline void TovTorgSellerTitleInfo::set_allocated_seller(::Diadoc::Api::Proto::Invoicing::Organizations::ExtendedOrganizationInfo* seller) {
  delete seller_;
  seller_ = seller;
  if (seller) {
    set_has_seller();
  } else {
    clear_has_seller();
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.TovTorgSellerTitleInfo.Seller)
}

// required .Diadoc.Api.Proto.Invoicing.Organizations.ExtendedOrganizationInfo Buyer = 2;
inline bool TovTorgSellerTitleInfo::has_buyer() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TovTorgSellerTitleInfo::set_has_buyer() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TovTorgSellerTitleInfo::clear_has_buyer() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TovTorgSellerTitleInfo::clear_buyer() {
  if (buyer_ != NULL) buyer_->::Diadoc::Api::Proto::Invoicing::Organizations::ExtendedOrganizationInfo::Clear();
  clear_has_buyer();
}
inline const ::Diadoc::Api::Proto::Invoicing::Organizations::ExtendedOrganizationInfo& TovTorgSellerTitleInfo::buyer() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.TovTorgSellerTitleInfo.Buyer)
  return buyer_ != NULL ? *buyer_ : *default_instance_->buyer_;
}
inline ::Diadoc::Api::Proto::Invoicing::Organizations::ExtendedOrganizationInfo* TovTorgSellerTitleInfo::mutable_buyer() {
  set_has_buyer();
  if (buyer_ == NULL) buyer_ = new ::Diadoc::Api::Proto::Invoicing::Organizations::ExtendedOrganizationInfo;
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.TovTorgSellerTitleInfo.Buyer)
  return buyer_;
}
inline ::Diadoc::Api::Proto::Invoicing::Organizations::ExtendedOrganizationInfo* TovTorgSellerTitleInfo::release_buyer() {
  clear_has_buyer();
  ::Diadoc::Api::Proto::Invoicing::Organizations::ExtendedOrganizationInfo* temp = buyer_;
  buyer_ = NULL;
  return temp;
}
inline void TovTorgSellerTitleInfo::set_allocated_buyer(::Diadoc::Api::Proto::Invoicing::Organizations::ExtendedOrganizationInfo* buyer) {
  delete buyer_;
  buyer_ = buyer;
  if (buyer) {
    set_has_buyer();
  } else {
    clear_has_buyer();
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.TovTorgSellerTitleInfo.Buyer)
}

// optional .Diadoc.Api.Proto.Invoicing.Organizations.ExtendedOrganizationInfo Shipper = 3;
inline bool TovTorgSellerTitleInfo::has_shipper() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TovTorgSellerTitleInfo::set_has_shipper() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TovTorgSellerTitleInfo::clear_has_shipper() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TovTorgSellerTitleInfo::clear_shipper() {
  if (shipper_ != NULL) shipper_->::Diadoc::Api::Proto::Invoicing::Organizations::ExtendedOrganizationInfo::Clear();
  clear_has_shipper();
}
inline const ::Diadoc::Api::Proto::Invoicing::Organizations::ExtendedOrganizationInfo& TovTorgSellerTitleInfo::shipper() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.TovTorgSellerTitleInfo.Shipper)
  return shipper_ != NULL ? *shipper_ : *default_instance_->shipper_;
}
inline ::Diadoc::Api::Proto::Invoicing::Organizations::ExtendedOrganizationInfo* TovTorgSellerTitleInfo::mutable_shipper() {
  set_has_shipper();
  if (shipper_ == NULL) shipper_ = new ::Diadoc::Api::Proto::Invoicing::Organizations::ExtendedOrganizationInfo;
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.TovTorgSellerTitleInfo.Shipper)
  return shipper_;
}
inline ::Diadoc::Api::Proto::Invoicing::Organizations::ExtendedOrganizationInfo* TovTorgSellerTitleInfo::release_shipper() {
  clear_has_shipper();
  ::Diadoc::Api::Proto::Invoicing::Organizations::ExtendedOrganizationInfo* temp = shipper_;
  shipper_ = NULL;
  return temp;
}
inline void TovTorgSellerTitleInfo::set_allocated_shipper(::Diadoc::Api::Proto::Invoicing::Organizations::ExtendedOrganizationInfo* shipper) {
  delete shipper_;
  shipper_ = shipper;
  if (shipper) {
    set_has_shipper();
  } else {
    clear_has_shipper();
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.TovTorgSellerTitleInfo.Shipper)
}

// optional .Diadoc.Api.Proto.Invoicing.Organizations.ExtendedOrganizationInfo Consignee = 4;
inline bool TovTorgSellerTitleInfo::has_consignee() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TovTorgSellerTitleInfo::set_has_consignee() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TovTorgSellerTitleInfo::clear_has_consignee() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TovTorgSellerTitleInfo::clear_consignee() {
  if (consignee_ != NULL) consignee_->::Diadoc::Api::Proto::Invoicing::Organizations::ExtendedOrganizationInfo::Clear();
  clear_has_consignee();
}
inline const ::Diadoc::Api::Proto::Invoicing::Organizations::ExtendedOrganizationInfo& TovTorgSellerTitleInfo::consignee() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.TovTorgSellerTitleInfo.Consignee)
  return consignee_ != NULL ? *consignee_ : *default_instance_->consignee_;
}
inline ::Diadoc::Api::Proto::Invoicing::Organizations::ExtendedOrganizationInfo* TovTorgSellerTitleInfo::mutable_consignee() {
  set_has_consignee();
  if (consignee_ == NULL) consignee_ = new ::Diadoc::Api::Proto::Invoicing::Organizations::ExtendedOrganizationInfo;
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.TovTorgSellerTitleInfo.Consignee)
  return consignee_;
}
inline ::Diadoc::Api::Proto::Invoicing::Organizations::ExtendedOrganizationInfo* TovTorgSellerTitleInfo::release_consignee() {
  clear_has_consignee();
  ::Diadoc::Api::Proto::Invoicing::Organizations::ExtendedOrganizationInfo* temp = consignee_;
  consignee_ = NULL;
  return temp;
}
inline void TovTorgSellerTitleInfo::set_allocated_consignee(::Diadoc::Api::Proto::Invoicing::Organizations::ExtendedOrganizationInfo* consignee) {
  delete consignee_;
  consignee_ = consignee;
  if (consignee) {
    set_has_consignee();
  } else {
    clear_has_consignee();
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.TovTorgSellerTitleInfo.Consignee)
}

// optional .Diadoc.Api.Proto.Invoicing.Organizations.ExtendedOrganizationInfo Carrier = 5;
inline bool TovTorgSellerTitleInfo::has_carrier() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TovTorgSellerTitleInfo::set_has_carrier() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TovTorgSellerTitleInfo::clear_has_carrier() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TovTorgSellerTitleInfo::clear_carrier() {
  if (carrier_ != NULL) carrier_->::Diadoc::Api::Proto::Invoicing::Organizations::ExtendedOrganizationInfo::Clear();
  clear_has_carrier();
}
inline const ::Diadoc::Api::Proto::Invoicing::Organizations::ExtendedOrganizationInfo& TovTorgSellerTitleInfo::carrier() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.TovTorgSellerTitleInfo.Carrier)
  return carrier_ != NULL ? *carrier_ : *default_instance_->carrier_;
}
inline ::Diadoc::Api::Proto::Invoicing::Organizations::ExtendedOrganizationInfo* TovTorgSellerTitleInfo::mutable_carrier() {
  set_has_carrier();
  if (carrier_ == NULL) carrier_ = new ::Diadoc::Api::Proto::Invoicing::Organizations::ExtendedOrganizationInfo;
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.TovTorgSellerTitleInfo.Carrier)
  return carrier_;
}
inline ::Diadoc::Api::Proto::Invoicing::Organizations::ExtendedOrganizationInfo* TovTorgSellerTitleInfo::release_carrier() {
  clear_has_carrier();
  ::Diadoc::Api::Proto::Invoicing::Organizations::ExtendedOrganizationInfo* temp = carrier_;
  carrier_ = NULL;
  return temp;
}
inline void TovTorgSellerTitleInfo::set_allocated_carrier(::Diadoc::Api::Proto::Invoicing::Organizations::ExtendedOrganizationInfo* carrier) {
  delete carrier_;
  carrier_ = carrier;
  if (carrier) {
    set_has_carrier();
  } else {
    clear_has_carrier();
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.TovTorgSellerTitleInfo.Carrier)
}

// repeated .Diadoc.Api.Proto.Invoicing.Signers.ExtendedSigner Signers = 6;
inline int TovTorgSellerTitleInfo::signers_size() const {
  return signers_.size();
}
inline void TovTorgSellerTitleInfo::clear_signers() {
  signers_.Clear();
}
inline const ::Diadoc::Api::Proto::Invoicing::Signers::ExtendedSigner& TovTorgSellerTitleInfo::signers(int index) const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.TovTorgSellerTitleInfo.Signers)
  return signers_.Get(index);
}
inline ::Diadoc::Api::Proto::Invoicing::Signers::ExtendedSigner* TovTorgSellerTitleInfo::mutable_signers(int index) {
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.TovTorgSellerTitleInfo.Signers)
  return signers_.Mutable(index);
}
inline ::Diadoc::Api::Proto::Invoicing::Signers::ExtendedSigner* TovTorgSellerTitleInfo::add_signers() {
  // @@protoc_insertion_point(field_add:Diadoc.Api.Proto.Invoicing.TovTorgSellerTitleInfo.Signers)
  return signers_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::Signers::ExtendedSigner >&
TovTorgSellerTitleInfo::signers() const {
  // @@protoc_insertion_point(field_list:Diadoc.Api.Proto.Invoicing.TovTorgSellerTitleInfo.Signers)
  return signers_;
}
inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::Signers::ExtendedSigner >*
TovTorgSellerTitleInfo::mutable_signers() {
  // @@protoc_insertion_point(field_mutable_list:Diadoc.Api.Proto.Invoicing.TovTorgSellerTitleInfo.Signers)
  return &signers_;
}

// repeated .Diadoc.Api.Proto.Invoicing.GroundInfo Grounds = 7;
inline int TovTorgSellerTitleInfo::grounds_size() const {
  return grounds_.size();
}
inline void TovTorgSellerTitleInfo::clear_grounds() {
  grounds_.Clear();
}
inline const ::Diadoc::Api::Proto::Invoicing::GroundInfo& TovTorgSellerTitleInfo::grounds(int index) const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.TovTorgSellerTitleInfo.Grounds)
  return grounds_.Get(index);
}
inline ::Diadoc::Api::Proto::Invoicing::GroundInfo* TovTorgSellerTitleInfo::mutable_grounds(int index) {
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.TovTorgSellerTitleInfo.Grounds)
  return grounds_.Mutable(index);
}
inline ::Diadoc::Api::Proto::Invoicing::GroundInfo* TovTorgSellerTitleInfo::add_grounds() {
  // @@protoc_insertion_point(field_add:Diadoc.Api.Proto.Invoicing.TovTorgSellerTitleInfo.Grounds)
  return grounds_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::GroundInfo >&
TovTorgSellerTitleInfo::grounds() const {
  // @@protoc_insertion_point(field_list:Diadoc.Api.Proto.Invoicing.TovTorgSellerTitleInfo.Grounds)
  return grounds_;
}
inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::GroundInfo >*
TovTorgSellerTitleInfo::mutable_grounds() {
  // @@protoc_insertion_point(field_mutable_list:Diadoc.Api.Proto.Invoicing.TovTorgSellerTitleInfo.Grounds)
  return &grounds_;
}

// required string Currency = 8;
inline bool TovTorgSellerTitleInfo::has_currency() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TovTorgSellerTitleInfo::set_has_currency() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TovTorgSellerTitleInfo::clear_has_currency() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TovTorgSellerTitleInfo::clear_currency() {
  if (currency_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    currency_->clear();
  }
  clear_has_currency();
}
inline const ::std::string& TovTorgSellerTitleInfo::currency() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.TovTorgSellerTitleInfo.Currency)
  return *currency_;
}
inline void TovTorgSellerTitleInfo::set_currency(const ::std::string& value) {
  set_has_currency();
  if (currency_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    currency_ = new ::std::string;
  }
  currency_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.TovTorgSellerTitleInfo.Currency)
}
inline void TovTorgSellerTitleInfo::set_currency(const char* value) {
  set_has_currency();
  if (currency_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    currency_ = new ::std::string;
  }
  currency_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.TovTorgSellerTitleInfo.Currency)
}
inline void TovTorgSellerTitleInfo::set_currency(const char* value, size_t size) {
  set_has_currency();
  if (currency_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    currency_ = new ::std::string;
  }
  currency_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.TovTorgSellerTitleInfo.Currency)
}
inline ::std::string* TovTorgSellerTitleInfo::mutable_currency() {
  set_has_currency();
  if (currency_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    currency_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.TovTorgSellerTitleInfo.Currency)
  return currency_;
}
inline ::std::string* TovTorgSellerTitleInfo::release_currency() {
  clear_has_currency();
  if (currency_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = currency_;
    currency_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TovTorgSellerTitleInfo::set_allocated_currency(::std::string* currency) {
  if (currency_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete currency_;
  }
  if (currency) {
    set_has_currency();
    currency_ = currency;
  } else {
    clear_has_currency();
    currency_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.TovTorgSellerTitleInfo.Currency)
}

// optional string CurrencyRate = 9;
inline bool TovTorgSellerTitleInfo::has_currencyrate() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TovTorgSellerTitleInfo::set_has_currencyrate() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TovTorgSellerTitleInfo::clear_has_currencyrate() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TovTorgSellerTitleInfo::clear_currencyrate() {
  if (currencyrate_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    currencyrate_->clear();
  }
  clear_has_currencyrate();
}
inline const ::std::string& TovTorgSellerTitleInfo::currencyrate() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.TovTorgSellerTitleInfo.CurrencyRate)
  return *currencyrate_;
}
inline void TovTorgSellerTitleInfo::set_currencyrate(const ::std::string& value) {
  set_has_currencyrate();
  if (currencyrate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    currencyrate_ = new ::std::string;
  }
  currencyrate_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.TovTorgSellerTitleInfo.CurrencyRate)
}
inline void TovTorgSellerTitleInfo::set_currencyrate(const char* value) {
  set_has_currencyrate();
  if (currencyrate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    currencyrate_ = new ::std::string;
  }
  currencyrate_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.TovTorgSellerTitleInfo.CurrencyRate)
}
inline void TovTorgSellerTitleInfo::set_currencyrate(const char* value, size_t size) {
  set_has_currencyrate();
  if (currencyrate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    currencyrate_ = new ::std::string;
  }
  currencyrate_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.TovTorgSellerTitleInfo.CurrencyRate)
}
inline ::std::string* TovTorgSellerTitleInfo::mutable_currencyrate() {
  set_has_currencyrate();
  if (currencyrate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    currencyrate_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.TovTorgSellerTitleInfo.CurrencyRate)
  return currencyrate_;
}
inline ::std::string* TovTorgSellerTitleInfo::release_currencyrate() {
  clear_has_currencyrate();
  if (currencyrate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = currencyrate_;
    currencyrate_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TovTorgSellerTitleInfo::set_allocated_currencyrate(::std::string* currencyrate) {
  if (currencyrate_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete currencyrate_;
  }
  if (currencyrate) {
    set_has_currencyrate();
    currencyrate_ = currencyrate;
  } else {
    clear_has_currencyrate();
    currencyrate_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.TovTorgSellerTitleInfo.CurrencyRate)
}

// required string DocumentDate = 10;
inline bool TovTorgSellerTitleInfo::has_documentdate() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TovTorgSellerTitleInfo::set_has_documentdate() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TovTorgSellerTitleInfo::clear_has_documentdate() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TovTorgSellerTitleInfo::clear_documentdate() {
  if (documentdate_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    documentdate_->clear();
  }
  clear_has_documentdate();
}
inline const ::std::string& TovTorgSellerTitleInfo::documentdate() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.TovTorgSellerTitleInfo.DocumentDate)
  return *documentdate_;
}
inline void TovTorgSellerTitleInfo::set_documentdate(const ::std::string& value) {
  set_has_documentdate();
  if (documentdate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    documentdate_ = new ::std::string;
  }
  documentdate_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.TovTorgSellerTitleInfo.DocumentDate)
}
inline void TovTorgSellerTitleInfo::set_documentdate(const char* value) {
  set_has_documentdate();
  if (documentdate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    documentdate_ = new ::std::string;
  }
  documentdate_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.TovTorgSellerTitleInfo.DocumentDate)
}
inline void TovTorgSellerTitleInfo::set_documentdate(const char* value, size_t size) {
  set_has_documentdate();
  if (documentdate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    documentdate_ = new ::std::string;
  }
  documentdate_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.TovTorgSellerTitleInfo.DocumentDate)
}
inline ::std::string* TovTorgSellerTitleInfo::mutable_documentdate() {
  set_has_documentdate();
  if (documentdate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    documentdate_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.TovTorgSellerTitleInfo.DocumentDate)
  return documentdate_;
}
inline ::std::string* TovTorgSellerTitleInfo::release_documentdate() {
  clear_has_documentdate();
  if (documentdate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = documentdate_;
    documentdate_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TovTorgSellerTitleInfo::set_allocated_documentdate(::std::string* documentdate) {
  if (documentdate_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete documentdate_;
  }
  if (documentdate) {
    set_has_documentdate();
    documentdate_ = documentdate;
  } else {
    clear_has_documentdate();
    documentdate_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.TovTorgSellerTitleInfo.DocumentDate)
}

// optional string DocumentNumber = 11;
inline bool TovTorgSellerTitleInfo::has_documentnumber() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void TovTorgSellerTitleInfo::set_has_documentnumber() {
  _has_bits_[0] |= 0x00000400u;
}
inline void TovTorgSellerTitleInfo::clear_has_documentnumber() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void TovTorgSellerTitleInfo::clear_documentnumber() {
  if (documentnumber_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    documentnumber_->clear();
  }
  clear_has_documentnumber();
}
inline const ::std::string& TovTorgSellerTitleInfo::documentnumber() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.TovTorgSellerTitleInfo.DocumentNumber)
  return *documentnumber_;
}
inline void TovTorgSellerTitleInfo::set_documentnumber(const ::std::string& value) {
  set_has_documentnumber();
  if (documentnumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    documentnumber_ = new ::std::string;
  }
  documentnumber_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.TovTorgSellerTitleInfo.DocumentNumber)
}
inline void TovTorgSellerTitleInfo::set_documentnumber(const char* value) {
  set_has_documentnumber();
  if (documentnumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    documentnumber_ = new ::std::string;
  }
  documentnumber_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.TovTorgSellerTitleInfo.DocumentNumber)
}
inline void TovTorgSellerTitleInfo::set_documentnumber(const char* value, size_t size) {
  set_has_documentnumber();
  if (documentnumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    documentnumber_ = new ::std::string;
  }
  documentnumber_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.TovTorgSellerTitleInfo.DocumentNumber)
}
inline ::std::string* TovTorgSellerTitleInfo::mutable_documentnumber() {
  set_has_documentnumber();
  if (documentnumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    documentnumber_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.TovTorgSellerTitleInfo.DocumentNumber)
  return documentnumber_;
}
inline ::std::string* TovTorgSellerTitleInfo::release_documentnumber() {
  clear_has_documentnumber();
  if (documentnumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = documentnumber_;
    documentnumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TovTorgSellerTitleInfo::set_allocated_documentnumber(::std::string* documentnumber) {
  if (documentnumber_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete documentnumber_;
  }
  if (documentnumber) {
    set_has_documentnumber();
    documentnumber_ = documentnumber;
  } else {
    clear_has_documentnumber();
    documentnumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.TovTorgSellerTitleInfo.DocumentNumber)
}

// optional string RevisionDate = 12;
inline bool TovTorgSellerTitleInfo::has_revisiondate() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void TovTorgSellerTitleInfo::set_has_revisiondate() {
  _has_bits_[0] |= 0x00000800u;
}
inline void TovTorgSellerTitleInfo::clear_has_revisiondate() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void TovTorgSellerTitleInfo::clear_revisiondate() {
  if (revisiondate_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    revisiondate_->clear();
  }
  clear_has_revisiondate();
}
inline const ::std::string& TovTorgSellerTitleInfo::revisiondate() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.TovTorgSellerTitleInfo.RevisionDate)
  return *revisiondate_;
}
inline void TovTorgSellerTitleInfo::set_revisiondate(const ::std::string& value) {
  set_has_revisiondate();
  if (revisiondate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    revisiondate_ = new ::std::string;
  }
  revisiondate_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.TovTorgSellerTitleInfo.RevisionDate)
}
inline void TovTorgSellerTitleInfo::set_revisiondate(const char* value) {
  set_has_revisiondate();
  if (revisiondate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    revisiondate_ = new ::std::string;
  }
  revisiondate_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.TovTorgSellerTitleInfo.RevisionDate)
}
inline void TovTorgSellerTitleInfo::set_revisiondate(const char* value, size_t size) {
  set_has_revisiondate();
  if (revisiondate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    revisiondate_ = new ::std::string;
  }
  revisiondate_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.TovTorgSellerTitleInfo.RevisionDate)
}
inline ::std::string* TovTorgSellerTitleInfo::mutable_revisiondate() {
  set_has_revisiondate();
  if (revisiondate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    revisiondate_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.TovTorgSellerTitleInfo.RevisionDate)
  return revisiondate_;
}
inline ::std::string* TovTorgSellerTitleInfo::release_revisiondate() {
  clear_has_revisiondate();
  if (revisiondate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = revisiondate_;
    revisiondate_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TovTorgSellerTitleInfo::set_allocated_revisiondate(::std::string* revisiondate) {
  if (revisiondate_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete revisiondate_;
  }
  if (revisiondate) {
    set_has_revisiondate();
    revisiondate_ = revisiondate;
  } else {
    clear_has_revisiondate();
    revisiondate_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.TovTorgSellerTitleInfo.RevisionDate)
}

// optional string RevisionNumber = 13;
inline bool TovTorgSellerTitleInfo::has_revisionnumber() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void TovTorgSellerTitleInfo::set_has_revisionnumber() {
  _has_bits_[0] |= 0x00001000u;
}
inline void TovTorgSellerTitleInfo::clear_has_revisionnumber() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void TovTorgSellerTitleInfo::clear_revisionnumber() {
  if (revisionnumber_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    revisionnumber_->clear();
  }
  clear_has_revisionnumber();
}
inline const ::std::string& TovTorgSellerTitleInfo::revisionnumber() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.TovTorgSellerTitleInfo.RevisionNumber)
  return *revisionnumber_;
}
inline void TovTorgSellerTitleInfo::set_revisionnumber(const ::std::string& value) {
  set_has_revisionnumber();
  if (revisionnumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    revisionnumber_ = new ::std::string;
  }
  revisionnumber_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.TovTorgSellerTitleInfo.RevisionNumber)
}
inline void TovTorgSellerTitleInfo::set_revisionnumber(const char* value) {
  set_has_revisionnumber();
  if (revisionnumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    revisionnumber_ = new ::std::string;
  }
  revisionnumber_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.TovTorgSellerTitleInfo.RevisionNumber)
}
inline void TovTorgSellerTitleInfo::set_revisionnumber(const char* value, size_t size) {
  set_has_revisionnumber();
  if (revisionnumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    revisionnumber_ = new ::std::string;
  }
  revisionnumber_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.TovTorgSellerTitleInfo.RevisionNumber)
}
inline ::std::string* TovTorgSellerTitleInfo::mutable_revisionnumber() {
  set_has_revisionnumber();
  if (revisionnumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    revisionnumber_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.TovTorgSellerTitleInfo.RevisionNumber)
  return revisionnumber_;
}
inline ::std::string* TovTorgSellerTitleInfo::release_revisionnumber() {
  clear_has_revisionnumber();
  if (revisionnumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = revisionnumber_;
    revisionnumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TovTorgSellerTitleInfo::set_allocated_revisionnumber(::std::string* revisionnumber) {
  if (revisionnumber_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete revisionnumber_;
  }
  if (revisionnumber) {
    set_has_revisionnumber();
    revisionnumber_ = revisionnumber;
  } else {
    clear_has_revisionnumber();
    revisionnumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.TovTorgSellerTitleInfo.RevisionNumber)
}

// required .Diadoc.Api.Proto.Invoicing.TovTorgTransferInfo TransferInfo = 14;
inline bool TovTorgSellerTitleInfo::has_transferinfo() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void TovTorgSellerTitleInfo::set_has_transferinfo() {
  _has_bits_[0] |= 0x00002000u;
}
inline void TovTorgSellerTitleInfo::clear_has_transferinfo() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void TovTorgSellerTitleInfo::clear_transferinfo() {
  if (transferinfo_ != NULL) transferinfo_->::Diadoc::Api::Proto::Invoicing::TovTorgTransferInfo::Clear();
  clear_has_transferinfo();
}
inline const ::Diadoc::Api::Proto::Invoicing::TovTorgTransferInfo& TovTorgSellerTitleInfo::transferinfo() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.TovTorgSellerTitleInfo.TransferInfo)
  return transferinfo_ != NULL ? *transferinfo_ : *default_instance_->transferinfo_;
}
inline ::Diadoc::Api::Proto::Invoicing::TovTorgTransferInfo* TovTorgSellerTitleInfo::mutable_transferinfo() {
  set_has_transferinfo();
  if (transferinfo_ == NULL) transferinfo_ = new ::Diadoc::Api::Proto::Invoicing::TovTorgTransferInfo;
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.TovTorgSellerTitleInfo.TransferInfo)
  return transferinfo_;
}
inline ::Diadoc::Api::Proto::Invoicing::TovTorgTransferInfo* TovTorgSellerTitleInfo::release_transferinfo() {
  clear_has_transferinfo();
  ::Diadoc::Api::Proto::Invoicing::TovTorgTransferInfo* temp = transferinfo_;
  transferinfo_ = NULL;
  return temp;
}
inline void TovTorgSellerTitleInfo::set_allocated_transferinfo(::Diadoc::Api::Proto::Invoicing::TovTorgTransferInfo* transferinfo) {
  delete transferinfo_;
  transferinfo_ = transferinfo;
  if (transferinfo) {
    set_has_transferinfo();
  } else {
    clear_has_transferinfo();
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.TovTorgSellerTitleInfo.TransferInfo)
}

// required string DocumentCreator = 15;
inline bool TovTorgSellerTitleInfo::has_documentcreator() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void TovTorgSellerTitleInfo::set_has_documentcreator() {
  _has_bits_[0] |= 0x00004000u;
}
inline void TovTorgSellerTitleInfo::clear_has_documentcreator() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void TovTorgSellerTitleInfo::clear_documentcreator() {
  if (documentcreator_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    documentcreator_->clear();
  }
  clear_has_documentcreator();
}
inline const ::std::string& TovTorgSellerTitleInfo::documentcreator() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.TovTorgSellerTitleInfo.DocumentCreator)
  return *documentcreator_;
}
inline void TovTorgSellerTitleInfo::set_documentcreator(const ::std::string& value) {
  set_has_documentcreator();
  if (documentcreator_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    documentcreator_ = new ::std::string;
  }
  documentcreator_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.TovTorgSellerTitleInfo.DocumentCreator)
}
inline void TovTorgSellerTitleInfo::set_documentcreator(const char* value) {
  set_has_documentcreator();
  if (documentcreator_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    documentcreator_ = new ::std::string;
  }
  documentcreator_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.TovTorgSellerTitleInfo.DocumentCreator)
}
inline void TovTorgSellerTitleInfo::set_documentcreator(const char* value, size_t size) {
  set_has_documentcreator();
  if (documentcreator_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    documentcreator_ = new ::std::string;
  }
  documentcreator_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.TovTorgSellerTitleInfo.DocumentCreator)
}
inline ::std::string* TovTorgSellerTitleInfo::mutable_documentcreator() {
  set_has_documentcreator();
  if (documentcreator_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    documentcreator_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.TovTorgSellerTitleInfo.DocumentCreator)
  return documentcreator_;
}
inline ::std::string* TovTorgSellerTitleInfo::release_documentcreator() {
  clear_has_documentcreator();
  if (documentcreator_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = documentcreator_;
    documentcreator_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TovTorgSellerTitleInfo::set_allocated_documentcreator(::std::string* documentcreator) {
  if (documentcreator_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete documentcreator_;
  }
  if (documentcreator) {
    set_has_documentcreator();
    documentcreator_ = documentcreator;
  } else {
    clear_has_documentcreator();
    documentcreator_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.TovTorgSellerTitleInfo.DocumentCreator)
}

// optional string DocumentCreatorBase = 16;
inline bool TovTorgSellerTitleInfo::has_documentcreatorbase() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void TovTorgSellerTitleInfo::set_has_documentcreatorbase() {
  _has_bits_[0] |= 0x00008000u;
}
inline void TovTorgSellerTitleInfo::clear_has_documentcreatorbase() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void TovTorgSellerTitleInfo::clear_documentcreatorbase() {
  if (documentcreatorbase_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    documentcreatorbase_->clear();
  }
  clear_has_documentcreatorbase();
}
inline const ::std::string& TovTorgSellerTitleInfo::documentcreatorbase() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.TovTorgSellerTitleInfo.DocumentCreatorBase)
  return *documentcreatorbase_;
}
inline void TovTorgSellerTitleInfo::set_documentcreatorbase(const ::std::string& value) {
  set_has_documentcreatorbase();
  if (documentcreatorbase_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    documentcreatorbase_ = new ::std::string;
  }
  documentcreatorbase_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.TovTorgSellerTitleInfo.DocumentCreatorBase)
}
inline void TovTorgSellerTitleInfo::set_documentcreatorbase(const char* value) {
  set_has_documentcreatorbase();
  if (documentcreatorbase_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    documentcreatorbase_ = new ::std::string;
  }
  documentcreatorbase_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.TovTorgSellerTitleInfo.DocumentCreatorBase)
}
inline void TovTorgSellerTitleInfo::set_documentcreatorbase(const char* value, size_t size) {
  set_has_documentcreatorbase();
  if (documentcreatorbase_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    documentcreatorbase_ = new ::std::string;
  }
  documentcreatorbase_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.TovTorgSellerTitleInfo.DocumentCreatorBase)
}
inline ::std::string* TovTorgSellerTitleInfo::mutable_documentcreatorbase() {
  set_has_documentcreatorbase();
  if (documentcreatorbase_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    documentcreatorbase_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.TovTorgSellerTitleInfo.DocumentCreatorBase)
  return documentcreatorbase_;
}
inline ::std::string* TovTorgSellerTitleInfo::release_documentcreatorbase() {
  clear_has_documentcreatorbase();
  if (documentcreatorbase_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = documentcreatorbase_;
    documentcreatorbase_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TovTorgSellerTitleInfo::set_allocated_documentcreatorbase(::std::string* documentcreatorbase) {
  if (documentcreatorbase_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete documentcreatorbase_;
  }
  if (documentcreatorbase) {
    set_has_documentcreatorbase();
    documentcreatorbase_ = documentcreatorbase;
  } else {
    clear_has_documentcreatorbase();
    documentcreatorbase_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.TovTorgSellerTitleInfo.DocumentCreatorBase)
}

// optional string OperationType = 17;
inline bool TovTorgSellerTitleInfo::has_operationtype() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void TovTorgSellerTitleInfo::set_has_operationtype() {
  _has_bits_[0] |= 0x00010000u;
}
inline void TovTorgSellerTitleInfo::clear_has_operationtype() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void TovTorgSellerTitleInfo::clear_operationtype() {
  if (operationtype_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    operationtype_->clear();
  }
  clear_has_operationtype();
}
inline const ::std::string& TovTorgSellerTitleInfo::operationtype() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.TovTorgSellerTitleInfo.OperationType)
  return *operationtype_;
}
inline void TovTorgSellerTitleInfo::set_operationtype(const ::std::string& value) {
  set_has_operationtype();
  if (operationtype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    operationtype_ = new ::std::string;
  }
  operationtype_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.TovTorgSellerTitleInfo.OperationType)
}
inline void TovTorgSellerTitleInfo::set_operationtype(const char* value) {
  set_has_operationtype();
  if (operationtype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    operationtype_ = new ::std::string;
  }
  operationtype_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.TovTorgSellerTitleInfo.OperationType)
}
inline void TovTorgSellerTitleInfo::set_operationtype(const char* value, size_t size) {
  set_has_operationtype();
  if (operationtype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    operationtype_ = new ::std::string;
  }
  operationtype_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.TovTorgSellerTitleInfo.OperationType)
}
inline ::std::string* TovTorgSellerTitleInfo::mutable_operationtype() {
  set_has_operationtype();
  if (operationtype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    operationtype_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.TovTorgSellerTitleInfo.OperationType)
  return operationtype_;
}
inline ::std::string* TovTorgSellerTitleInfo::release_operationtype() {
  clear_has_operationtype();
  if (operationtype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = operationtype_;
    operationtype_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TovTorgSellerTitleInfo::set_allocated_operationtype(::std::string* operationtype) {
  if (operationtype_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete operationtype_;
  }
  if (operationtype) {
    set_has_operationtype();
    operationtype_ = operationtype;
  } else {
    clear_has_operationtype();
    operationtype_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.TovTorgSellerTitleInfo.OperationType)
}

// optional string GovernmentContractInfo = 18;
inline bool TovTorgSellerTitleInfo::has_governmentcontractinfo() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void TovTorgSellerTitleInfo::set_has_governmentcontractinfo() {
  _has_bits_[0] |= 0x00020000u;
}
inline void TovTorgSellerTitleInfo::clear_has_governmentcontractinfo() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void TovTorgSellerTitleInfo::clear_governmentcontractinfo() {
  if (governmentcontractinfo_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    governmentcontractinfo_->clear();
  }
  clear_has_governmentcontractinfo();
}
inline const ::std::string& TovTorgSellerTitleInfo::governmentcontractinfo() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.TovTorgSellerTitleInfo.GovernmentContractInfo)
  return *governmentcontractinfo_;
}
inline void TovTorgSellerTitleInfo::set_governmentcontractinfo(const ::std::string& value) {
  set_has_governmentcontractinfo();
  if (governmentcontractinfo_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    governmentcontractinfo_ = new ::std::string;
  }
  governmentcontractinfo_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.TovTorgSellerTitleInfo.GovernmentContractInfo)
}
inline void TovTorgSellerTitleInfo::set_governmentcontractinfo(const char* value) {
  set_has_governmentcontractinfo();
  if (governmentcontractinfo_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    governmentcontractinfo_ = new ::std::string;
  }
  governmentcontractinfo_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.TovTorgSellerTitleInfo.GovernmentContractInfo)
}
inline void TovTorgSellerTitleInfo::set_governmentcontractinfo(const char* value, size_t size) {
  set_has_governmentcontractinfo();
  if (governmentcontractinfo_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    governmentcontractinfo_ = new ::std::string;
  }
  governmentcontractinfo_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.TovTorgSellerTitleInfo.GovernmentContractInfo)
}
inline ::std::string* TovTorgSellerTitleInfo::mutable_governmentcontractinfo() {
  set_has_governmentcontractinfo();
  if (governmentcontractinfo_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    governmentcontractinfo_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.TovTorgSellerTitleInfo.GovernmentContractInfo)
  return governmentcontractinfo_;
}
inline ::std::string* TovTorgSellerTitleInfo::release_governmentcontractinfo() {
  clear_has_governmentcontractinfo();
  if (governmentcontractinfo_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = governmentcontractinfo_;
    governmentcontractinfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TovTorgSellerTitleInfo::set_allocated_governmentcontractinfo(::std::string* governmentcontractinfo) {
  if (governmentcontractinfo_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete governmentcontractinfo_;
  }
  if (governmentcontractinfo) {
    set_has_governmentcontractinfo();
    governmentcontractinfo_ = governmentcontractinfo;
  } else {
    clear_has_governmentcontractinfo();
    governmentcontractinfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.TovTorgSellerTitleInfo.GovernmentContractInfo)
}

// optional .Diadoc.Api.Proto.Invoicing.TovTorgTable Table = 19;
inline bool TovTorgSellerTitleInfo::has_table() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void TovTorgSellerTitleInfo::set_has_table() {
  _has_bits_[0] |= 0x00040000u;
}
inline void TovTorgSellerTitleInfo::clear_has_table() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void TovTorgSellerTitleInfo::clear_table() {
  if (table_ != NULL) table_->::Diadoc::Api::Proto::Invoicing::TovTorgTable::Clear();
  clear_has_table();
}
inline const ::Diadoc::Api::Proto::Invoicing::TovTorgTable& TovTorgSellerTitleInfo::table() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.TovTorgSellerTitleInfo.Table)
  return table_ != NULL ? *table_ : *default_instance_->table_;
}
inline ::Diadoc::Api::Proto::Invoicing::TovTorgTable* TovTorgSellerTitleInfo::mutable_table() {
  set_has_table();
  if (table_ == NULL) table_ = new ::Diadoc::Api::Proto::Invoicing::TovTorgTable;
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.TovTorgSellerTitleInfo.Table)
  return table_;
}
inline ::Diadoc::Api::Proto::Invoicing::TovTorgTable* TovTorgSellerTitleInfo::release_table() {
  clear_has_table();
  ::Diadoc::Api::Proto::Invoicing::TovTorgTable* temp = table_;
  table_ = NULL;
  return temp;
}
inline void TovTorgSellerTitleInfo::set_allocated_table(::Diadoc::Api::Proto::Invoicing::TovTorgTable* table) {
  delete table_;
  table_ = table;
  if (table) {
    set_has_table();
  } else {
    clear_has_table();
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.TovTorgSellerTitleInfo.Table)
}

// optional .Diadoc.Api.Proto.Invoicing.AdditionalInfoId AdditionalInfoId = 20;
inline bool TovTorgSellerTitleInfo::has_additionalinfoid() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void TovTorgSellerTitleInfo::set_has_additionalinfoid() {
  _has_bits_[0] |= 0x00080000u;
}
inline void TovTorgSellerTitleInfo::clear_has_additionalinfoid() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void TovTorgSellerTitleInfo::clear_additionalinfoid() {
  if (additionalinfoid_ != NULL) additionalinfoid_->::Diadoc::Api::Proto::Invoicing::AdditionalInfoId::Clear();
  clear_has_additionalinfoid();
}
inline const ::Diadoc::Api::Proto::Invoicing::AdditionalInfoId& TovTorgSellerTitleInfo::additionalinfoid() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.TovTorgSellerTitleInfo.AdditionalInfoId)
  return additionalinfoid_ != NULL ? *additionalinfoid_ : *default_instance_->additionalinfoid_;
}
inline ::Diadoc::Api::Proto::Invoicing::AdditionalInfoId* TovTorgSellerTitleInfo::mutable_additionalinfoid() {
  set_has_additionalinfoid();
  if (additionalinfoid_ == NULL) additionalinfoid_ = new ::Diadoc::Api::Proto::Invoicing::AdditionalInfoId;
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.TovTorgSellerTitleInfo.AdditionalInfoId)
  return additionalinfoid_;
}
inline ::Diadoc::Api::Proto::Invoicing::AdditionalInfoId* TovTorgSellerTitleInfo::release_additionalinfoid() {
  clear_has_additionalinfoid();
  ::Diadoc::Api::Proto::Invoicing::AdditionalInfoId* temp = additionalinfoid_;
  additionalinfoid_ = NULL;
  return temp;
}
inline void TovTorgSellerTitleInfo::set_allocated_additionalinfoid(::Diadoc::Api::Proto::Invoicing::AdditionalInfoId* additionalinfoid) {
  delete additionalinfoid_;
  additionalinfoid_ = additionalinfoid;
  if (additionalinfoid) {
    set_has_additionalinfoid();
  } else {
    clear_has_additionalinfoid();
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.TovTorgSellerTitleInfo.AdditionalInfoId)
}

// required string DocumentName = 21;
inline bool TovTorgSellerTitleInfo::has_documentname() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void TovTorgSellerTitleInfo::set_has_documentname() {
  _has_bits_[0] |= 0x00100000u;
}
inline void TovTorgSellerTitleInfo::clear_has_documentname() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void TovTorgSellerTitleInfo::clear_documentname() {
  if (documentname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    documentname_->clear();
  }
  clear_has_documentname();
}
inline const ::std::string& TovTorgSellerTitleInfo::documentname() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.TovTorgSellerTitleInfo.DocumentName)
  return *documentname_;
}
inline void TovTorgSellerTitleInfo::set_documentname(const ::std::string& value) {
  set_has_documentname();
  if (documentname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    documentname_ = new ::std::string;
  }
  documentname_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.TovTorgSellerTitleInfo.DocumentName)
}
inline void TovTorgSellerTitleInfo::set_documentname(const char* value) {
  set_has_documentname();
  if (documentname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    documentname_ = new ::std::string;
  }
  documentname_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.TovTorgSellerTitleInfo.DocumentName)
}
inline void TovTorgSellerTitleInfo::set_documentname(const char* value, size_t size) {
  set_has_documentname();
  if (documentname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    documentname_ = new ::std::string;
  }
  documentname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.TovTorgSellerTitleInfo.DocumentName)
}
inline ::std::string* TovTorgSellerTitleInfo::mutable_documentname() {
  set_has_documentname();
  if (documentname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    documentname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.TovTorgSellerTitleInfo.DocumentName)
  return documentname_;
}
inline ::std::string* TovTorgSellerTitleInfo::release_documentname() {
  clear_has_documentname();
  if (documentname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = documentname_;
    documentname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TovTorgSellerTitleInfo::set_allocated_documentname(::std::string* documentname) {
  if (documentname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete documentname_;
  }
  if (documentname) {
    set_has_documentname();
    documentname_ = documentname;
  } else {
    clear_has_documentname();
    documentname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.TovTorgSellerTitleInfo.DocumentName)
}

// -------------------------------------------------------------------

// TovTorgBuyerTitleInfo

// required string DocumentCreator = 1;
inline bool TovTorgBuyerTitleInfo::has_documentcreator() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TovTorgBuyerTitleInfo::set_has_documentcreator() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TovTorgBuyerTitleInfo::clear_has_documentcreator() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TovTorgBuyerTitleInfo::clear_documentcreator() {
  if (documentcreator_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    documentcreator_->clear();
  }
  clear_has_documentcreator();
}
inline const ::std::string& TovTorgBuyerTitleInfo::documentcreator() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.TovTorgBuyerTitleInfo.DocumentCreator)
  return *documentcreator_;
}
inline void TovTorgBuyerTitleInfo::set_documentcreator(const ::std::string& value) {
  set_has_documentcreator();
  if (documentcreator_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    documentcreator_ = new ::std::string;
  }
  documentcreator_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.TovTorgBuyerTitleInfo.DocumentCreator)
}
inline void TovTorgBuyerTitleInfo::set_documentcreator(const char* value) {
  set_has_documentcreator();
  if (documentcreator_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    documentcreator_ = new ::std::string;
  }
  documentcreator_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.TovTorgBuyerTitleInfo.DocumentCreator)
}
inline void TovTorgBuyerTitleInfo::set_documentcreator(const char* value, size_t size) {
  set_has_documentcreator();
  if (documentcreator_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    documentcreator_ = new ::std::string;
  }
  documentcreator_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.TovTorgBuyerTitleInfo.DocumentCreator)
}
inline ::std::string* TovTorgBuyerTitleInfo::mutable_documentcreator() {
  set_has_documentcreator();
  if (documentcreator_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    documentcreator_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.TovTorgBuyerTitleInfo.DocumentCreator)
  return documentcreator_;
}
inline ::std::string* TovTorgBuyerTitleInfo::release_documentcreator() {
  clear_has_documentcreator();
  if (documentcreator_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = documentcreator_;
    documentcreator_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TovTorgBuyerTitleInfo::set_allocated_documentcreator(::std::string* documentcreator) {
  if (documentcreator_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete documentcreator_;
  }
  if (documentcreator) {
    set_has_documentcreator();
    documentcreator_ = documentcreator;
  } else {
    clear_has_documentcreator();
    documentcreator_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.TovTorgBuyerTitleInfo.DocumentCreator)
}

// optional string DocumentCreatorBase = 2;
inline bool TovTorgBuyerTitleInfo::has_documentcreatorbase() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TovTorgBuyerTitleInfo::set_has_documentcreatorbase() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TovTorgBuyerTitleInfo::clear_has_documentcreatorbase() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TovTorgBuyerTitleInfo::clear_documentcreatorbase() {
  if (documentcreatorbase_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    documentcreatorbase_->clear();
  }
  clear_has_documentcreatorbase();
}
inline const ::std::string& TovTorgBuyerTitleInfo::documentcreatorbase() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.TovTorgBuyerTitleInfo.DocumentCreatorBase)
  return *documentcreatorbase_;
}
inline void TovTorgBuyerTitleInfo::set_documentcreatorbase(const ::std::string& value) {
  set_has_documentcreatorbase();
  if (documentcreatorbase_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    documentcreatorbase_ = new ::std::string;
  }
  documentcreatorbase_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.TovTorgBuyerTitleInfo.DocumentCreatorBase)
}
inline void TovTorgBuyerTitleInfo::set_documentcreatorbase(const char* value) {
  set_has_documentcreatorbase();
  if (documentcreatorbase_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    documentcreatorbase_ = new ::std::string;
  }
  documentcreatorbase_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.TovTorgBuyerTitleInfo.DocumentCreatorBase)
}
inline void TovTorgBuyerTitleInfo::set_documentcreatorbase(const char* value, size_t size) {
  set_has_documentcreatorbase();
  if (documentcreatorbase_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    documentcreatorbase_ = new ::std::string;
  }
  documentcreatorbase_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.TovTorgBuyerTitleInfo.DocumentCreatorBase)
}
inline ::std::string* TovTorgBuyerTitleInfo::mutable_documentcreatorbase() {
  set_has_documentcreatorbase();
  if (documentcreatorbase_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    documentcreatorbase_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.TovTorgBuyerTitleInfo.DocumentCreatorBase)
  return documentcreatorbase_;
}
inline ::std::string* TovTorgBuyerTitleInfo::release_documentcreatorbase() {
  clear_has_documentcreatorbase();
  if (documentcreatorbase_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = documentcreatorbase_;
    documentcreatorbase_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TovTorgBuyerTitleInfo::set_allocated_documentcreatorbase(::std::string* documentcreatorbase) {
  if (documentcreatorbase_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete documentcreatorbase_;
  }
  if (documentcreatorbase) {
    set_has_documentcreatorbase();
    documentcreatorbase_ = documentcreatorbase;
  } else {
    clear_has_documentcreatorbase();
    documentcreatorbase_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.TovTorgBuyerTitleInfo.DocumentCreatorBase)
}

// optional string OperationCode = 3;
inline bool TovTorgBuyerTitleInfo::has_operationcode() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TovTorgBuyerTitleInfo::set_has_operationcode() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TovTorgBuyerTitleInfo::clear_has_operationcode() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TovTorgBuyerTitleInfo::clear_operationcode() {
  if (operationcode_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    operationcode_->clear();
  }
  clear_has_operationcode();
}
inline const ::std::string& TovTorgBuyerTitleInfo::operationcode() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.TovTorgBuyerTitleInfo.OperationCode)
  return *operationcode_;
}
inline void TovTorgBuyerTitleInfo::set_operationcode(const ::std::string& value) {
  set_has_operationcode();
  if (operationcode_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    operationcode_ = new ::std::string;
  }
  operationcode_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.TovTorgBuyerTitleInfo.OperationCode)
}
inline void TovTorgBuyerTitleInfo::set_operationcode(const char* value) {
  set_has_operationcode();
  if (operationcode_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    operationcode_ = new ::std::string;
  }
  operationcode_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.TovTorgBuyerTitleInfo.OperationCode)
}
inline void TovTorgBuyerTitleInfo::set_operationcode(const char* value, size_t size) {
  set_has_operationcode();
  if (operationcode_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    operationcode_ = new ::std::string;
  }
  operationcode_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.TovTorgBuyerTitleInfo.OperationCode)
}
inline ::std::string* TovTorgBuyerTitleInfo::mutable_operationcode() {
  set_has_operationcode();
  if (operationcode_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    operationcode_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.TovTorgBuyerTitleInfo.OperationCode)
  return operationcode_;
}
inline ::std::string* TovTorgBuyerTitleInfo::release_operationcode() {
  clear_has_operationcode();
  if (operationcode_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = operationcode_;
    operationcode_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TovTorgBuyerTitleInfo::set_allocated_operationcode(::std::string* operationcode) {
  if (operationcode_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete operationcode_;
  }
  if (operationcode) {
    set_has_operationcode();
    operationcode_ = operationcode;
  } else {
    clear_has_operationcode();
    operationcode_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.TovTorgBuyerTitleInfo.OperationCode)
}

// required string OperationContent = 4;
inline bool TovTorgBuyerTitleInfo::has_operationcontent() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TovTorgBuyerTitleInfo::set_has_operationcontent() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TovTorgBuyerTitleInfo::clear_has_operationcontent() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TovTorgBuyerTitleInfo::clear_operationcontent() {
  if (operationcontent_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    operationcontent_->clear();
  }
  clear_has_operationcontent();
}
inline const ::std::string& TovTorgBuyerTitleInfo::operationcontent() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.TovTorgBuyerTitleInfo.OperationContent)
  return *operationcontent_;
}
inline void TovTorgBuyerTitleInfo::set_operationcontent(const ::std::string& value) {
  set_has_operationcontent();
  if (operationcontent_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    operationcontent_ = new ::std::string;
  }
  operationcontent_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.TovTorgBuyerTitleInfo.OperationContent)
}
inline void TovTorgBuyerTitleInfo::set_operationcontent(const char* value) {
  set_has_operationcontent();
  if (operationcontent_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    operationcontent_ = new ::std::string;
  }
  operationcontent_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.TovTorgBuyerTitleInfo.OperationContent)
}
inline void TovTorgBuyerTitleInfo::set_operationcontent(const char* value, size_t size) {
  set_has_operationcontent();
  if (operationcontent_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    operationcontent_ = new ::std::string;
  }
  operationcontent_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.TovTorgBuyerTitleInfo.OperationContent)
}
inline ::std::string* TovTorgBuyerTitleInfo::mutable_operationcontent() {
  set_has_operationcontent();
  if (operationcontent_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    operationcontent_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.TovTorgBuyerTitleInfo.OperationContent)
  return operationcontent_;
}
inline ::std::string* TovTorgBuyerTitleInfo::release_operationcontent() {
  clear_has_operationcontent();
  if (operationcontent_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = operationcontent_;
    operationcontent_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TovTorgBuyerTitleInfo::set_allocated_operationcontent(::std::string* operationcontent) {
  if (operationcontent_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete operationcontent_;
  }
  if (operationcontent) {
    set_has_operationcontent();
    operationcontent_ = operationcontent;
  } else {
    clear_has_operationcontent();
    operationcontent_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.TovTorgBuyerTitleInfo.OperationContent)
}

// optional string AcceptanceDate = 5;
inline bool TovTorgBuyerTitleInfo::has_acceptancedate() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TovTorgBuyerTitleInfo::set_has_acceptancedate() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TovTorgBuyerTitleInfo::clear_has_acceptancedate() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TovTorgBuyerTitleInfo::clear_acceptancedate() {
  if (acceptancedate_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    acceptancedate_->clear();
  }
  clear_has_acceptancedate();
}
inline const ::std::string& TovTorgBuyerTitleInfo::acceptancedate() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.TovTorgBuyerTitleInfo.AcceptanceDate)
  return *acceptancedate_;
}
inline void TovTorgBuyerTitleInfo::set_acceptancedate(const ::std::string& value) {
  set_has_acceptancedate();
  if (acceptancedate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    acceptancedate_ = new ::std::string;
  }
  acceptancedate_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.TovTorgBuyerTitleInfo.AcceptanceDate)
}
inline void TovTorgBuyerTitleInfo::set_acceptancedate(const char* value) {
  set_has_acceptancedate();
  if (acceptancedate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    acceptancedate_ = new ::std::string;
  }
  acceptancedate_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.TovTorgBuyerTitleInfo.AcceptanceDate)
}
inline void TovTorgBuyerTitleInfo::set_acceptancedate(const char* value, size_t size) {
  set_has_acceptancedate();
  if (acceptancedate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    acceptancedate_ = new ::std::string;
  }
  acceptancedate_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.TovTorgBuyerTitleInfo.AcceptanceDate)
}
inline ::std::string* TovTorgBuyerTitleInfo::mutable_acceptancedate() {
  set_has_acceptancedate();
  if (acceptancedate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    acceptancedate_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.TovTorgBuyerTitleInfo.AcceptanceDate)
  return acceptancedate_;
}
inline ::std::string* TovTorgBuyerTitleInfo::release_acceptancedate() {
  clear_has_acceptancedate();
  if (acceptancedate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = acceptancedate_;
    acceptancedate_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TovTorgBuyerTitleInfo::set_allocated_acceptancedate(::std::string* acceptancedate) {
  if (acceptancedate_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete acceptancedate_;
  }
  if (acceptancedate) {
    set_has_acceptancedate();
    acceptancedate_ = acceptancedate;
  } else {
    clear_has_acceptancedate();
    acceptancedate_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.TovTorgBuyerTitleInfo.AcceptanceDate)
}

// optional .Diadoc.Api.Proto.Invoicing.Employee Employee = 6;
inline bool TovTorgBuyerTitleInfo::has_employee() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TovTorgBuyerTitleInfo::set_has_employee() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TovTorgBuyerTitleInfo::clear_has_employee() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TovTorgBuyerTitleInfo::clear_employee() {
  if (employee_ != NULL) employee_->::Diadoc::Api::Proto::Invoicing::Employee::Clear();
  clear_has_employee();
}
inline const ::Diadoc::Api::Proto::Invoicing::Employee& TovTorgBuyerTitleInfo::employee() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.TovTorgBuyerTitleInfo.Employee)
  return employee_ != NULL ? *employee_ : *default_instance_->employee_;
}
inline ::Diadoc::Api::Proto::Invoicing::Employee* TovTorgBuyerTitleInfo::mutable_employee() {
  set_has_employee();
  if (employee_ == NULL) employee_ = new ::Diadoc::Api::Proto::Invoicing::Employee;
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.TovTorgBuyerTitleInfo.Employee)
  return employee_;
}
inline ::Diadoc::Api::Proto::Invoicing::Employee* TovTorgBuyerTitleInfo::release_employee() {
  clear_has_employee();
  ::Diadoc::Api::Proto::Invoicing::Employee* temp = employee_;
  employee_ = NULL;
  return temp;
}
inline void TovTorgBuyerTitleInfo::set_allocated_employee(::Diadoc::Api::Proto::Invoicing::Employee* employee) {
  delete employee_;
  employee_ = employee;
  if (employee) {
    set_has_employee();
  } else {
    clear_has_employee();
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.TovTorgBuyerTitleInfo.Employee)
}

// optional .Diadoc.Api.Proto.Invoicing.OtherIssuer OtherIssuer = 7;
inline bool TovTorgBuyerTitleInfo::has_otherissuer() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TovTorgBuyerTitleInfo::set_has_otherissuer() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TovTorgBuyerTitleInfo::clear_has_otherissuer() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TovTorgBuyerTitleInfo::clear_otherissuer() {
  if (otherissuer_ != NULL) otherissuer_->::Diadoc::Api::Proto::Invoicing::OtherIssuer::Clear();
  clear_has_otherissuer();
}
inline const ::Diadoc::Api::Proto::Invoicing::OtherIssuer& TovTorgBuyerTitleInfo::otherissuer() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.TovTorgBuyerTitleInfo.OtherIssuer)
  return otherissuer_ != NULL ? *otherissuer_ : *default_instance_->otherissuer_;
}
inline ::Diadoc::Api::Proto::Invoicing::OtherIssuer* TovTorgBuyerTitleInfo::mutable_otherissuer() {
  set_has_otherissuer();
  if (otherissuer_ == NULL) otherissuer_ = new ::Diadoc::Api::Proto::Invoicing::OtherIssuer;
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.TovTorgBuyerTitleInfo.OtherIssuer)
  return otherissuer_;
}
inline ::Diadoc::Api::Proto::Invoicing::OtherIssuer* TovTorgBuyerTitleInfo::release_otherissuer() {
  clear_has_otherissuer();
  ::Diadoc::Api::Proto::Invoicing::OtherIssuer* temp = otherissuer_;
  otherissuer_ = NULL;
  return temp;
}
inline void TovTorgBuyerTitleInfo::set_allocated_otherissuer(::Diadoc::Api::Proto::Invoicing::OtherIssuer* otherissuer) {
  delete otherissuer_;
  otherissuer_ = otherissuer;
  if (otherissuer) {
    set_has_otherissuer();
  } else {
    clear_has_otherissuer();
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.TovTorgBuyerTitleInfo.OtherIssuer)
}

// optional .Diadoc.Api.Proto.Invoicing.AdditionalInfoId AdditionalInfoId = 8;
inline bool TovTorgBuyerTitleInfo::has_additionalinfoid() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TovTorgBuyerTitleInfo::set_has_additionalinfoid() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TovTorgBuyerTitleInfo::clear_has_additionalinfoid() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TovTorgBuyerTitleInfo::clear_additionalinfoid() {
  if (additionalinfoid_ != NULL) additionalinfoid_->::Diadoc::Api::Proto::Invoicing::AdditionalInfoId::Clear();
  clear_has_additionalinfoid();
}
inline const ::Diadoc::Api::Proto::Invoicing::AdditionalInfoId& TovTorgBuyerTitleInfo::additionalinfoid() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.TovTorgBuyerTitleInfo.AdditionalInfoId)
  return additionalinfoid_ != NULL ? *additionalinfoid_ : *default_instance_->additionalinfoid_;
}
inline ::Diadoc::Api::Proto::Invoicing::AdditionalInfoId* TovTorgBuyerTitleInfo::mutable_additionalinfoid() {
  set_has_additionalinfoid();
  if (additionalinfoid_ == NULL) additionalinfoid_ = new ::Diadoc::Api::Proto::Invoicing::AdditionalInfoId;
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.TovTorgBuyerTitleInfo.AdditionalInfoId)
  return additionalinfoid_;
}
inline ::Diadoc::Api::Proto::Invoicing::AdditionalInfoId* TovTorgBuyerTitleInfo::release_additionalinfoid() {
  clear_has_additionalinfoid();
  ::Diadoc::Api::Proto::Invoicing::AdditionalInfoId* temp = additionalinfoid_;
  additionalinfoid_ = NULL;
  return temp;
}
inline void TovTorgBuyerTitleInfo::set_allocated_additionalinfoid(::Diadoc::Api::Proto::Invoicing::AdditionalInfoId* additionalinfoid) {
  delete additionalinfoid_;
  additionalinfoid_ = additionalinfoid;
  if (additionalinfoid) {
    set_has_additionalinfoid();
  } else {
    clear_has_additionalinfoid();
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.TovTorgBuyerTitleInfo.AdditionalInfoId)
}

// repeated .Diadoc.Api.Proto.Invoicing.Signers.ExtendedSigner Signers = 9;
inline int TovTorgBuyerTitleInfo::signers_size() const {
  return signers_.size();
}
inline void TovTorgBuyerTitleInfo::clear_signers() {
  signers_.Clear();
}
inline const ::Diadoc::Api::Proto::Invoicing::Signers::ExtendedSigner& TovTorgBuyerTitleInfo::signers(int index) const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.TovTorgBuyerTitleInfo.Signers)
  return signers_.Get(index);
}
inline ::Diadoc::Api::Proto::Invoicing::Signers::ExtendedSigner* TovTorgBuyerTitleInfo::mutable_signers(int index) {
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.TovTorgBuyerTitleInfo.Signers)
  return signers_.Mutable(index);
}
inline ::Diadoc::Api::Proto::Invoicing::Signers::ExtendedSigner* TovTorgBuyerTitleInfo::add_signers() {
  // @@protoc_insertion_point(field_add:Diadoc.Api.Proto.Invoicing.TovTorgBuyerTitleInfo.Signers)
  return signers_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::Signers::ExtendedSigner >&
TovTorgBuyerTitleInfo::signers() const {
  // @@protoc_insertion_point(field_list:Diadoc.Api.Proto.Invoicing.TovTorgBuyerTitleInfo.Signers)
  return signers_;
}
inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::Signers::ExtendedSigner >*
TovTorgBuyerTitleInfo::mutable_signers() {
  // @@protoc_insertion_point(field_mutable_list:Diadoc.Api.Proto.Invoicing.TovTorgBuyerTitleInfo.Signers)
  return &signers_;
}

// -------------------------------------------------------------------

// TovTorgTable

// repeated .Diadoc.Api.Proto.Invoicing.TovTorgItem Items = 1;
inline int TovTorgTable::items_size() const {
  return items_.size();
}
inline void TovTorgTable::clear_items() {
  items_.Clear();
}
inline const ::Diadoc::Api::Proto::Invoicing::TovTorgItem& TovTorgTable::items(int index) const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.TovTorgTable.Items)
  return items_.Get(index);
}
inline ::Diadoc::Api::Proto::Invoicing::TovTorgItem* TovTorgTable::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.TovTorgTable.Items)
  return items_.Mutable(index);
}
inline ::Diadoc::Api::Proto::Invoicing::TovTorgItem* TovTorgTable::add_items() {
  // @@protoc_insertion_point(field_add:Diadoc.Api.Proto.Invoicing.TovTorgTable.Items)
  return items_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::TovTorgItem >&
TovTorgTable::items() const {
  // @@protoc_insertion_point(field_list:Diadoc.Api.Proto.Invoicing.TovTorgTable.Items)
  return items_;
}
inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::TovTorgItem >*
TovTorgTable::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:Diadoc.Api.Proto.Invoicing.TovTorgTable.Items)
  return &items_;
}

// optional string TotalQuantity = 2;
inline bool TovTorgTable::has_totalquantity() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TovTorgTable::set_has_totalquantity() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TovTorgTable::clear_has_totalquantity() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TovTorgTable::clear_totalquantity() {
  if (totalquantity_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    totalquantity_->clear();
  }
  clear_has_totalquantity();
}
inline const ::std::string& TovTorgTable::totalquantity() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.TovTorgTable.TotalQuantity)
  return *totalquantity_;
}
inline void TovTorgTable::set_totalquantity(const ::std::string& value) {
  set_has_totalquantity();
  if (totalquantity_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    totalquantity_ = new ::std::string;
  }
  totalquantity_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.TovTorgTable.TotalQuantity)
}
inline void TovTorgTable::set_totalquantity(const char* value) {
  set_has_totalquantity();
  if (totalquantity_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    totalquantity_ = new ::std::string;
  }
  totalquantity_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.TovTorgTable.TotalQuantity)
}
inline void TovTorgTable::set_totalquantity(const char* value, size_t size) {
  set_has_totalquantity();
  if (totalquantity_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    totalquantity_ = new ::std::string;
  }
  totalquantity_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.TovTorgTable.TotalQuantity)
}
inline ::std::string* TovTorgTable::mutable_totalquantity() {
  set_has_totalquantity();
  if (totalquantity_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    totalquantity_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.TovTorgTable.TotalQuantity)
  return totalquantity_;
}
inline ::std::string* TovTorgTable::release_totalquantity() {
  clear_has_totalquantity();
  if (totalquantity_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = totalquantity_;
    totalquantity_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TovTorgTable::set_allocated_totalquantity(::std::string* totalquantity) {
  if (totalquantity_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete totalquantity_;
  }
  if (totalquantity) {
    set_has_totalquantity();
    totalquantity_ = totalquantity;
  } else {
    clear_has_totalquantity();
    totalquantity_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.TovTorgTable.TotalQuantity)
}

// optional string TotalGross = 3;
inline bool TovTorgTable::has_totalgross() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TovTorgTable::set_has_totalgross() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TovTorgTable::clear_has_totalgross() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TovTorgTable::clear_totalgross() {
  if (totalgross_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    totalgross_->clear();
  }
  clear_has_totalgross();
}
inline const ::std::string& TovTorgTable::totalgross() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.TovTorgTable.TotalGross)
  return *totalgross_;
}
inline void TovTorgTable::set_totalgross(const ::std::string& value) {
  set_has_totalgross();
  if (totalgross_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    totalgross_ = new ::std::string;
  }
  totalgross_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.TovTorgTable.TotalGross)
}
inline void TovTorgTable::set_totalgross(const char* value) {
  set_has_totalgross();
  if (totalgross_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    totalgross_ = new ::std::string;
  }
  totalgross_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.TovTorgTable.TotalGross)
}
inline void TovTorgTable::set_totalgross(const char* value, size_t size) {
  set_has_totalgross();
  if (totalgross_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    totalgross_ = new ::std::string;
  }
  totalgross_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.TovTorgTable.TotalGross)
}
inline ::std::string* TovTorgTable::mutable_totalgross() {
  set_has_totalgross();
  if (totalgross_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    totalgross_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.TovTorgTable.TotalGross)
  return totalgross_;
}
inline ::std::string* TovTorgTable::release_totalgross() {
  clear_has_totalgross();
  if (totalgross_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = totalgross_;
    totalgross_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TovTorgTable::set_allocated_totalgross(::std::string* totalgross) {
  if (totalgross_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete totalgross_;
  }
  if (totalgross) {
    set_has_totalgross();
    totalgross_ = totalgross;
  } else {
    clear_has_totalgross();
    totalgross_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.TovTorgTable.TotalGross)
}

// optional string TotalNet = 4;
inline bool TovTorgTable::has_totalnet() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TovTorgTable::set_has_totalnet() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TovTorgTable::clear_has_totalnet() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TovTorgTable::clear_totalnet() {
  if (totalnet_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    totalnet_->clear();
  }
  clear_has_totalnet();
}
inline const ::std::string& TovTorgTable::totalnet() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.TovTorgTable.TotalNet)
  return *totalnet_;
}
inline void TovTorgTable::set_totalnet(const ::std::string& value) {
  set_has_totalnet();
  if (totalnet_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    totalnet_ = new ::std::string;
  }
  totalnet_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.TovTorgTable.TotalNet)
}
inline void TovTorgTable::set_totalnet(const char* value) {
  set_has_totalnet();
  if (totalnet_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    totalnet_ = new ::std::string;
  }
  totalnet_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.TovTorgTable.TotalNet)
}
inline void TovTorgTable::set_totalnet(const char* value, size_t size) {
  set_has_totalnet();
  if (totalnet_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    totalnet_ = new ::std::string;
  }
  totalnet_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.TovTorgTable.TotalNet)
}
inline ::std::string* TovTorgTable::mutable_totalnet() {
  set_has_totalnet();
  if (totalnet_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    totalnet_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.TovTorgTable.TotalNet)
  return totalnet_;
}
inline ::std::string* TovTorgTable::release_totalnet() {
  clear_has_totalnet();
  if (totalnet_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = totalnet_;
    totalnet_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TovTorgTable::set_allocated_totalnet(::std::string* totalnet) {
  if (totalnet_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete totalnet_;
  }
  if (totalnet) {
    set_has_totalnet();
    totalnet_ = totalnet;
  } else {
    clear_has_totalnet();
    totalnet_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.TovTorgTable.TotalNet)
}

// optional string TotalWithVatExcluded = 5;
inline bool TovTorgTable::has_totalwithvatexcluded() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TovTorgTable::set_has_totalwithvatexcluded() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TovTorgTable::clear_has_totalwithvatexcluded() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TovTorgTable::clear_totalwithvatexcluded() {
  if (totalwithvatexcluded_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    totalwithvatexcluded_->clear();
  }
  clear_has_totalwithvatexcluded();
}
inline const ::std::string& TovTorgTable::totalwithvatexcluded() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.TovTorgTable.TotalWithVatExcluded)
  return *totalwithvatexcluded_;
}
inline void TovTorgTable::set_totalwithvatexcluded(const ::std::string& value) {
  set_has_totalwithvatexcluded();
  if (totalwithvatexcluded_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    totalwithvatexcluded_ = new ::std::string;
  }
  totalwithvatexcluded_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.TovTorgTable.TotalWithVatExcluded)
}
inline void TovTorgTable::set_totalwithvatexcluded(const char* value) {
  set_has_totalwithvatexcluded();
  if (totalwithvatexcluded_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    totalwithvatexcluded_ = new ::std::string;
  }
  totalwithvatexcluded_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.TovTorgTable.TotalWithVatExcluded)
}
inline void TovTorgTable::set_totalwithvatexcluded(const char* value, size_t size) {
  set_has_totalwithvatexcluded();
  if (totalwithvatexcluded_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    totalwithvatexcluded_ = new ::std::string;
  }
  totalwithvatexcluded_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.TovTorgTable.TotalWithVatExcluded)
}
inline ::std::string* TovTorgTable::mutable_totalwithvatexcluded() {
  set_has_totalwithvatexcluded();
  if (totalwithvatexcluded_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    totalwithvatexcluded_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.TovTorgTable.TotalWithVatExcluded)
  return totalwithvatexcluded_;
}
inline ::std::string* TovTorgTable::release_totalwithvatexcluded() {
  clear_has_totalwithvatexcluded();
  if (totalwithvatexcluded_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = totalwithvatexcluded_;
    totalwithvatexcluded_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TovTorgTable::set_allocated_totalwithvatexcluded(::std::string* totalwithvatexcluded) {
  if (totalwithvatexcluded_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete totalwithvatexcluded_;
  }
  if (totalwithvatexcluded) {
    set_has_totalwithvatexcluded();
    totalwithvatexcluded_ = totalwithvatexcluded;
  } else {
    clear_has_totalwithvatexcluded();
    totalwithvatexcluded_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.TovTorgTable.TotalWithVatExcluded)
}

// optional string TotalVat = 6;
inline bool TovTorgTable::has_totalvat() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TovTorgTable::set_has_totalvat() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TovTorgTable::clear_has_totalvat() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TovTorgTable::clear_totalvat() {
  if (totalvat_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    totalvat_->clear();
  }
  clear_has_totalvat();
}
inline const ::std::string& TovTorgTable::totalvat() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.TovTorgTable.TotalVat)
  return *totalvat_;
}
inline void TovTorgTable::set_totalvat(const ::std::string& value) {
  set_has_totalvat();
  if (totalvat_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    totalvat_ = new ::std::string;
  }
  totalvat_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.TovTorgTable.TotalVat)
}
inline void TovTorgTable::set_totalvat(const char* value) {
  set_has_totalvat();
  if (totalvat_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    totalvat_ = new ::std::string;
  }
  totalvat_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.TovTorgTable.TotalVat)
}
inline void TovTorgTable::set_totalvat(const char* value, size_t size) {
  set_has_totalvat();
  if (totalvat_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    totalvat_ = new ::std::string;
  }
  totalvat_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.TovTorgTable.TotalVat)
}
inline ::std::string* TovTorgTable::mutable_totalvat() {
  set_has_totalvat();
  if (totalvat_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    totalvat_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.TovTorgTable.TotalVat)
  return totalvat_;
}
inline ::std::string* TovTorgTable::release_totalvat() {
  clear_has_totalvat();
  if (totalvat_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = totalvat_;
    totalvat_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TovTorgTable::set_allocated_totalvat(::std::string* totalvat) {
  if (totalvat_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete totalvat_;
  }
  if (totalvat) {
    set_has_totalvat();
    totalvat_ = totalvat;
  } else {
    clear_has_totalvat();
    totalvat_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.TovTorgTable.TotalVat)
}

// optional string Total = 7;
inline bool TovTorgTable::has_total() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TovTorgTable::set_has_total() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TovTorgTable::clear_has_total() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TovTorgTable::clear_total() {
  if (total_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    total_->clear();
  }
  clear_has_total();
}
inline const ::std::string& TovTorgTable::total() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.TovTorgTable.Total)
  return *total_;
}
inline void TovTorgTable::set_total(const ::std::string& value) {
  set_has_total();
  if (total_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    total_ = new ::std::string;
  }
  total_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.TovTorgTable.Total)
}
inline void TovTorgTable::set_total(const char* value) {
  set_has_total();
  if (total_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    total_ = new ::std::string;
  }
  total_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.TovTorgTable.Total)
}
inline void TovTorgTable::set_total(const char* value, size_t size) {
  set_has_total();
  if (total_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    total_ = new ::std::string;
  }
  total_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.TovTorgTable.Total)
}
inline ::std::string* TovTorgTable::mutable_total() {
  set_has_total();
  if (total_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    total_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.TovTorgTable.Total)
  return total_;
}
inline ::std::string* TovTorgTable::release_total() {
  clear_has_total();
  if (total_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = total_;
    total_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TovTorgTable::set_allocated_total(::std::string* total) {
  if (total_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete total_;
  }
  if (total) {
    set_has_total();
    total_ = total;
  } else {
    clear_has_total();
    total_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.TovTorgTable.Total)
}

// -------------------------------------------------------------------

// TovTorgItem

// optional string Product = 1;
inline bool TovTorgItem::has_product() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TovTorgItem::set_has_product() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TovTorgItem::clear_has_product() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TovTorgItem::clear_product() {
  if (product_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    product_->clear();
  }
  clear_has_product();
}
inline const ::std::string& TovTorgItem::product() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.TovTorgItem.Product)
  return *product_;
}
inline void TovTorgItem::set_product(const ::std::string& value) {
  set_has_product();
  if (product_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    product_ = new ::std::string;
  }
  product_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.TovTorgItem.Product)
}
inline void TovTorgItem::set_product(const char* value) {
  set_has_product();
  if (product_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    product_ = new ::std::string;
  }
  product_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.TovTorgItem.Product)
}
inline void TovTorgItem::set_product(const char* value, size_t size) {
  set_has_product();
  if (product_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    product_ = new ::std::string;
  }
  product_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.TovTorgItem.Product)
}
inline ::std::string* TovTorgItem::mutable_product() {
  set_has_product();
  if (product_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    product_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.TovTorgItem.Product)
  return product_;
}
inline ::std::string* TovTorgItem::release_product() {
  clear_has_product();
  if (product_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = product_;
    product_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TovTorgItem::set_allocated_product(::std::string* product) {
  if (product_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete product_;
  }
  if (product) {
    set_has_product();
    product_ = product;
  } else {
    clear_has_product();
    product_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.TovTorgItem.Product)
}

// optional string Feature = 2;
inline bool TovTorgItem::has_feature() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TovTorgItem::set_has_feature() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TovTorgItem::clear_has_feature() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TovTorgItem::clear_feature() {
  if (feature_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    feature_->clear();
  }
  clear_has_feature();
}
inline const ::std::string& TovTorgItem::feature() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.TovTorgItem.Feature)
  return *feature_;
}
inline void TovTorgItem::set_feature(const ::std::string& value) {
  set_has_feature();
  if (feature_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    feature_ = new ::std::string;
  }
  feature_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.TovTorgItem.Feature)
}
inline void TovTorgItem::set_feature(const char* value) {
  set_has_feature();
  if (feature_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    feature_ = new ::std::string;
  }
  feature_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.TovTorgItem.Feature)
}
inline void TovTorgItem::set_feature(const char* value, size_t size) {
  set_has_feature();
  if (feature_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    feature_ = new ::std::string;
  }
  feature_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.TovTorgItem.Feature)
}
inline ::std::string* TovTorgItem::mutable_feature() {
  set_has_feature();
  if (feature_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    feature_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.TovTorgItem.Feature)
  return feature_;
}
inline ::std::string* TovTorgItem::release_feature() {
  clear_has_feature();
  if (feature_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = feature_;
    feature_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TovTorgItem::set_allocated_feature(::std::string* feature) {
  if (feature_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete feature_;
  }
  if (feature) {
    set_has_feature();
    feature_ = feature;
  } else {
    clear_has_feature();
    feature_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.TovTorgItem.Feature)
}

// optional string Sort = 3;
inline bool TovTorgItem::has_sort() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TovTorgItem::set_has_sort() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TovTorgItem::clear_has_sort() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TovTorgItem::clear_sort() {
  if (sort_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sort_->clear();
  }
  clear_has_sort();
}
inline const ::std::string& TovTorgItem::sort() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.TovTorgItem.Sort)
  return *sort_;
}
inline void TovTorgItem::set_sort(const ::std::string& value) {
  set_has_sort();
  if (sort_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sort_ = new ::std::string;
  }
  sort_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.TovTorgItem.Sort)
}
inline void TovTorgItem::set_sort(const char* value) {
  set_has_sort();
  if (sort_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sort_ = new ::std::string;
  }
  sort_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.TovTorgItem.Sort)
}
inline void TovTorgItem::set_sort(const char* value, size_t size) {
  set_has_sort();
  if (sort_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sort_ = new ::std::string;
  }
  sort_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.TovTorgItem.Sort)
}
inline ::std::string* TovTorgItem::mutable_sort() {
  set_has_sort();
  if (sort_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sort_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.TovTorgItem.Sort)
  return sort_;
}
inline ::std::string* TovTorgItem::release_sort() {
  clear_has_sort();
  if (sort_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = sort_;
    sort_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TovTorgItem::set_allocated_sort(::std::string* sort) {
  if (sort_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete sort_;
  }
  if (sort) {
    set_has_sort();
    sort_ = sort;
  } else {
    clear_has_sort();
    sort_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.TovTorgItem.Sort)
}

// optional string VendorCode = 4;
inline bool TovTorgItem::has_vendorcode() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TovTorgItem::set_has_vendorcode() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TovTorgItem::clear_has_vendorcode() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TovTorgItem::clear_vendorcode() {
  if (vendorcode_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vendorcode_->clear();
  }
  clear_has_vendorcode();
}
inline const ::std::string& TovTorgItem::vendorcode() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.TovTorgItem.VendorCode)
  return *vendorcode_;
}
inline void TovTorgItem::set_vendorcode(const ::std::string& value) {
  set_has_vendorcode();
  if (vendorcode_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vendorcode_ = new ::std::string;
  }
  vendorcode_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.TovTorgItem.VendorCode)
}
inline void TovTorgItem::set_vendorcode(const char* value) {
  set_has_vendorcode();
  if (vendorcode_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vendorcode_ = new ::std::string;
  }
  vendorcode_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.TovTorgItem.VendorCode)
}
inline void TovTorgItem::set_vendorcode(const char* value, size_t size) {
  set_has_vendorcode();
  if (vendorcode_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vendorcode_ = new ::std::string;
  }
  vendorcode_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.TovTorgItem.VendorCode)
}
inline ::std::string* TovTorgItem::mutable_vendorcode() {
  set_has_vendorcode();
  if (vendorcode_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vendorcode_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.TovTorgItem.VendorCode)
  return vendorcode_;
}
inline ::std::string* TovTorgItem::release_vendorcode() {
  clear_has_vendorcode();
  if (vendorcode_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = vendorcode_;
    vendorcode_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TovTorgItem::set_allocated_vendorcode(::std::string* vendorcode) {
  if (vendorcode_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete vendorcode_;
  }
  if (vendorcode) {
    set_has_vendorcode();
    vendorcode_ = vendorcode;
  } else {
    clear_has_vendorcode();
    vendorcode_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.TovTorgItem.VendorCode)
}

// optional string ProductCode = 5;
inline bool TovTorgItem::has_productcode() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TovTorgItem::set_has_productcode() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TovTorgItem::clear_has_productcode() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TovTorgItem::clear_productcode() {
  if (productcode_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    productcode_->clear();
  }
  clear_has_productcode();
}
inline const ::std::string& TovTorgItem::productcode() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.TovTorgItem.ProductCode)
  return *productcode_;
}
inline void TovTorgItem::set_productcode(const ::std::string& value) {
  set_has_productcode();
  if (productcode_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    productcode_ = new ::std::string;
  }
  productcode_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.TovTorgItem.ProductCode)
}
inline void TovTorgItem::set_productcode(const char* value) {
  set_has_productcode();
  if (productcode_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    productcode_ = new ::std::string;
  }
  productcode_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.TovTorgItem.ProductCode)
}
inline void TovTorgItem::set_productcode(const char* value, size_t size) {
  set_has_productcode();
  if (productcode_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    productcode_ = new ::std::string;
  }
  productcode_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.TovTorgItem.ProductCode)
}
inline ::std::string* TovTorgItem::mutable_productcode() {
  set_has_productcode();
  if (productcode_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    productcode_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.TovTorgItem.ProductCode)
  return productcode_;
}
inline ::std::string* TovTorgItem::release_productcode() {
  clear_has_productcode();
  if (productcode_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = productcode_;
    productcode_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TovTorgItem::set_allocated_productcode(::std::string* productcode) {
  if (productcode_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete productcode_;
  }
  if (productcode) {
    set_has_productcode();
    productcode_ = productcode;
  } else {
    clear_has_productcode();
    productcode_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.TovTorgItem.ProductCode)
}

// optional string UnitName = 6;
inline bool TovTorgItem::has_unitname() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TovTorgItem::set_has_unitname() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TovTorgItem::clear_has_unitname() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TovTorgItem::clear_unitname() {
  if (unitname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    unitname_->clear();
  }
  clear_has_unitname();
}
inline const ::std::string& TovTorgItem::unitname() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.TovTorgItem.UnitName)
  return *unitname_;
}
inline void TovTorgItem::set_unitname(const ::std::string& value) {
  set_has_unitname();
  if (unitname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    unitname_ = new ::std::string;
  }
  unitname_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.TovTorgItem.UnitName)
}
inline void TovTorgItem::set_unitname(const char* value) {
  set_has_unitname();
  if (unitname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    unitname_ = new ::std::string;
  }
  unitname_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.TovTorgItem.UnitName)
}
inline void TovTorgItem::set_unitname(const char* value, size_t size) {
  set_has_unitname();
  if (unitname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    unitname_ = new ::std::string;
  }
  unitname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.TovTorgItem.UnitName)
}
inline ::std::string* TovTorgItem::mutable_unitname() {
  set_has_unitname();
  if (unitname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    unitname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.TovTorgItem.UnitName)
  return unitname_;
}
inline ::std::string* TovTorgItem::release_unitname() {
  clear_has_unitname();
  if (unitname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = unitname_;
    unitname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TovTorgItem::set_allocated_unitname(::std::string* unitname) {
  if (unitname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete unitname_;
  }
  if (unitname) {
    set_has_unitname();
    unitname_ = unitname;
  } else {
    clear_has_unitname();
    unitname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.TovTorgItem.UnitName)
}

// required string Unit = 7;
inline bool TovTorgItem::has_unit() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TovTorgItem::set_has_unit() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TovTorgItem::clear_has_unit() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TovTorgItem::clear_unit() {
  if (unit_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    unit_->clear();
  }
  clear_has_unit();
}
inline const ::std::string& TovTorgItem::unit() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.TovTorgItem.Unit)
  return *unit_;
}
inline void TovTorgItem::set_unit(const ::std::string& value) {
  set_has_unit();
  if (unit_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    unit_ = new ::std::string;
  }
  unit_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.TovTorgItem.Unit)
}
inline void TovTorgItem::set_unit(const char* value) {
  set_has_unit();
  if (unit_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    unit_ = new ::std::string;
  }
  unit_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.TovTorgItem.Unit)
}
inline void TovTorgItem::set_unit(const char* value, size_t size) {
  set_has_unit();
  if (unit_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    unit_ = new ::std::string;
  }
  unit_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.TovTorgItem.Unit)
}
inline ::std::string* TovTorgItem::mutable_unit() {
  set_has_unit();
  if (unit_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    unit_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.TovTorgItem.Unit)
  return unit_;
}
inline ::std::string* TovTorgItem::release_unit() {
  clear_has_unit();
  if (unit_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = unit_;
    unit_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TovTorgItem::set_allocated_unit(::std::string* unit) {
  if (unit_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete unit_;
  }
  if (unit) {
    set_has_unit();
    unit_ = unit;
  } else {
    clear_has_unit();
    unit_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.TovTorgItem.Unit)
}

// optional string PackageType = 8;
inline bool TovTorgItem::has_packagetype() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TovTorgItem::set_has_packagetype() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TovTorgItem::clear_has_packagetype() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TovTorgItem::clear_packagetype() {
  if (packagetype_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    packagetype_->clear();
  }
  clear_has_packagetype();
}
inline const ::std::string& TovTorgItem::packagetype() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.TovTorgItem.PackageType)
  return *packagetype_;
}
inline void TovTorgItem::set_packagetype(const ::std::string& value) {
  set_has_packagetype();
  if (packagetype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    packagetype_ = new ::std::string;
  }
  packagetype_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.TovTorgItem.PackageType)
}
inline void TovTorgItem::set_packagetype(const char* value) {
  set_has_packagetype();
  if (packagetype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    packagetype_ = new ::std::string;
  }
  packagetype_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.TovTorgItem.PackageType)
}
inline void TovTorgItem::set_packagetype(const char* value, size_t size) {
  set_has_packagetype();
  if (packagetype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    packagetype_ = new ::std::string;
  }
  packagetype_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.TovTorgItem.PackageType)
}
inline ::std::string* TovTorgItem::mutable_packagetype() {
  set_has_packagetype();
  if (packagetype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    packagetype_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.TovTorgItem.PackageType)
  return packagetype_;
}
inline ::std::string* TovTorgItem::release_packagetype() {
  clear_has_packagetype();
  if (packagetype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = packagetype_;
    packagetype_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TovTorgItem::set_allocated_packagetype(::std::string* packagetype) {
  if (packagetype_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete packagetype_;
  }
  if (packagetype) {
    set_has_packagetype();
    packagetype_ = packagetype;
  } else {
    clear_has_packagetype();
    packagetype_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.TovTorgItem.PackageType)
}

// optional string QuantityInPack = 9;
inline bool TovTorgItem::has_quantityinpack() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TovTorgItem::set_has_quantityinpack() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TovTorgItem::clear_has_quantityinpack() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TovTorgItem::clear_quantityinpack() {
  if (quantityinpack_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    quantityinpack_->clear();
  }
  clear_has_quantityinpack();
}
inline const ::std::string& TovTorgItem::quantityinpack() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.TovTorgItem.QuantityInPack)
  return *quantityinpack_;
}
inline void TovTorgItem::set_quantityinpack(const ::std::string& value) {
  set_has_quantityinpack();
  if (quantityinpack_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    quantityinpack_ = new ::std::string;
  }
  quantityinpack_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.TovTorgItem.QuantityInPack)
}
inline void TovTorgItem::set_quantityinpack(const char* value) {
  set_has_quantityinpack();
  if (quantityinpack_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    quantityinpack_ = new ::std::string;
  }
  quantityinpack_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.TovTorgItem.QuantityInPack)
}
inline void TovTorgItem::set_quantityinpack(const char* value, size_t size) {
  set_has_quantityinpack();
  if (quantityinpack_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    quantityinpack_ = new ::std::string;
  }
  quantityinpack_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.TovTorgItem.QuantityInPack)
}
inline ::std::string* TovTorgItem::mutable_quantityinpack() {
  set_has_quantityinpack();
  if (quantityinpack_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    quantityinpack_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.TovTorgItem.QuantityInPack)
  return quantityinpack_;
}
inline ::std::string* TovTorgItem::release_quantityinpack() {
  clear_has_quantityinpack();
  if (quantityinpack_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = quantityinpack_;
    quantityinpack_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TovTorgItem::set_allocated_quantityinpack(::std::string* quantityinpack) {
  if (quantityinpack_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete quantityinpack_;
  }
  if (quantityinpack) {
    set_has_quantityinpack();
    quantityinpack_ = quantityinpack;
  } else {
    clear_has_quantityinpack();
    quantityinpack_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.TovTorgItem.QuantityInPack)
}

// optional string Quantity = 10;
inline bool TovTorgItem::has_quantity() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TovTorgItem::set_has_quantity() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TovTorgItem::clear_has_quantity() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TovTorgItem::clear_quantity() {
  if (quantity_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    quantity_->clear();
  }
  clear_has_quantity();
}
inline const ::std::string& TovTorgItem::quantity() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.TovTorgItem.Quantity)
  return *quantity_;
}
inline void TovTorgItem::set_quantity(const ::std::string& value) {
  set_has_quantity();
  if (quantity_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    quantity_ = new ::std::string;
  }
  quantity_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.TovTorgItem.Quantity)
}
inline void TovTorgItem::set_quantity(const char* value) {
  set_has_quantity();
  if (quantity_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    quantity_ = new ::std::string;
  }
  quantity_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.TovTorgItem.Quantity)
}
inline void TovTorgItem::set_quantity(const char* value, size_t size) {
  set_has_quantity();
  if (quantity_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    quantity_ = new ::std::string;
  }
  quantity_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.TovTorgItem.Quantity)
}
inline ::std::string* TovTorgItem::mutable_quantity() {
  set_has_quantity();
  if (quantity_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    quantity_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.TovTorgItem.Quantity)
  return quantity_;
}
inline ::std::string* TovTorgItem::release_quantity() {
  clear_has_quantity();
  if (quantity_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = quantity_;
    quantity_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TovTorgItem::set_allocated_quantity(::std::string* quantity) {
  if (quantity_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete quantity_;
  }
  if (quantity) {
    set_has_quantity();
    quantity_ = quantity;
  } else {
    clear_has_quantity();
    quantity_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.TovTorgItem.Quantity)
}

// optional string Gross = 11;
inline bool TovTorgItem::has_gross() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void TovTorgItem::set_has_gross() {
  _has_bits_[0] |= 0x00000400u;
}
inline void TovTorgItem::clear_has_gross() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void TovTorgItem::clear_gross() {
  if (gross_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    gross_->clear();
  }
  clear_has_gross();
}
inline const ::std::string& TovTorgItem::gross() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.TovTorgItem.Gross)
  return *gross_;
}
inline void TovTorgItem::set_gross(const ::std::string& value) {
  set_has_gross();
  if (gross_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    gross_ = new ::std::string;
  }
  gross_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.TovTorgItem.Gross)
}
inline void TovTorgItem::set_gross(const char* value) {
  set_has_gross();
  if (gross_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    gross_ = new ::std::string;
  }
  gross_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.TovTorgItem.Gross)
}
inline void TovTorgItem::set_gross(const char* value, size_t size) {
  set_has_gross();
  if (gross_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    gross_ = new ::std::string;
  }
  gross_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.TovTorgItem.Gross)
}
inline ::std::string* TovTorgItem::mutable_gross() {
  set_has_gross();
  if (gross_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    gross_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.TovTorgItem.Gross)
  return gross_;
}
inline ::std::string* TovTorgItem::release_gross() {
  clear_has_gross();
  if (gross_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = gross_;
    gross_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TovTorgItem::set_allocated_gross(::std::string* gross) {
  if (gross_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete gross_;
  }
  if (gross) {
    set_has_gross();
    gross_ = gross;
  } else {
    clear_has_gross();
    gross_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.TovTorgItem.Gross)
}

// required string Net = 12;
inline bool TovTorgItem::has_net() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void TovTorgItem::set_has_net() {
  _has_bits_[0] |= 0x00000800u;
}
inline void TovTorgItem::clear_has_net() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void TovTorgItem::clear_net() {
  if (net_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    net_->clear();
  }
  clear_has_net();
}
inline const ::std::string& TovTorgItem::net() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.TovTorgItem.Net)
  return *net_;
}
inline void TovTorgItem::set_net(const ::std::string& value) {
  set_has_net();
  if (net_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    net_ = new ::std::string;
  }
  net_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.TovTorgItem.Net)
}
inline void TovTorgItem::set_net(const char* value) {
  set_has_net();
  if (net_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    net_ = new ::std::string;
  }
  net_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.TovTorgItem.Net)
}
inline void TovTorgItem::set_net(const char* value, size_t size) {
  set_has_net();
  if (net_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    net_ = new ::std::string;
  }
  net_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.TovTorgItem.Net)
}
inline ::std::string* TovTorgItem::mutable_net() {
  set_has_net();
  if (net_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    net_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.TovTorgItem.Net)
  return net_;
}
inline ::std::string* TovTorgItem::release_net() {
  clear_has_net();
  if (net_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = net_;
    net_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TovTorgItem::set_allocated_net(::std::string* net) {
  if (net_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete net_;
  }
  if (net) {
    set_has_net();
    net_ = net;
  } else {
    clear_has_net();
    net_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.TovTorgItem.Net)
}

// optional string ItemToRelease = 13;
inline bool TovTorgItem::has_itemtorelease() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void TovTorgItem::set_has_itemtorelease() {
  _has_bits_[0] |= 0x00001000u;
}
inline void TovTorgItem::clear_has_itemtorelease() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void TovTorgItem::clear_itemtorelease() {
  if (itemtorelease_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    itemtorelease_->clear();
  }
  clear_has_itemtorelease();
}
inline const ::std::string& TovTorgItem::itemtorelease() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.TovTorgItem.ItemToRelease)
  return *itemtorelease_;
}
inline void TovTorgItem::set_itemtorelease(const ::std::string& value) {
  set_has_itemtorelease();
  if (itemtorelease_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    itemtorelease_ = new ::std::string;
  }
  itemtorelease_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.TovTorgItem.ItemToRelease)
}
inline void TovTorgItem::set_itemtorelease(const char* value) {
  set_has_itemtorelease();
  if (itemtorelease_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    itemtorelease_ = new ::std::string;
  }
  itemtorelease_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.TovTorgItem.ItemToRelease)
}
inline void TovTorgItem::set_itemtorelease(const char* value, size_t size) {
  set_has_itemtorelease();
  if (itemtorelease_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    itemtorelease_ = new ::std::string;
  }
  itemtorelease_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.TovTorgItem.ItemToRelease)
}
inline ::std::string* TovTorgItem::mutable_itemtorelease() {
  set_has_itemtorelease();
  if (itemtorelease_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    itemtorelease_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.TovTorgItem.ItemToRelease)
  return itemtorelease_;
}
inline ::std::string* TovTorgItem::release_itemtorelease() {
  clear_has_itemtorelease();
  if (itemtorelease_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = itemtorelease_;
    itemtorelease_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TovTorgItem::set_allocated_itemtorelease(::std::string* itemtorelease) {
  if (itemtorelease_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete itemtorelease_;
  }
  if (itemtorelease) {
    set_has_itemtorelease();
    itemtorelease_ = itemtorelease;
  } else {
    clear_has_itemtorelease();
    itemtorelease_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.TovTorgItem.ItemToRelease)
}

// optional string Price = 14;
inline bool TovTorgItem::has_price() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void TovTorgItem::set_has_price() {
  _has_bits_[0] |= 0x00002000u;
}
inline void TovTorgItem::clear_has_price() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void TovTorgItem::clear_price() {
  if (price_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    price_->clear();
  }
  clear_has_price();
}
inline const ::std::string& TovTorgItem::price() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.TovTorgItem.Price)
  return *price_;
}
inline void TovTorgItem::set_price(const ::std::string& value) {
  set_has_price();
  if (price_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    price_ = new ::std::string;
  }
  price_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.TovTorgItem.Price)
}
inline void TovTorgItem::set_price(const char* value) {
  set_has_price();
  if (price_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    price_ = new ::std::string;
  }
  price_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.TovTorgItem.Price)
}
inline void TovTorgItem::set_price(const char* value, size_t size) {
  set_has_price();
  if (price_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    price_ = new ::std::string;
  }
  price_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.TovTorgItem.Price)
}
inline ::std::string* TovTorgItem::mutable_price() {
  set_has_price();
  if (price_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    price_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.TovTorgItem.Price)
  return price_;
}
inline ::std::string* TovTorgItem::release_price() {
  clear_has_price();
  if (price_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = price_;
    price_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TovTorgItem::set_allocated_price(::std::string* price) {
  if (price_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete price_;
  }
  if (price) {
    set_has_price();
    price_ = price;
  } else {
    clear_has_price();
    price_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.TovTorgItem.Price)
}

// optional string SubtotalWithVatExcluded = 15;
inline bool TovTorgItem::has_subtotalwithvatexcluded() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void TovTorgItem::set_has_subtotalwithvatexcluded() {
  _has_bits_[0] |= 0x00004000u;
}
inline void TovTorgItem::clear_has_subtotalwithvatexcluded() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void TovTorgItem::clear_subtotalwithvatexcluded() {
  if (subtotalwithvatexcluded_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    subtotalwithvatexcluded_->clear();
  }
  clear_has_subtotalwithvatexcluded();
}
inline const ::std::string& TovTorgItem::subtotalwithvatexcluded() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.TovTorgItem.SubtotalWithVatExcluded)
  return *subtotalwithvatexcluded_;
}
inline void TovTorgItem::set_subtotalwithvatexcluded(const ::std::string& value) {
  set_has_subtotalwithvatexcluded();
  if (subtotalwithvatexcluded_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    subtotalwithvatexcluded_ = new ::std::string;
  }
  subtotalwithvatexcluded_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.TovTorgItem.SubtotalWithVatExcluded)
}
inline void TovTorgItem::set_subtotalwithvatexcluded(const char* value) {
  set_has_subtotalwithvatexcluded();
  if (subtotalwithvatexcluded_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    subtotalwithvatexcluded_ = new ::std::string;
  }
  subtotalwithvatexcluded_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.TovTorgItem.SubtotalWithVatExcluded)
}
inline void TovTorgItem::set_subtotalwithvatexcluded(const char* value, size_t size) {
  set_has_subtotalwithvatexcluded();
  if (subtotalwithvatexcluded_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    subtotalwithvatexcluded_ = new ::std::string;
  }
  subtotalwithvatexcluded_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.TovTorgItem.SubtotalWithVatExcluded)
}
inline ::std::string* TovTorgItem::mutable_subtotalwithvatexcluded() {
  set_has_subtotalwithvatexcluded();
  if (subtotalwithvatexcluded_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    subtotalwithvatexcluded_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.TovTorgItem.SubtotalWithVatExcluded)
  return subtotalwithvatexcluded_;
}
inline ::std::string* TovTorgItem::release_subtotalwithvatexcluded() {
  clear_has_subtotalwithvatexcluded();
  if (subtotalwithvatexcluded_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = subtotalwithvatexcluded_;
    subtotalwithvatexcluded_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TovTorgItem::set_allocated_subtotalwithvatexcluded(::std::string* subtotalwithvatexcluded) {
  if (subtotalwithvatexcluded_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete subtotalwithvatexcluded_;
  }
  if (subtotalwithvatexcluded) {
    set_has_subtotalwithvatexcluded();
    subtotalwithvatexcluded_ = subtotalwithvatexcluded;
  } else {
    clear_has_subtotalwithvatexcluded();
    subtotalwithvatexcluded_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.TovTorgItem.SubtotalWithVatExcluded)
}

// optional .Diadoc.Api.Proto.Invoicing.TaxRate TaxRate = 16 [default = Percent_18];
inline bool TovTorgItem::has_taxrate() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void TovTorgItem::set_has_taxrate() {
  _has_bits_[0] |= 0x00008000u;
}
inline void TovTorgItem::clear_has_taxrate() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void TovTorgItem::clear_taxrate() {
  taxrate_ = 3;
  clear_has_taxrate();
}
inline ::Diadoc::Api::Proto::Invoicing::TaxRate TovTorgItem::taxrate() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.TovTorgItem.TaxRate)
  return static_cast< ::Diadoc::Api::Proto::Invoicing::TaxRate >(taxrate_);
}
inline void TovTorgItem::set_taxrate(::Diadoc::Api::Proto::Invoicing::TaxRate value) {
  assert(::Diadoc::Api::Proto::Invoicing::TaxRate_IsValid(value));
  set_has_taxrate();
  taxrate_ = value;
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.TovTorgItem.TaxRate)
}

// optional string Vat = 17;
inline bool TovTorgItem::has_vat() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void TovTorgItem::set_has_vat() {
  _has_bits_[0] |= 0x00010000u;
}
inline void TovTorgItem::clear_has_vat() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void TovTorgItem::clear_vat() {
  if (vat_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vat_->clear();
  }
  clear_has_vat();
}
inline const ::std::string& TovTorgItem::vat() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.TovTorgItem.Vat)
  return *vat_;
}
inline void TovTorgItem::set_vat(const ::std::string& value) {
  set_has_vat();
  if (vat_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vat_ = new ::std::string;
  }
  vat_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.TovTorgItem.Vat)
}
inline void TovTorgItem::set_vat(const char* value) {
  set_has_vat();
  if (vat_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vat_ = new ::std::string;
  }
  vat_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.TovTorgItem.Vat)
}
inline void TovTorgItem::set_vat(const char* value, size_t size) {
  set_has_vat();
  if (vat_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vat_ = new ::std::string;
  }
  vat_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.TovTorgItem.Vat)
}
inline ::std::string* TovTorgItem::mutable_vat() {
  set_has_vat();
  if (vat_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vat_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.TovTorgItem.Vat)
  return vat_;
}
inline ::std::string* TovTorgItem::release_vat() {
  clear_has_vat();
  if (vat_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = vat_;
    vat_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TovTorgItem::set_allocated_vat(::std::string* vat) {
  if (vat_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete vat_;
  }
  if (vat) {
    set_has_vat();
    vat_ = vat;
  } else {
    clear_has_vat();
    vat_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.TovTorgItem.Vat)
}

// required string Subtotal = 18;
inline bool TovTorgItem::has_subtotal() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void TovTorgItem::set_has_subtotal() {
  _has_bits_[0] |= 0x00020000u;
}
inline void TovTorgItem::clear_has_subtotal() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void TovTorgItem::clear_subtotal() {
  if (subtotal_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    subtotal_->clear();
  }
  clear_has_subtotal();
}
inline const ::std::string& TovTorgItem::subtotal() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.TovTorgItem.Subtotal)
  return *subtotal_;
}
inline void TovTorgItem::set_subtotal(const ::std::string& value) {
  set_has_subtotal();
  if (subtotal_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    subtotal_ = new ::std::string;
  }
  subtotal_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.TovTorgItem.Subtotal)
}
inline void TovTorgItem::set_subtotal(const char* value) {
  set_has_subtotal();
  if (subtotal_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    subtotal_ = new ::std::string;
  }
  subtotal_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.TovTorgItem.Subtotal)
}
inline void TovTorgItem::set_subtotal(const char* value, size_t size) {
  set_has_subtotal();
  if (subtotal_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    subtotal_ = new ::std::string;
  }
  subtotal_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.TovTorgItem.Subtotal)
}
inline ::std::string* TovTorgItem::mutable_subtotal() {
  set_has_subtotal();
  if (subtotal_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    subtotal_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.TovTorgItem.Subtotal)
  return subtotal_;
}
inline ::std::string* TovTorgItem::release_subtotal() {
  clear_has_subtotal();
  if (subtotal_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = subtotal_;
    subtotal_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TovTorgItem::set_allocated_subtotal(::std::string* subtotal) {
  if (subtotal_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete subtotal_;
  }
  if (subtotal) {
    set_has_subtotal();
    subtotal_ = subtotal;
  } else {
    clear_has_subtotal();
    subtotal_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.TovTorgItem.Subtotal)
}

// optional string ItemAccountDebit = 19;
inline bool TovTorgItem::has_itemaccountdebit() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void TovTorgItem::set_has_itemaccountdebit() {
  _has_bits_[0] |= 0x00040000u;
}
inline void TovTorgItem::clear_has_itemaccountdebit() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void TovTorgItem::clear_itemaccountdebit() {
  if (itemaccountdebit_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    itemaccountdebit_->clear();
  }
  clear_has_itemaccountdebit();
}
inline const ::std::string& TovTorgItem::itemaccountdebit() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.TovTorgItem.ItemAccountDebit)
  return *itemaccountdebit_;
}
inline void TovTorgItem::set_itemaccountdebit(const ::std::string& value) {
  set_has_itemaccountdebit();
  if (itemaccountdebit_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    itemaccountdebit_ = new ::std::string;
  }
  itemaccountdebit_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.TovTorgItem.ItemAccountDebit)
}
inline void TovTorgItem::set_itemaccountdebit(const char* value) {
  set_has_itemaccountdebit();
  if (itemaccountdebit_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    itemaccountdebit_ = new ::std::string;
  }
  itemaccountdebit_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.TovTorgItem.ItemAccountDebit)
}
inline void TovTorgItem::set_itemaccountdebit(const char* value, size_t size) {
  set_has_itemaccountdebit();
  if (itemaccountdebit_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    itemaccountdebit_ = new ::std::string;
  }
  itemaccountdebit_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.TovTorgItem.ItemAccountDebit)
}
inline ::std::string* TovTorgItem::mutable_itemaccountdebit() {
  set_has_itemaccountdebit();
  if (itemaccountdebit_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    itemaccountdebit_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.TovTorgItem.ItemAccountDebit)
  return itemaccountdebit_;
}
inline ::std::string* TovTorgItem::release_itemaccountdebit() {
  clear_has_itemaccountdebit();
  if (itemaccountdebit_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = itemaccountdebit_;
    itemaccountdebit_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TovTorgItem::set_allocated_itemaccountdebit(::std::string* itemaccountdebit) {
  if (itemaccountdebit_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete itemaccountdebit_;
  }
  if (itemaccountdebit) {
    set_has_itemaccountdebit();
    itemaccountdebit_ = itemaccountdebit;
  } else {
    clear_has_itemaccountdebit();
    itemaccountdebit_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.TovTorgItem.ItemAccountDebit)
}

// optional string ItemAccountCredit = 20;
inline bool TovTorgItem::has_itemaccountcredit() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void TovTorgItem::set_has_itemaccountcredit() {
  _has_bits_[0] |= 0x00080000u;
}
inline void TovTorgItem::clear_has_itemaccountcredit() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void TovTorgItem::clear_itemaccountcredit() {
  if (itemaccountcredit_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    itemaccountcredit_->clear();
  }
  clear_has_itemaccountcredit();
}
inline const ::std::string& TovTorgItem::itemaccountcredit() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.TovTorgItem.ItemAccountCredit)
  return *itemaccountcredit_;
}
inline void TovTorgItem::set_itemaccountcredit(const ::std::string& value) {
  set_has_itemaccountcredit();
  if (itemaccountcredit_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    itemaccountcredit_ = new ::std::string;
  }
  itemaccountcredit_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.TovTorgItem.ItemAccountCredit)
}
inline void TovTorgItem::set_itemaccountcredit(const char* value) {
  set_has_itemaccountcredit();
  if (itemaccountcredit_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    itemaccountcredit_ = new ::std::string;
  }
  itemaccountcredit_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.TovTorgItem.ItemAccountCredit)
}
inline void TovTorgItem::set_itemaccountcredit(const char* value, size_t size) {
  set_has_itemaccountcredit();
  if (itemaccountcredit_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    itemaccountcredit_ = new ::std::string;
  }
  itemaccountcredit_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.TovTorgItem.ItemAccountCredit)
}
inline ::std::string* TovTorgItem::mutable_itemaccountcredit() {
  set_has_itemaccountcredit();
  if (itemaccountcredit_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    itemaccountcredit_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.TovTorgItem.ItemAccountCredit)
  return itemaccountcredit_;
}
inline ::std::string* TovTorgItem::release_itemaccountcredit() {
  clear_has_itemaccountcredit();
  if (itemaccountcredit_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = itemaccountcredit_;
    itemaccountcredit_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TovTorgItem::set_allocated_itemaccountcredit(::std::string* itemaccountcredit) {
  if (itemaccountcredit_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete itemaccountcredit_;
  }
  if (itemaccountcredit) {
    set_has_itemaccountcredit();
    itemaccountcredit_ = itemaccountcredit;
  } else {
    clear_has_itemaccountcredit();
    itemaccountcredit_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.TovTorgItem.ItemAccountCredit)
}

// repeated .Diadoc.Api.Proto.Invoicing.AdditionalInfo AdditionalInfos = 21;
inline int TovTorgItem::additionalinfos_size() const {
  return additionalinfos_.size();
}
inline void TovTorgItem::clear_additionalinfos() {
  additionalinfos_.Clear();
}
inline const ::Diadoc::Api::Proto::Invoicing::AdditionalInfo& TovTorgItem::additionalinfos(int index) const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.TovTorgItem.AdditionalInfos)
  return additionalinfos_.Get(index);
}
inline ::Diadoc::Api::Proto::Invoicing::AdditionalInfo* TovTorgItem::mutable_additionalinfos(int index) {
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.TovTorgItem.AdditionalInfos)
  return additionalinfos_.Mutable(index);
}
inline ::Diadoc::Api::Proto::Invoicing::AdditionalInfo* TovTorgItem::add_additionalinfos() {
  // @@protoc_insertion_point(field_add:Diadoc.Api.Proto.Invoicing.TovTorgItem.AdditionalInfos)
  return additionalinfos_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::AdditionalInfo >&
TovTorgItem::additionalinfos() const {
  // @@protoc_insertion_point(field_list:Diadoc.Api.Proto.Invoicing.TovTorgItem.AdditionalInfos)
  return additionalinfos_;
}
inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::AdditionalInfo >*
TovTorgItem::mutable_additionalinfos() {
  // @@protoc_insertion_point(field_mutable_list:Diadoc.Api.Proto.Invoicing.TovTorgItem.AdditionalInfos)
  return &additionalinfos_;
}

// -------------------------------------------------------------------

// TovTorgTransferInfo

// required string OperationInfo = 1;
inline bool TovTorgTransferInfo::has_operationinfo() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TovTorgTransferInfo::set_has_operationinfo() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TovTorgTransferInfo::clear_has_operationinfo() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TovTorgTransferInfo::clear_operationinfo() {
  if (operationinfo_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    operationinfo_->clear();
  }
  clear_has_operationinfo();
}
inline const ::std::string& TovTorgTransferInfo::operationinfo() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.TovTorgTransferInfo.OperationInfo)
  return *operationinfo_;
}
inline void TovTorgTransferInfo::set_operationinfo(const ::std::string& value) {
  set_has_operationinfo();
  if (operationinfo_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    operationinfo_ = new ::std::string;
  }
  operationinfo_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.TovTorgTransferInfo.OperationInfo)
}
inline void TovTorgTransferInfo::set_operationinfo(const char* value) {
  set_has_operationinfo();
  if (operationinfo_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    operationinfo_ = new ::std::string;
  }
  operationinfo_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.TovTorgTransferInfo.OperationInfo)
}
inline void TovTorgTransferInfo::set_operationinfo(const char* value, size_t size) {
  set_has_operationinfo();
  if (operationinfo_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    operationinfo_ = new ::std::string;
  }
  operationinfo_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.TovTorgTransferInfo.OperationInfo)
}
inline ::std::string* TovTorgTransferInfo::mutable_operationinfo() {
  set_has_operationinfo();
  if (operationinfo_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    operationinfo_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.TovTorgTransferInfo.OperationInfo)
  return operationinfo_;
}
inline ::std::string* TovTorgTransferInfo::release_operationinfo() {
  clear_has_operationinfo();
  if (operationinfo_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = operationinfo_;
    operationinfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TovTorgTransferInfo::set_allocated_operationinfo(::std::string* operationinfo) {
  if (operationinfo_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete operationinfo_;
  }
  if (operationinfo) {
    set_has_operationinfo();
    operationinfo_ = operationinfo;
  } else {
    clear_has_operationinfo();
    operationinfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.TovTorgTransferInfo.OperationInfo)
}

// optional string TransferDate = 2;
inline bool TovTorgTransferInfo::has_transferdate() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TovTorgTransferInfo::set_has_transferdate() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TovTorgTransferInfo::clear_has_transferdate() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TovTorgTransferInfo::clear_transferdate() {
  if (transferdate_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    transferdate_->clear();
  }
  clear_has_transferdate();
}
inline const ::std::string& TovTorgTransferInfo::transferdate() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.TovTorgTransferInfo.TransferDate)
  return *transferdate_;
}
inline void TovTorgTransferInfo::set_transferdate(const ::std::string& value) {
  set_has_transferdate();
  if (transferdate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    transferdate_ = new ::std::string;
  }
  transferdate_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.TovTorgTransferInfo.TransferDate)
}
inline void TovTorgTransferInfo::set_transferdate(const char* value) {
  set_has_transferdate();
  if (transferdate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    transferdate_ = new ::std::string;
  }
  transferdate_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.TovTorgTransferInfo.TransferDate)
}
inline void TovTorgTransferInfo::set_transferdate(const char* value, size_t size) {
  set_has_transferdate();
  if (transferdate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    transferdate_ = new ::std::string;
  }
  transferdate_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.TovTorgTransferInfo.TransferDate)
}
inline ::std::string* TovTorgTransferInfo::mutable_transferdate() {
  set_has_transferdate();
  if (transferdate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    transferdate_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.TovTorgTransferInfo.TransferDate)
  return transferdate_;
}
inline ::std::string* TovTorgTransferInfo::release_transferdate() {
  clear_has_transferdate();
  if (transferdate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = transferdate_;
    transferdate_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TovTorgTransferInfo::set_allocated_transferdate(::std::string* transferdate) {
  if (transferdate_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete transferdate_;
  }
  if (transferdate) {
    set_has_transferdate();
    transferdate_ = transferdate;
  } else {
    clear_has_transferdate();
    transferdate_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.TovTorgTransferInfo.TransferDate)
}

// optional string Attachment = 3;
inline bool TovTorgTransferInfo::has_attachment() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TovTorgTransferInfo::set_has_attachment() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TovTorgTransferInfo::clear_has_attachment() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TovTorgTransferInfo::clear_attachment() {
  if (attachment_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attachment_->clear();
  }
  clear_has_attachment();
}
inline const ::std::string& TovTorgTransferInfo::attachment() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.TovTorgTransferInfo.Attachment)
  return *attachment_;
}
inline void TovTorgTransferInfo::set_attachment(const ::std::string& value) {
  set_has_attachment();
  if (attachment_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attachment_ = new ::std::string;
  }
  attachment_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.TovTorgTransferInfo.Attachment)
}
inline void TovTorgTransferInfo::set_attachment(const char* value) {
  set_has_attachment();
  if (attachment_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attachment_ = new ::std::string;
  }
  attachment_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.TovTorgTransferInfo.Attachment)
}
inline void TovTorgTransferInfo::set_attachment(const char* value, size_t size) {
  set_has_attachment();
  if (attachment_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attachment_ = new ::std::string;
  }
  attachment_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.TovTorgTransferInfo.Attachment)
}
inline ::std::string* TovTorgTransferInfo::mutable_attachment() {
  set_has_attachment();
  if (attachment_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attachment_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.TovTorgTransferInfo.Attachment)
  return attachment_;
}
inline ::std::string* TovTorgTransferInfo::release_attachment() {
  clear_has_attachment();
  if (attachment_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attachment_;
    attachment_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TovTorgTransferInfo::set_allocated_attachment(::std::string* attachment) {
  if (attachment_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attachment_;
  }
  if (attachment) {
    set_has_attachment();
    attachment_ = attachment;
  } else {
    clear_has_attachment();
    attachment_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.TovTorgTransferInfo.Attachment)
}

// repeated .Diadoc.Api.Proto.Invoicing.Waybill Waybills = 4;
inline int TovTorgTransferInfo::waybills_size() const {
  return waybills_.size();
}
inline void TovTorgTransferInfo::clear_waybills() {
  waybills_.Clear();
}
inline const ::Diadoc::Api::Proto::Invoicing::Waybill& TovTorgTransferInfo::waybills(int index) const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.TovTorgTransferInfo.Waybills)
  return waybills_.Get(index);
}
inline ::Diadoc::Api::Proto::Invoicing::Waybill* TovTorgTransferInfo::mutable_waybills(int index) {
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.TovTorgTransferInfo.Waybills)
  return waybills_.Mutable(index);
}
inline ::Diadoc::Api::Proto::Invoicing::Waybill* TovTorgTransferInfo::add_waybills() {
  // @@protoc_insertion_point(field_add:Diadoc.Api.Proto.Invoicing.TovTorgTransferInfo.Waybills)
  return waybills_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::Waybill >&
TovTorgTransferInfo::waybills() const {
  // @@protoc_insertion_point(field_list:Diadoc.Api.Proto.Invoicing.TovTorgTransferInfo.Waybills)
  return waybills_;
}
inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::Waybill >*
TovTorgTransferInfo::mutable_waybills() {
  // @@protoc_insertion_point(field_mutable_list:Diadoc.Api.Proto.Invoicing.TovTorgTransferInfo.Waybills)
  return &waybills_;
}

// optional .Diadoc.Api.Proto.Invoicing.Employee Employee = 5;
inline bool TovTorgTransferInfo::has_employee() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TovTorgTransferInfo::set_has_employee() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TovTorgTransferInfo::clear_has_employee() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TovTorgTransferInfo::clear_employee() {
  if (employee_ != NULL) employee_->::Diadoc::Api::Proto::Invoicing::Employee::Clear();
  clear_has_employee();
}
inline const ::Diadoc::Api::Proto::Invoicing::Employee& TovTorgTransferInfo::employee() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.TovTorgTransferInfo.Employee)
  return employee_ != NULL ? *employee_ : *default_instance_->employee_;
}
inline ::Diadoc::Api::Proto::Invoicing::Employee* TovTorgTransferInfo::mutable_employee() {
  set_has_employee();
  if (employee_ == NULL) employee_ = new ::Diadoc::Api::Proto::Invoicing::Employee;
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.TovTorgTransferInfo.Employee)
  return employee_;
}
inline ::Diadoc::Api::Proto::Invoicing::Employee* TovTorgTransferInfo::release_employee() {
  clear_has_employee();
  ::Diadoc::Api::Proto::Invoicing::Employee* temp = employee_;
  employee_ = NULL;
  return temp;
}
inline void TovTorgTransferInfo::set_allocated_employee(::Diadoc::Api::Proto::Invoicing::Employee* employee) {
  delete employee_;
  employee_ = employee;
  if (employee) {
    set_has_employee();
  } else {
    clear_has_employee();
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.TovTorgTransferInfo.Employee)
}

// optional .Diadoc.Api.Proto.Invoicing.OtherIssuer OtherIssuer = 6;
inline bool TovTorgTransferInfo::has_otherissuer() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TovTorgTransferInfo::set_has_otherissuer() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TovTorgTransferInfo::clear_has_otherissuer() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TovTorgTransferInfo::clear_otherissuer() {
  if (otherissuer_ != NULL) otherissuer_->::Diadoc::Api::Proto::Invoicing::OtherIssuer::Clear();
  clear_has_otherissuer();
}
inline const ::Diadoc::Api::Proto::Invoicing::OtherIssuer& TovTorgTransferInfo::otherissuer() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.TovTorgTransferInfo.OtherIssuer)
  return otherissuer_ != NULL ? *otherissuer_ : *default_instance_->otherissuer_;
}
inline ::Diadoc::Api::Proto::Invoicing::OtherIssuer* TovTorgTransferInfo::mutable_otherissuer() {
  set_has_otherissuer();
  if (otherissuer_ == NULL) otherissuer_ = new ::Diadoc::Api::Proto::Invoicing::OtherIssuer;
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.TovTorgTransferInfo.OtherIssuer)
  return otherissuer_;
}
inline ::Diadoc::Api::Proto::Invoicing::OtherIssuer* TovTorgTransferInfo::release_otherissuer() {
  clear_has_otherissuer();
  ::Diadoc::Api::Proto::Invoicing::OtherIssuer* temp = otherissuer_;
  otherissuer_ = NULL;
  return temp;
}
inline void TovTorgTransferInfo::set_allocated_otherissuer(::Diadoc::Api::Proto::Invoicing::OtherIssuer* otherissuer) {
  delete otherissuer_;
  otherissuer_ = otherissuer;
  if (otherissuer) {
    set_has_otherissuer();
  } else {
    clear_has_otherissuer();
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.TovTorgTransferInfo.OtherIssuer)
}

// repeated .Diadoc.Api.Proto.Invoicing.AdditionalInfo AdditionalInfos = 7;
inline int TovTorgTransferInfo::additionalinfos_size() const {
  return additionalinfos_.size();
}
inline void TovTorgTransferInfo::clear_additionalinfos() {
  additionalinfos_.Clear();
}
inline const ::Diadoc::Api::Proto::Invoicing::AdditionalInfo& TovTorgTransferInfo::additionalinfos(int index) const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.TovTorgTransferInfo.AdditionalInfos)
  return additionalinfos_.Get(index);
}
inline ::Diadoc::Api::Proto::Invoicing::AdditionalInfo* TovTorgTransferInfo::mutable_additionalinfos(int index) {
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.TovTorgTransferInfo.AdditionalInfos)
  return additionalinfos_.Mutable(index);
}
inline ::Diadoc::Api::Proto::Invoicing::AdditionalInfo* TovTorgTransferInfo::add_additionalinfos() {
  // @@protoc_insertion_point(field_add:Diadoc.Api.Proto.Invoicing.TovTorgTransferInfo.AdditionalInfos)
  return additionalinfos_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::AdditionalInfo >&
TovTorgTransferInfo::additionalinfos() const {
  // @@protoc_insertion_point(field_list:Diadoc.Api.Proto.Invoicing.TovTorgTransferInfo.AdditionalInfos)
  return additionalinfos_;
}
inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::AdditionalInfo >*
TovTorgTransferInfo::mutable_additionalinfos() {
  // @@protoc_insertion_point(field_mutable_list:Diadoc.Api.Proto.Invoicing.TovTorgTransferInfo.AdditionalInfos)
  return &additionalinfos_;
}

// -------------------------------------------------------------------

// GroundInfo

// required string Name = 1;
inline bool GroundInfo::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroundInfo::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroundInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroundInfo::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& GroundInfo::name() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.GroundInfo.Name)
  return *name_;
}
inline void GroundInfo::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.GroundInfo.Name)
}
inline void GroundInfo::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.GroundInfo.Name)
}
inline void GroundInfo::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.GroundInfo.Name)
}
inline ::std::string* GroundInfo::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.GroundInfo.Name)
  return name_;
}
inline ::std::string* GroundInfo::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GroundInfo::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.GroundInfo.Name)
}

// optional string Number = 2;
inline bool GroundInfo::has_number() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GroundInfo::set_has_number() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GroundInfo::clear_has_number() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GroundInfo::clear_number() {
  if (number_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    number_->clear();
  }
  clear_has_number();
}
inline const ::std::string& GroundInfo::number() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.GroundInfo.Number)
  return *number_;
}
inline void GroundInfo::set_number(const ::std::string& value) {
  set_has_number();
  if (number_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    number_ = new ::std::string;
  }
  number_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.GroundInfo.Number)
}
inline void GroundInfo::set_number(const char* value) {
  set_has_number();
  if (number_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    number_ = new ::std::string;
  }
  number_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.GroundInfo.Number)
}
inline void GroundInfo::set_number(const char* value, size_t size) {
  set_has_number();
  if (number_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    number_ = new ::std::string;
  }
  number_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.GroundInfo.Number)
}
inline ::std::string* GroundInfo::mutable_number() {
  set_has_number();
  if (number_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    number_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.GroundInfo.Number)
  return number_;
}
inline ::std::string* GroundInfo::release_number() {
  clear_has_number();
  if (number_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = number_;
    number_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GroundInfo::set_allocated_number(::std::string* number) {
  if (number_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete number_;
  }
  if (number) {
    set_has_number();
    number_ = number;
  } else {
    clear_has_number();
    number_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.GroundInfo.Number)
}

// optional string Date = 3;
inline bool GroundInfo::has_date() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GroundInfo::set_has_date() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GroundInfo::clear_has_date() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GroundInfo::clear_date() {
  if (date_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    date_->clear();
  }
  clear_has_date();
}
inline const ::std::string& GroundInfo::date() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.GroundInfo.Date)
  return *date_;
}
inline void GroundInfo::set_date(const ::std::string& value) {
  set_has_date();
  if (date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    date_ = new ::std::string;
  }
  date_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.GroundInfo.Date)
}
inline void GroundInfo::set_date(const char* value) {
  set_has_date();
  if (date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    date_ = new ::std::string;
  }
  date_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.GroundInfo.Date)
}
inline void GroundInfo::set_date(const char* value, size_t size) {
  set_has_date();
  if (date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    date_ = new ::std::string;
  }
  date_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.GroundInfo.Date)
}
inline ::std::string* GroundInfo::mutable_date() {
  set_has_date();
  if (date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    date_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.GroundInfo.Date)
  return date_;
}
inline ::std::string* GroundInfo::release_date() {
  clear_has_date();
  if (date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = date_;
    date_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GroundInfo::set_allocated_date(::std::string* date) {
  if (date_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete date_;
  }
  if (date) {
    set_has_date();
    date_ = date;
  } else {
    clear_has_date();
    date_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.GroundInfo.Date)
}

// optional string Info = 4;
inline bool GroundInfo::has_info() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GroundInfo::set_has_info() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GroundInfo::clear_has_info() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GroundInfo::clear_info() {
  if (info_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    info_->clear();
  }
  clear_has_info();
}
inline const ::std::string& GroundInfo::info() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.GroundInfo.Info)
  return *info_;
}
inline void GroundInfo::set_info(const ::std::string& value) {
  set_has_info();
  if (info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    info_ = new ::std::string;
  }
  info_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.GroundInfo.Info)
}
inline void GroundInfo::set_info(const char* value) {
  set_has_info();
  if (info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    info_ = new ::std::string;
  }
  info_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.GroundInfo.Info)
}
inline void GroundInfo::set_info(const char* value, size_t size) {
  set_has_info();
  if (info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    info_ = new ::std::string;
  }
  info_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.GroundInfo.Info)
}
inline ::std::string* GroundInfo::mutable_info() {
  set_has_info();
  if (info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    info_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.GroundInfo.Info)
  return info_;
}
inline ::std::string* GroundInfo::release_info() {
  clear_has_info();
  if (info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = info_;
    info_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GroundInfo::set_allocated_info(::std::string* info) {
  if (info_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete info_;
  }
  if (info) {
    set_has_info();
    info_ = info;
  } else {
    clear_has_info();
    info_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.GroundInfo.Info)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace Invoicing
}  // namespace Proto
}  // namespace Api
}  // namespace Diadoc

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_Invoicing_2fTovTorgInfo_2eproto__INCLUDED
