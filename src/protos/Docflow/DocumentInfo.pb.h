// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Docflow/DocumentInfo.proto

#ifndef PROTOBUF_Docflow_2fDocumentInfo_2eproto__INCLUDED
#define PROTOBUF_Docflow_2fDocumentInfo_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include "DocumentType.pb.h"
#include "DocumentDirection.pb.h"
#include "Invoicing/UniversalTransferDocumentInfo.pb.h"
// @@protoc_insertion_point(includes)

namespace Diadoc {
namespace Api {
namespace Proto {
namespace Docflow {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_Docflow_2fDocumentInfo_2eproto();
void protobuf_AssignDesc_Docflow_2fDocumentInfo_2eproto();
void protobuf_ShutdownFile_Docflow_2fDocumentInfo_2eproto();

class DocumentInfo;
class DocumentDateAndNumber;
class BasicDocumentInfo;
class InvoiceDocumentInfo;
class InvoiceCorrectionDocumentInfo;
class PriceListDocumentInfo;
class ContractDocumentInfo;
class SupplementaryAgreementDocumentInfo;
class UniversalTransferDocumentInfo;
class UniversalCorrectionDocumentInfo;

// ===================================================================

class DocumentInfo : public ::google::protobuf::Message {
 public:
  DocumentInfo();
  virtual ~DocumentInfo();

  DocumentInfo(const DocumentInfo& from);

  inline DocumentInfo& operator=(const DocumentInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DocumentInfo& default_instance();

  void Swap(DocumentInfo* other);

  // implements Message ----------------------------------------------

  DocumentInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DocumentInfo& from);
  void MergeFrom(const DocumentInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Diadoc.Api.Proto.DocumentType DocumentType = 1 [default = UnknownDocumentType];
  inline bool has_documenttype() const;
  inline void clear_documenttype();
  static const int kDocumentTypeFieldNumber = 1;
  inline ::Diadoc::Api::Proto::DocumentType documenttype() const;
  inline void set_documenttype(::Diadoc::Api::Proto::DocumentType value);

  // optional .Diadoc.Api.Proto.DocumentDirection DocumentDirection = 2 [default = UnknownDocumentDirection];
  inline bool has_documentdirection() const;
  inline void clear_documentdirection();
  static const int kDocumentDirectionFieldNumber = 2;
  inline ::Diadoc::Api::Proto::DocumentDirection documentdirection() const;
  inline void set_documentdirection(::Diadoc::Api::Proto::DocumentDirection value);

  // optional bool IsTest = 3;
  inline bool has_istest() const;
  inline void clear_istest();
  static const int kIsTestFieldNumber = 3;
  inline bool istest() const;
  inline void set_istest(bool value);

  // optional string CustomDocumentId = 4;
  inline bool has_customdocumentid() const;
  inline void clear_customdocumentid();
  static const int kCustomDocumentIdFieldNumber = 4;
  inline const ::std::string& customdocumentid() const;
  inline void set_customdocumentid(const ::std::string& value);
  inline void set_customdocumentid(const char* value);
  inline void set_customdocumentid(const char* value, size_t size);
  inline ::std::string* mutable_customdocumentid();
  inline ::std::string* release_customdocumentid();
  inline void set_allocated_customdocumentid(::std::string* customdocumentid);

  // optional string FromDepartmentId = 5;
  inline bool has_fromdepartmentid() const;
  inline void clear_fromdepartmentid();
  static const int kFromDepartmentIdFieldNumber = 5;
  inline const ::std::string& fromdepartmentid() const;
  inline void set_fromdepartmentid(const ::std::string& value);
  inline void set_fromdepartmentid(const char* value);
  inline void set_fromdepartmentid(const char* value, size_t size);
  inline ::std::string* mutable_fromdepartmentid();
  inline ::std::string* release_fromdepartmentid();
  inline void set_allocated_fromdepartmentid(::std::string* fromdepartmentid);

  // optional string ToDepartmentId = 6;
  inline bool has_todepartmentid() const;
  inline void clear_todepartmentid();
  static const int kToDepartmentIdFieldNumber = 6;
  inline const ::std::string& todepartmentid() const;
  inline void set_todepartmentid(const ::std::string& value);
  inline void set_todepartmentid(const char* value);
  inline void set_todepartmentid(const char* value, size_t size);
  inline ::std::string* mutable_todepartmentid();
  inline ::std::string* release_todepartmentid();
  inline void set_allocated_todepartmentid(::std::string* todepartmentid);

  // optional string CounteragentBoxId = 7;
  inline bool has_counteragentboxid() const;
  inline void clear_counteragentboxid();
  static const int kCounteragentBoxIdFieldNumber = 7;
  inline const ::std::string& counteragentboxid() const;
  inline void set_counteragentboxid(const ::std::string& value);
  inline void set_counteragentboxid(const char* value);
  inline void set_counteragentboxid(const char* value, size_t size);
  inline ::std::string* mutable_counteragentboxid();
  inline ::std::string* release_counteragentboxid();
  inline void set_allocated_counteragentboxid(::std::string* counteragentboxid);

  // optional .Diadoc.Api.Proto.Docflow.DocumentDateAndNumber DocumentDateAndNumber = 8;
  inline bool has_documentdateandnumber() const;
  inline void clear_documentdateandnumber();
  static const int kDocumentDateAndNumberFieldNumber = 8;
  inline const ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber& documentdateandnumber() const;
  inline ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber* mutable_documentdateandnumber();
  inline ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber* release_documentdateandnumber();
  inline void set_allocated_documentdateandnumber(::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber* documentdateandnumber);

  // optional .Diadoc.Api.Proto.Docflow.BasicDocumentInfo BasicDocumentInfo = 9;
  inline bool has_basicdocumentinfo() const;
  inline void clear_basicdocumentinfo();
  static const int kBasicDocumentInfoFieldNumber = 9;
  inline const ::Diadoc::Api::Proto::Docflow::BasicDocumentInfo& basicdocumentinfo() const;
  inline ::Diadoc::Api::Proto::Docflow::BasicDocumentInfo* mutable_basicdocumentinfo();
  inline ::Diadoc::Api::Proto::Docflow::BasicDocumentInfo* release_basicdocumentinfo();
  inline void set_allocated_basicdocumentinfo(::Diadoc::Api::Proto::Docflow::BasicDocumentInfo* basicdocumentinfo);

  // optional .Diadoc.Api.Proto.Docflow.InvoiceDocumentInfo InvoiceInfo = 10;
  inline bool has_invoiceinfo() const;
  inline void clear_invoiceinfo();
  static const int kInvoiceInfoFieldNumber = 10;
  inline const ::Diadoc::Api::Proto::Docflow::InvoiceDocumentInfo& invoiceinfo() const;
  inline ::Diadoc::Api::Proto::Docflow::InvoiceDocumentInfo* mutable_invoiceinfo();
  inline ::Diadoc::Api::Proto::Docflow::InvoiceDocumentInfo* release_invoiceinfo();
  inline void set_allocated_invoiceinfo(::Diadoc::Api::Proto::Docflow::InvoiceDocumentInfo* invoiceinfo);

  // optional .Diadoc.Api.Proto.Docflow.InvoiceCorrectionDocumentInfo InvoiceCorrectionInfo = 11;
  inline bool has_invoicecorrectioninfo() const;
  inline void clear_invoicecorrectioninfo();
  static const int kInvoiceCorrectionInfoFieldNumber = 11;
  inline const ::Diadoc::Api::Proto::Docflow::InvoiceCorrectionDocumentInfo& invoicecorrectioninfo() const;
  inline ::Diadoc::Api::Proto::Docflow::InvoiceCorrectionDocumentInfo* mutable_invoicecorrectioninfo();
  inline ::Diadoc::Api::Proto::Docflow::InvoiceCorrectionDocumentInfo* release_invoicecorrectioninfo();
  inline void set_allocated_invoicecorrectioninfo(::Diadoc::Api::Proto::Docflow::InvoiceCorrectionDocumentInfo* invoicecorrectioninfo);

  // optional .Diadoc.Api.Proto.Docflow.PriceListDocumentInfo PriceListInfo = 12;
  inline bool has_pricelistinfo() const;
  inline void clear_pricelistinfo();
  static const int kPriceListInfoFieldNumber = 12;
  inline const ::Diadoc::Api::Proto::Docflow::PriceListDocumentInfo& pricelistinfo() const;
  inline ::Diadoc::Api::Proto::Docflow::PriceListDocumentInfo* mutable_pricelistinfo();
  inline ::Diadoc::Api::Proto::Docflow::PriceListDocumentInfo* release_pricelistinfo();
  inline void set_allocated_pricelistinfo(::Diadoc::Api::Proto::Docflow::PriceListDocumentInfo* pricelistinfo);

  // optional .Diadoc.Api.Proto.Docflow.ContractDocumentInfo ContractInfo = 13;
  inline bool has_contractinfo() const;
  inline void clear_contractinfo();
  static const int kContractInfoFieldNumber = 13;
  inline const ::Diadoc::Api::Proto::Docflow::ContractDocumentInfo& contractinfo() const;
  inline ::Diadoc::Api::Proto::Docflow::ContractDocumentInfo* mutable_contractinfo();
  inline ::Diadoc::Api::Proto::Docflow::ContractDocumentInfo* release_contractinfo();
  inline void set_allocated_contractinfo(::Diadoc::Api::Proto::Docflow::ContractDocumentInfo* contractinfo);

  // optional .Diadoc.Api.Proto.Docflow.SupplementaryAgreementDocumentInfo SupplementaryAgreementInfo = 14;
  inline bool has_supplementaryagreementinfo() const;
  inline void clear_supplementaryagreementinfo();
  static const int kSupplementaryAgreementInfoFieldNumber = 14;
  inline const ::Diadoc::Api::Proto::Docflow::SupplementaryAgreementDocumentInfo& supplementaryagreementinfo() const;
  inline ::Diadoc::Api::Proto::Docflow::SupplementaryAgreementDocumentInfo* mutable_supplementaryagreementinfo();
  inline ::Diadoc::Api::Proto::Docflow::SupplementaryAgreementDocumentInfo* release_supplementaryagreementinfo();
  inline void set_allocated_supplementaryagreementinfo(::Diadoc::Api::Proto::Docflow::SupplementaryAgreementDocumentInfo* supplementaryagreementinfo);

  // optional .Diadoc.Api.Proto.Docflow.UniversalTransferDocumentInfo UniversalTransferDocumentInfo = 15;
  inline bool has_universaltransferdocumentinfo() const;
  inline void clear_universaltransferdocumentinfo();
  static const int kUniversalTransferDocumentInfoFieldNumber = 15;
  inline const ::Diadoc::Api::Proto::Docflow::UniversalTransferDocumentInfo& universaltransferdocumentinfo() const;
  inline ::Diadoc::Api::Proto::Docflow::UniversalTransferDocumentInfo* mutable_universaltransferdocumentinfo();
  inline ::Diadoc::Api::Proto::Docflow::UniversalTransferDocumentInfo* release_universaltransferdocumentinfo();
  inline void set_allocated_universaltransferdocumentinfo(::Diadoc::Api::Proto::Docflow::UniversalTransferDocumentInfo* universaltransferdocumentinfo);

  // optional .Diadoc.Api.Proto.Docflow.UniversalCorrectionDocumentInfo UniversalCorrectionDocumentInfo = 16;
  inline bool has_universalcorrectiondocumentinfo() const;
  inline void clear_universalcorrectiondocumentinfo();
  static const int kUniversalCorrectionDocumentInfoFieldNumber = 16;
  inline const ::Diadoc::Api::Proto::Docflow::UniversalCorrectionDocumentInfo& universalcorrectiondocumentinfo() const;
  inline ::Diadoc::Api::Proto::Docflow::UniversalCorrectionDocumentInfo* mutable_universalcorrectiondocumentinfo();
  inline ::Diadoc::Api::Proto::Docflow::UniversalCorrectionDocumentInfo* release_universalcorrectiondocumentinfo();
  inline void set_allocated_universalcorrectiondocumentinfo(::Diadoc::Api::Proto::Docflow::UniversalCorrectionDocumentInfo* universalcorrectiondocumentinfo);

  // optional string AttachmentVersion = 17;
  inline bool has_attachmentversion() const;
  inline void clear_attachmentversion();
  static const int kAttachmentVersionFieldNumber = 17;
  inline const ::std::string& attachmentversion() const;
  inline void set_attachmentversion(const ::std::string& value);
  inline void set_attachmentversion(const char* value);
  inline void set_attachmentversion(const char* value, size_t size);
  inline ::std::string* mutable_attachmentversion();
  inline ::std::string* release_attachmentversion();
  inline void set_allocated_attachmentversion(::std::string* attachmentversion);

  // required string Version = 18;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 18;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  inline void set_allocated_version(::std::string* version);

  // @@protoc_insertion_point(class_scope:Diadoc.Api.Proto.Docflow.DocumentInfo)
 private:
  inline void set_has_documenttype();
  inline void clear_has_documenttype();
  inline void set_has_documentdirection();
  inline void clear_has_documentdirection();
  inline void set_has_istest();
  inline void clear_has_istest();
  inline void set_has_customdocumentid();
  inline void clear_has_customdocumentid();
  inline void set_has_fromdepartmentid();
  inline void clear_has_fromdepartmentid();
  inline void set_has_todepartmentid();
  inline void clear_has_todepartmentid();
  inline void set_has_counteragentboxid();
  inline void clear_has_counteragentboxid();
  inline void set_has_documentdateandnumber();
  inline void clear_has_documentdateandnumber();
  inline void set_has_basicdocumentinfo();
  inline void clear_has_basicdocumentinfo();
  inline void set_has_invoiceinfo();
  inline void clear_has_invoiceinfo();
  inline void set_has_invoicecorrectioninfo();
  inline void clear_has_invoicecorrectioninfo();
  inline void set_has_pricelistinfo();
  inline void clear_has_pricelistinfo();
  inline void set_has_contractinfo();
  inline void clear_has_contractinfo();
  inline void set_has_supplementaryagreementinfo();
  inline void clear_has_supplementaryagreementinfo();
  inline void set_has_universaltransferdocumentinfo();
  inline void clear_has_universaltransferdocumentinfo();
  inline void set_has_universalcorrectiondocumentinfo();
  inline void clear_has_universalcorrectiondocumentinfo();
  inline void set_has_attachmentversion();
  inline void clear_has_attachmentversion();
  inline void set_has_version();
  inline void clear_has_version();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int documenttype_;
  int documentdirection_;
  ::std::string* customdocumentid_;
  ::std::string* fromdepartmentid_;
  ::std::string* todepartmentid_;
  ::std::string* counteragentboxid_;
  ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber* documentdateandnumber_;
  ::Diadoc::Api::Proto::Docflow::BasicDocumentInfo* basicdocumentinfo_;
  ::Diadoc::Api::Proto::Docflow::InvoiceDocumentInfo* invoiceinfo_;
  ::Diadoc::Api::Proto::Docflow::InvoiceCorrectionDocumentInfo* invoicecorrectioninfo_;
  ::Diadoc::Api::Proto::Docflow::PriceListDocumentInfo* pricelistinfo_;
  ::Diadoc::Api::Proto::Docflow::ContractDocumentInfo* contractinfo_;
  ::Diadoc::Api::Proto::Docflow::SupplementaryAgreementDocumentInfo* supplementaryagreementinfo_;
  ::Diadoc::Api::Proto::Docflow::UniversalTransferDocumentInfo* universaltransferdocumentinfo_;
  ::Diadoc::Api::Proto::Docflow::UniversalCorrectionDocumentInfo* universalcorrectiondocumentinfo_;
  ::std::string* attachmentversion_;
  ::std::string* version_;
  bool istest_;
  friend void  protobuf_AddDesc_Docflow_2fDocumentInfo_2eproto();
  friend void protobuf_AssignDesc_Docflow_2fDocumentInfo_2eproto();
  friend void protobuf_ShutdownFile_Docflow_2fDocumentInfo_2eproto();

  void InitAsDefaultInstance();
  static DocumentInfo* default_instance_;
};
// -------------------------------------------------------------------

class DocumentDateAndNumber : public ::google::protobuf::Message {
 public:
  DocumentDateAndNumber();
  virtual ~DocumentDateAndNumber();

  DocumentDateAndNumber(const DocumentDateAndNumber& from);

  inline DocumentDateAndNumber& operator=(const DocumentDateAndNumber& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DocumentDateAndNumber& default_instance();

  void Swap(DocumentDateAndNumber* other);

  // implements Message ----------------------------------------------

  DocumentDateAndNumber* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DocumentDateAndNumber& from);
  void MergeFrom(const DocumentDateAndNumber& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string DocumentDate = 1;
  inline bool has_documentdate() const;
  inline void clear_documentdate();
  static const int kDocumentDateFieldNumber = 1;
  inline const ::std::string& documentdate() const;
  inline void set_documentdate(const ::std::string& value);
  inline void set_documentdate(const char* value);
  inline void set_documentdate(const char* value, size_t size);
  inline ::std::string* mutable_documentdate();
  inline ::std::string* release_documentdate();
  inline void set_allocated_documentdate(::std::string* documentdate);

  // optional string DocumentNumber = 2;
  inline bool has_documentnumber() const;
  inline void clear_documentnumber();
  static const int kDocumentNumberFieldNumber = 2;
  inline const ::std::string& documentnumber() const;
  inline void set_documentnumber(const ::std::string& value);
  inline void set_documentnumber(const char* value);
  inline void set_documentnumber(const char* value, size_t size);
  inline ::std::string* mutable_documentnumber();
  inline ::std::string* release_documentnumber();
  inline void set_allocated_documentnumber(::std::string* documentnumber);

  // @@protoc_insertion_point(class_scope:Diadoc.Api.Proto.Docflow.DocumentDateAndNumber)
 private:
  inline void set_has_documentdate();
  inline void clear_has_documentdate();
  inline void set_has_documentnumber();
  inline void clear_has_documentnumber();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* documentdate_;
  ::std::string* documentnumber_;
  friend void  protobuf_AddDesc_Docflow_2fDocumentInfo_2eproto();
  friend void protobuf_AssignDesc_Docflow_2fDocumentInfo_2eproto();
  friend void protobuf_ShutdownFile_Docflow_2fDocumentInfo_2eproto();

  void InitAsDefaultInstance();
  static DocumentDateAndNumber* default_instance_;
};
// -------------------------------------------------------------------

class BasicDocumentInfo : public ::google::protobuf::Message {
 public:
  BasicDocumentInfo();
  virtual ~BasicDocumentInfo();

  BasicDocumentInfo(const BasicDocumentInfo& from);

  inline BasicDocumentInfo& operator=(const BasicDocumentInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BasicDocumentInfo& default_instance();

  void Swap(BasicDocumentInfo* other);

  // implements Message ----------------------------------------------

  BasicDocumentInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BasicDocumentInfo& from);
  void MergeFrom(const BasicDocumentInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string Total = 1;
  inline bool has_total() const;
  inline void clear_total();
  static const int kTotalFieldNumber = 1;
  inline const ::std::string& total() const;
  inline void set_total(const ::std::string& value);
  inline void set_total(const char* value);
  inline void set_total(const char* value, size_t size);
  inline ::std::string* mutable_total();
  inline ::std::string* release_total();
  inline void set_allocated_total(::std::string* total);

  // optional bool NoVat = 2;
  inline bool has_novat() const;
  inline void clear_novat();
  static const int kNoVatFieldNumber = 2;
  inline bool novat() const;
  inline void set_novat(bool value);

  // optional string Vat = 3;
  inline bool has_vat() const;
  inline void clear_vat();
  static const int kVatFieldNumber = 3;
  inline const ::std::string& vat() const;
  inline void set_vat(const ::std::string& value);
  inline void set_vat(const char* value);
  inline void set_vat(const char* value, size_t size);
  inline ::std::string* mutable_vat();
  inline ::std::string* release_vat();
  inline void set_allocated_vat(::std::string* vat);

  // optional string Grounds = 4;
  inline bool has_grounds() const;
  inline void clear_grounds();
  static const int kGroundsFieldNumber = 4;
  inline const ::std::string& grounds() const;
  inline void set_grounds(const ::std::string& value);
  inline void set_grounds(const char* value);
  inline void set_grounds(const char* value, size_t size);
  inline ::std::string* mutable_grounds();
  inline ::std::string* release_grounds();
  inline void set_allocated_grounds(::std::string* grounds);

  // optional .Diadoc.Api.Proto.Docflow.DocumentDateAndNumber RevisionDateAndNumber = 5;
  inline bool has_revisiondateandnumber() const;
  inline void clear_revisiondateandnumber();
  static const int kRevisionDateAndNumberFieldNumber = 5;
  inline const ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber& revisiondateandnumber() const;
  inline ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber* mutable_revisiondateandnumber();
  inline ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber* release_revisiondateandnumber();
  inline void set_allocated_revisiondateandnumber(::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber* revisiondateandnumber);

  // @@protoc_insertion_point(class_scope:Diadoc.Api.Proto.Docflow.BasicDocumentInfo)
 private:
  inline void set_has_total();
  inline void clear_has_total();
  inline void set_has_novat();
  inline void clear_has_novat();
  inline void set_has_vat();
  inline void clear_has_vat();
  inline void set_has_grounds();
  inline void clear_has_grounds();
  inline void set_has_revisiondateandnumber();
  inline void clear_has_revisiondateandnumber();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* total_;
  ::std::string* vat_;
  ::std::string* grounds_;
  ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber* revisiondateandnumber_;
  bool novat_;
  friend void  protobuf_AddDesc_Docflow_2fDocumentInfo_2eproto();
  friend void protobuf_AssignDesc_Docflow_2fDocumentInfo_2eproto();
  friend void protobuf_ShutdownFile_Docflow_2fDocumentInfo_2eproto();

  void InitAsDefaultInstance();
  static BasicDocumentInfo* default_instance_;
};
// -------------------------------------------------------------------

class InvoiceDocumentInfo : public ::google::protobuf::Message {
 public:
  InvoiceDocumentInfo();
  virtual ~InvoiceDocumentInfo();

  InvoiceDocumentInfo(const InvoiceDocumentInfo& from);

  inline InvoiceDocumentInfo& operator=(const InvoiceDocumentInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InvoiceDocumentInfo& default_instance();

  void Swap(InvoiceDocumentInfo* other);

  // implements Message ----------------------------------------------

  InvoiceDocumentInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InvoiceDocumentInfo& from);
  void MergeFrom(const InvoiceDocumentInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string Total = 1;
  inline bool has_total() const;
  inline void clear_total();
  static const int kTotalFieldNumber = 1;
  inline const ::std::string& total() const;
  inline void set_total(const ::std::string& value);
  inline void set_total(const char* value);
  inline void set_total(const char* value, size_t size);
  inline ::std::string* mutable_total();
  inline ::std::string* release_total();
  inline void set_allocated_total(::std::string* total);

  // optional string Vat = 2;
  inline bool has_vat() const;
  inline void clear_vat();
  static const int kVatFieldNumber = 2;
  inline const ::std::string& vat() const;
  inline void set_vat(const ::std::string& value);
  inline void set_vat(const char* value);
  inline void set_vat(const char* value, size_t size);
  inline ::std::string* mutable_vat();
  inline ::std::string* release_vat();
  inline void set_allocated_vat(::std::string* vat);

  // optional int32 CurrencyCode = 3;
  inline bool has_currencycode() const;
  inline void clear_currencycode();
  static const int kCurrencyCodeFieldNumber = 3;
  inline ::google::protobuf::int32 currencycode() const;
  inline void set_currencycode(::google::protobuf::int32 value);

  // optional .Diadoc.Api.Proto.Docflow.DocumentDateAndNumber OriginalInvoiceDateAndNumber = 4;
  inline bool has_originalinvoicedateandnumber() const;
  inline void clear_originalinvoicedateandnumber();
  static const int kOriginalInvoiceDateAndNumberFieldNumber = 4;
  inline const ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber& originalinvoicedateandnumber() const;
  inline ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber* mutable_originalinvoicedateandnumber();
  inline ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber* release_originalinvoicedateandnumber();
  inline void set_allocated_originalinvoicedateandnumber(::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber* originalinvoicedateandnumber);

  // @@protoc_insertion_point(class_scope:Diadoc.Api.Proto.Docflow.InvoiceDocumentInfo)
 private:
  inline void set_has_total();
  inline void clear_has_total();
  inline void set_has_vat();
  inline void clear_has_vat();
  inline void set_has_currencycode();
  inline void clear_has_currencycode();
  inline void set_has_originalinvoicedateandnumber();
  inline void clear_has_originalinvoicedateandnumber();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* total_;
  ::std::string* vat_;
  ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber* originalinvoicedateandnumber_;
  ::google::protobuf::int32 currencycode_;
  friend void  protobuf_AddDesc_Docflow_2fDocumentInfo_2eproto();
  friend void protobuf_AssignDesc_Docflow_2fDocumentInfo_2eproto();
  friend void protobuf_ShutdownFile_Docflow_2fDocumentInfo_2eproto();

  void InitAsDefaultInstance();
  static InvoiceDocumentInfo* default_instance_;
};
// -------------------------------------------------------------------

class InvoiceCorrectionDocumentInfo : public ::google::protobuf::Message {
 public:
  InvoiceCorrectionDocumentInfo();
  virtual ~InvoiceCorrectionDocumentInfo();

  InvoiceCorrectionDocumentInfo(const InvoiceCorrectionDocumentInfo& from);

  inline InvoiceCorrectionDocumentInfo& operator=(const InvoiceCorrectionDocumentInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InvoiceCorrectionDocumentInfo& default_instance();

  void Swap(InvoiceCorrectionDocumentInfo* other);

  // implements Message ----------------------------------------------

  InvoiceCorrectionDocumentInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InvoiceCorrectionDocumentInfo& from);
  void MergeFrom(const InvoiceCorrectionDocumentInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string TotalInc = 1;
  inline bool has_totalinc() const;
  inline void clear_totalinc();
  static const int kTotalIncFieldNumber = 1;
  inline const ::std::string& totalinc() const;
  inline void set_totalinc(const ::std::string& value);
  inline void set_totalinc(const char* value);
  inline void set_totalinc(const char* value, size_t size);
  inline ::std::string* mutable_totalinc();
  inline ::std::string* release_totalinc();
  inline void set_allocated_totalinc(::std::string* totalinc);

  // optional string TotalDec = 2;
  inline bool has_totaldec() const;
  inline void clear_totaldec();
  static const int kTotalDecFieldNumber = 2;
  inline const ::std::string& totaldec() const;
  inline void set_totaldec(const ::std::string& value);
  inline void set_totaldec(const char* value);
  inline void set_totaldec(const char* value, size_t size);
  inline ::std::string* mutable_totaldec();
  inline ::std::string* release_totaldec();
  inline void set_allocated_totaldec(::std::string* totaldec);

  // optional string VatInc = 3;
  inline bool has_vatinc() const;
  inline void clear_vatinc();
  static const int kVatIncFieldNumber = 3;
  inline const ::std::string& vatinc() const;
  inline void set_vatinc(const ::std::string& value);
  inline void set_vatinc(const char* value);
  inline void set_vatinc(const char* value, size_t size);
  inline ::std::string* mutable_vatinc();
  inline ::std::string* release_vatinc();
  inline void set_allocated_vatinc(::std::string* vatinc);

  // optional string VatDec = 4;
  inline bool has_vatdec() const;
  inline void clear_vatdec();
  static const int kVatDecFieldNumber = 4;
  inline const ::std::string& vatdec() const;
  inline void set_vatdec(const ::std::string& value);
  inline void set_vatdec(const char* value);
  inline void set_vatdec(const char* value, size_t size);
  inline ::std::string* mutable_vatdec();
  inline ::std::string* release_vatdec();
  inline void set_allocated_vatdec(::std::string* vatdec);

  // optional int32 CurrencyCode = 5;
  inline bool has_currencycode() const;
  inline void clear_currencycode();
  static const int kCurrencyCodeFieldNumber = 5;
  inline ::google::protobuf::int32 currencycode() const;
  inline void set_currencycode(::google::protobuf::int32 value);

  // optional .Diadoc.Api.Proto.Docflow.DocumentDateAndNumber OriginalInvoiceDateAndNumber = 6;
  inline bool has_originalinvoicedateandnumber() const;
  inline void clear_originalinvoicedateandnumber();
  static const int kOriginalInvoiceDateAndNumberFieldNumber = 6;
  inline const ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber& originalinvoicedateandnumber() const;
  inline ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber* mutable_originalinvoicedateandnumber();
  inline ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber* release_originalinvoicedateandnumber();
  inline void set_allocated_originalinvoicedateandnumber(::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber* originalinvoicedateandnumber);

  // optional .Diadoc.Api.Proto.Docflow.DocumentDateAndNumber OriginalInvoiceRevisionDateAndNumber = 7;
  inline bool has_originalinvoicerevisiondateandnumber() const;
  inline void clear_originalinvoicerevisiondateandnumber();
  static const int kOriginalInvoiceRevisionDateAndNumberFieldNumber = 7;
  inline const ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber& originalinvoicerevisiondateandnumber() const;
  inline ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber* mutable_originalinvoicerevisiondateandnumber();
  inline ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber* release_originalinvoicerevisiondateandnumber();
  inline void set_allocated_originalinvoicerevisiondateandnumber(::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber* originalinvoicerevisiondateandnumber);

  // optional .Diadoc.Api.Proto.Docflow.DocumentDateAndNumber OriginalInvoiceCorrectionDateAndNumber = 8;
  inline bool has_originalinvoicecorrectiondateandnumber() const;
  inline void clear_originalinvoicecorrectiondateandnumber();
  static const int kOriginalInvoiceCorrectionDateAndNumberFieldNumber = 8;
  inline const ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber& originalinvoicecorrectiondateandnumber() const;
  inline ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber* mutable_originalinvoicecorrectiondateandnumber();
  inline ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber* release_originalinvoicecorrectiondateandnumber();
  inline void set_allocated_originalinvoicecorrectiondateandnumber(::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber* originalinvoicecorrectiondateandnumber);

  // @@protoc_insertion_point(class_scope:Diadoc.Api.Proto.Docflow.InvoiceCorrectionDocumentInfo)
 private:
  inline void set_has_totalinc();
  inline void clear_has_totalinc();
  inline void set_has_totaldec();
  inline void clear_has_totaldec();
  inline void set_has_vatinc();
  inline void clear_has_vatinc();
  inline void set_has_vatdec();
  inline void clear_has_vatdec();
  inline void set_has_currencycode();
  inline void clear_has_currencycode();
  inline void set_has_originalinvoicedateandnumber();
  inline void clear_has_originalinvoicedateandnumber();
  inline void set_has_originalinvoicerevisiondateandnumber();
  inline void clear_has_originalinvoicerevisiondateandnumber();
  inline void set_has_originalinvoicecorrectiondateandnumber();
  inline void clear_has_originalinvoicecorrectiondateandnumber();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* totalinc_;
  ::std::string* totaldec_;
  ::std::string* vatinc_;
  ::std::string* vatdec_;
  ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber* originalinvoicedateandnumber_;
  ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber* originalinvoicerevisiondateandnumber_;
  ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber* originalinvoicecorrectiondateandnumber_;
  ::google::protobuf::int32 currencycode_;
  friend void  protobuf_AddDesc_Docflow_2fDocumentInfo_2eproto();
  friend void protobuf_AssignDesc_Docflow_2fDocumentInfo_2eproto();
  friend void protobuf_ShutdownFile_Docflow_2fDocumentInfo_2eproto();

  void InitAsDefaultInstance();
  static InvoiceCorrectionDocumentInfo* default_instance_;
};
// -------------------------------------------------------------------

class PriceListDocumentInfo : public ::google::protobuf::Message {
 public:
  PriceListDocumentInfo();
  virtual ~PriceListDocumentInfo();

  PriceListDocumentInfo(const PriceListDocumentInfo& from);

  inline PriceListDocumentInfo& operator=(const PriceListDocumentInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PriceListDocumentInfo& default_instance();

  void Swap(PriceListDocumentInfo* other);

  // implements Message ----------------------------------------------

  PriceListDocumentInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PriceListDocumentInfo& from);
  void MergeFrom(const PriceListDocumentInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string PriceListEffectiveDate = 1;
  inline bool has_pricelisteffectivedate() const;
  inline void clear_pricelisteffectivedate();
  static const int kPriceListEffectiveDateFieldNumber = 1;
  inline const ::std::string& pricelisteffectivedate() const;
  inline void set_pricelisteffectivedate(const ::std::string& value);
  inline void set_pricelisteffectivedate(const char* value);
  inline void set_pricelisteffectivedate(const char* value, size_t size);
  inline ::std::string* mutable_pricelisteffectivedate();
  inline ::std::string* release_pricelisteffectivedate();
  inline void set_allocated_pricelisteffectivedate(::std::string* pricelisteffectivedate);

  // optional .Diadoc.Api.Proto.Docflow.DocumentDateAndNumber ContractDocumentDateAndNumber = 2;
  inline bool has_contractdocumentdateandnumber() const;
  inline void clear_contractdocumentdateandnumber();
  static const int kContractDocumentDateAndNumberFieldNumber = 2;
  inline const ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber& contractdocumentdateandnumber() const;
  inline ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber* mutable_contractdocumentdateandnumber();
  inline ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber* release_contractdocumentdateandnumber();
  inline void set_allocated_contractdocumentdateandnumber(::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber* contractdocumentdateandnumber);

  // @@protoc_insertion_point(class_scope:Diadoc.Api.Proto.Docflow.PriceListDocumentInfo)
 private:
  inline void set_has_pricelisteffectivedate();
  inline void clear_has_pricelisteffectivedate();
  inline void set_has_contractdocumentdateandnumber();
  inline void clear_has_contractdocumentdateandnumber();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* pricelisteffectivedate_;
  ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber* contractdocumentdateandnumber_;
  friend void  protobuf_AddDesc_Docflow_2fDocumentInfo_2eproto();
  friend void protobuf_AssignDesc_Docflow_2fDocumentInfo_2eproto();
  friend void protobuf_ShutdownFile_Docflow_2fDocumentInfo_2eproto();

  void InitAsDefaultInstance();
  static PriceListDocumentInfo* default_instance_;
};
// -------------------------------------------------------------------

class ContractDocumentInfo : public ::google::protobuf::Message {
 public:
  ContractDocumentInfo();
  virtual ~ContractDocumentInfo();

  ContractDocumentInfo(const ContractDocumentInfo& from);

  inline ContractDocumentInfo& operator=(const ContractDocumentInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ContractDocumentInfo& default_instance();

  void Swap(ContractDocumentInfo* other);

  // implements Message ----------------------------------------------

  ContractDocumentInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ContractDocumentInfo& from);
  void MergeFrom(const ContractDocumentInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string ContractPrice = 1;
  inline bool has_contractprice() const;
  inline void clear_contractprice();
  static const int kContractPriceFieldNumber = 1;
  inline const ::std::string& contractprice() const;
  inline void set_contractprice(const ::std::string& value);
  inline void set_contractprice(const char* value);
  inline void set_contractprice(const char* value, size_t size);
  inline ::std::string* mutable_contractprice();
  inline ::std::string* release_contractprice();
  inline void set_allocated_contractprice(::std::string* contractprice);

  // optional string ContractType = 2;
  inline bool has_contracttype() const;
  inline void clear_contracttype();
  static const int kContractTypeFieldNumber = 2;
  inline const ::std::string& contracttype() const;
  inline void set_contracttype(const ::std::string& value);
  inline void set_contracttype(const char* value);
  inline void set_contracttype(const char* value, size_t size);
  inline ::std::string* mutable_contracttype();
  inline ::std::string* release_contracttype();
  inline void set_allocated_contracttype(::std::string* contracttype);

  // @@protoc_insertion_point(class_scope:Diadoc.Api.Proto.Docflow.ContractDocumentInfo)
 private:
  inline void set_has_contractprice();
  inline void clear_has_contractprice();
  inline void set_has_contracttype();
  inline void clear_has_contracttype();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* contractprice_;
  ::std::string* contracttype_;
  friend void  protobuf_AddDesc_Docflow_2fDocumentInfo_2eproto();
  friend void protobuf_AssignDesc_Docflow_2fDocumentInfo_2eproto();
  friend void protobuf_ShutdownFile_Docflow_2fDocumentInfo_2eproto();

  void InitAsDefaultInstance();
  static ContractDocumentInfo* default_instance_;
};
// -------------------------------------------------------------------

class SupplementaryAgreementDocumentInfo : public ::google::protobuf::Message {
 public:
  SupplementaryAgreementDocumentInfo();
  virtual ~SupplementaryAgreementDocumentInfo();

  SupplementaryAgreementDocumentInfo(const SupplementaryAgreementDocumentInfo& from);

  inline SupplementaryAgreementDocumentInfo& operator=(const SupplementaryAgreementDocumentInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SupplementaryAgreementDocumentInfo& default_instance();

  void Swap(SupplementaryAgreementDocumentInfo* other);

  // implements Message ----------------------------------------------

  SupplementaryAgreementDocumentInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SupplementaryAgreementDocumentInfo& from);
  void MergeFrom(const SupplementaryAgreementDocumentInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string ContractType = 1;
  inline bool has_contracttype() const;
  inline void clear_contracttype();
  static const int kContractTypeFieldNumber = 1;
  inline const ::std::string& contracttype() const;
  inline void set_contracttype(const ::std::string& value);
  inline void set_contracttype(const char* value);
  inline void set_contracttype(const char* value, size_t size);
  inline ::std::string* mutable_contracttype();
  inline ::std::string* release_contracttype();
  inline void set_allocated_contracttype(::std::string* contracttype);

  // required .Diadoc.Api.Proto.Docflow.DocumentDateAndNumber ContractDocumentDateAndNumber = 2;
  inline bool has_contractdocumentdateandnumber() const;
  inline void clear_contractdocumentdateandnumber();
  static const int kContractDocumentDateAndNumberFieldNumber = 2;
  inline const ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber& contractdocumentdateandnumber() const;
  inline ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber* mutable_contractdocumentdateandnumber();
  inline ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber* release_contractdocumentdateandnumber();
  inline void set_allocated_contractdocumentdateandnumber(::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber* contractdocumentdateandnumber);

  // required .Diadoc.Api.Proto.Docflow.DocumentDateAndNumber DocumentDateAndNumber = 3;
  inline bool has_documentdateandnumber() const;
  inline void clear_documentdateandnumber();
  static const int kDocumentDateAndNumberFieldNumber = 3;
  inline const ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber& documentdateandnumber() const;
  inline ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber* mutable_documentdateandnumber();
  inline ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber* release_documentdateandnumber();
  inline void set_allocated_documentdateandnumber(::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber* documentdateandnumber);

  // optional string Total = 4;
  inline bool has_total() const;
  inline void clear_total();
  static const int kTotalFieldNumber = 4;
  inline const ::std::string& total() const;
  inline void set_total(const ::std::string& value);
  inline void set_total(const char* value);
  inline void set_total(const char* value, size_t size);
  inline ::std::string* mutable_total();
  inline ::std::string* release_total();
  inline void set_allocated_total(::std::string* total);

  // @@protoc_insertion_point(class_scope:Diadoc.Api.Proto.Docflow.SupplementaryAgreementDocumentInfo)
 private:
  inline void set_has_contracttype();
  inline void clear_has_contracttype();
  inline void set_has_contractdocumentdateandnumber();
  inline void clear_has_contractdocumentdateandnumber();
  inline void set_has_documentdateandnumber();
  inline void clear_has_documentdateandnumber();
  inline void set_has_total();
  inline void clear_has_total();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* contracttype_;
  ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber* contractdocumentdateandnumber_;
  ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber* documentdateandnumber_;
  ::std::string* total_;
  friend void  protobuf_AddDesc_Docflow_2fDocumentInfo_2eproto();
  friend void protobuf_AssignDesc_Docflow_2fDocumentInfo_2eproto();
  friend void protobuf_ShutdownFile_Docflow_2fDocumentInfo_2eproto();

  void InitAsDefaultInstance();
  static SupplementaryAgreementDocumentInfo* default_instance_;
};
// -------------------------------------------------------------------

class UniversalTransferDocumentInfo : public ::google::protobuf::Message {
 public:
  UniversalTransferDocumentInfo();
  virtual ~UniversalTransferDocumentInfo();

  UniversalTransferDocumentInfo(const UniversalTransferDocumentInfo& from);

  inline UniversalTransferDocumentInfo& operator=(const UniversalTransferDocumentInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UniversalTransferDocumentInfo& default_instance();

  void Swap(UniversalTransferDocumentInfo* other);

  // implements Message ----------------------------------------------

  UniversalTransferDocumentInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UniversalTransferDocumentInfo& from);
  void MergeFrom(const UniversalTransferDocumentInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string Total = 1;
  inline bool has_total() const;
  inline void clear_total();
  static const int kTotalFieldNumber = 1;
  inline const ::std::string& total() const;
  inline void set_total(const ::std::string& value);
  inline void set_total(const char* value);
  inline void set_total(const char* value, size_t size);
  inline ::std::string* mutable_total();
  inline ::std::string* release_total();
  inline void set_allocated_total(::std::string* total);

  // optional string Vat = 2;
  inline bool has_vat() const;
  inline void clear_vat();
  static const int kVatFieldNumber = 2;
  inline const ::std::string& vat() const;
  inline void set_vat(const ::std::string& value);
  inline void set_vat(const char* value);
  inline void set_vat(const char* value, size_t size);
  inline ::std::string* mutable_vat();
  inline ::std::string* release_vat();
  inline void set_allocated_vat(::std::string* vat);

  // optional int32 CurrencyCode = 3;
  inline bool has_currencycode() const;
  inline void clear_currencycode();
  static const int kCurrencyCodeFieldNumber = 3;
  inline ::google::protobuf::int32 currencycode() const;
  inline void set_currencycode(::google::protobuf::int32 value);

  // optional string Grounds = 4;
  inline bool has_grounds() const;
  inline void clear_grounds();
  static const int kGroundsFieldNumber = 4;
  inline const ::std::string& grounds() const;
  inline void set_grounds(const ::std::string& value);
  inline void set_grounds(const char* value);
  inline void set_grounds(const char* value, size_t size);
  inline ::std::string* mutable_grounds();
  inline ::std::string* release_grounds();
  inline void set_allocated_grounds(::std::string* grounds);

  // required .Diadoc.Api.Proto.Invoicing.FunctionType Function = 5;
  inline bool has_function() const;
  inline void clear_function();
  static const int kFunctionFieldNumber = 5;
  inline ::Diadoc::Api::Proto::Invoicing::FunctionType function() const;
  inline void set_function(::Diadoc::Api::Proto::Invoicing::FunctionType value);

  // optional .Diadoc.Api.Proto.Docflow.DocumentDateAndNumber OriginalDocumentDateAndNumber = 6;
  inline bool has_originaldocumentdateandnumber() const;
  inline void clear_originaldocumentdateandnumber();
  static const int kOriginalDocumentDateAndNumberFieldNumber = 6;
  inline const ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber& originaldocumentdateandnumber() const;
  inline ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber* mutable_originaldocumentdateandnumber();
  inline ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber* release_originaldocumentdateandnumber();
  inline void set_allocated_originaldocumentdateandnumber(::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber* originaldocumentdateandnumber);

  // @@protoc_insertion_point(class_scope:Diadoc.Api.Proto.Docflow.UniversalTransferDocumentInfo)
 private:
  inline void set_has_total();
  inline void clear_has_total();
  inline void set_has_vat();
  inline void clear_has_vat();
  inline void set_has_currencycode();
  inline void clear_has_currencycode();
  inline void set_has_grounds();
  inline void clear_has_grounds();
  inline void set_has_function();
  inline void clear_has_function();
  inline void set_has_originaldocumentdateandnumber();
  inline void clear_has_originaldocumentdateandnumber();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* total_;
  ::std::string* vat_;
  ::std::string* grounds_;
  ::google::protobuf::int32 currencycode_;
  int function_;
  ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber* originaldocumentdateandnumber_;
  friend void  protobuf_AddDesc_Docflow_2fDocumentInfo_2eproto();
  friend void protobuf_AssignDesc_Docflow_2fDocumentInfo_2eproto();
  friend void protobuf_ShutdownFile_Docflow_2fDocumentInfo_2eproto();

  void InitAsDefaultInstance();
  static UniversalTransferDocumentInfo* default_instance_;
};
// -------------------------------------------------------------------

class UniversalCorrectionDocumentInfo : public ::google::protobuf::Message {
 public:
  UniversalCorrectionDocumentInfo();
  virtual ~UniversalCorrectionDocumentInfo();

  UniversalCorrectionDocumentInfo(const UniversalCorrectionDocumentInfo& from);

  inline UniversalCorrectionDocumentInfo& operator=(const UniversalCorrectionDocumentInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UniversalCorrectionDocumentInfo& default_instance();

  void Swap(UniversalCorrectionDocumentInfo* other);

  // implements Message ----------------------------------------------

  UniversalCorrectionDocumentInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UniversalCorrectionDocumentInfo& from);
  void MergeFrom(const UniversalCorrectionDocumentInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string TotalInc = 1;
  inline bool has_totalinc() const;
  inline void clear_totalinc();
  static const int kTotalIncFieldNumber = 1;
  inline const ::std::string& totalinc() const;
  inline void set_totalinc(const ::std::string& value);
  inline void set_totalinc(const char* value);
  inline void set_totalinc(const char* value, size_t size);
  inline ::std::string* mutable_totalinc();
  inline ::std::string* release_totalinc();
  inline void set_allocated_totalinc(::std::string* totalinc);

  // optional string TotalDec = 2;
  inline bool has_totaldec() const;
  inline void clear_totaldec();
  static const int kTotalDecFieldNumber = 2;
  inline const ::std::string& totaldec() const;
  inline void set_totaldec(const ::std::string& value);
  inline void set_totaldec(const char* value);
  inline void set_totaldec(const char* value, size_t size);
  inline ::std::string* mutable_totaldec();
  inline ::std::string* release_totaldec();
  inline void set_allocated_totaldec(::std::string* totaldec);

  // optional string VatInc = 3;
  inline bool has_vatinc() const;
  inline void clear_vatinc();
  static const int kVatIncFieldNumber = 3;
  inline const ::std::string& vatinc() const;
  inline void set_vatinc(const ::std::string& value);
  inline void set_vatinc(const char* value);
  inline void set_vatinc(const char* value, size_t size);
  inline ::std::string* mutable_vatinc();
  inline ::std::string* release_vatinc();
  inline void set_allocated_vatinc(::std::string* vatinc);

  // optional string VatDec = 4;
  inline bool has_vatdec() const;
  inline void clear_vatdec();
  static const int kVatDecFieldNumber = 4;
  inline const ::std::string& vatdec() const;
  inline void set_vatdec(const ::std::string& value);
  inline void set_vatdec(const char* value);
  inline void set_vatdec(const char* value, size_t size);
  inline ::std::string* mutable_vatdec();
  inline ::std::string* release_vatdec();
  inline void set_allocated_vatdec(::std::string* vatdec);

  // optional int32 CurrencyCode = 5;
  inline bool has_currencycode() const;
  inline void clear_currencycode();
  static const int kCurrencyCodeFieldNumber = 5;
  inline ::google::protobuf::int32 currencycode() const;
  inline void set_currencycode(::google::protobuf::int32 value);

  // optional string Grounds = 6;
  inline bool has_grounds() const;
  inline void clear_grounds();
  static const int kGroundsFieldNumber = 6;
  inline const ::std::string& grounds() const;
  inline void set_grounds(const ::std::string& value);
  inline void set_grounds(const char* value);
  inline void set_grounds(const char* value, size_t size);
  inline ::std::string* mutable_grounds();
  inline ::std::string* release_grounds();
  inline void set_allocated_grounds(::std::string* grounds);

  // required .Diadoc.Api.Proto.Invoicing.FunctionType Function = 7;
  inline bool has_function() const;
  inline void clear_function();
  static const int kFunctionFieldNumber = 7;
  inline ::Diadoc::Api::Proto::Invoicing::FunctionType function() const;
  inline void set_function(::Diadoc::Api::Proto::Invoicing::FunctionType value);

  // optional .Diadoc.Api.Proto.Docflow.DocumentDateAndNumber OriginalDocumentDateAndNumber = 8;
  inline bool has_originaldocumentdateandnumber() const;
  inline void clear_originaldocumentdateandnumber();
  static const int kOriginalDocumentDateAndNumberFieldNumber = 8;
  inline const ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber& originaldocumentdateandnumber() const;
  inline ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber* mutable_originaldocumentdateandnumber();
  inline ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber* release_originaldocumentdateandnumber();
  inline void set_allocated_originaldocumentdateandnumber(::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber* originaldocumentdateandnumber);

  // optional .Diadoc.Api.Proto.Docflow.DocumentDateAndNumber OriginalDocumentRevisionDateAndNumber = 9;
  inline bool has_originaldocumentrevisiondateandnumber() const;
  inline void clear_originaldocumentrevisiondateandnumber();
  static const int kOriginalDocumentRevisionDateAndNumberFieldNumber = 9;
  inline const ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber& originaldocumentrevisiondateandnumber() const;
  inline ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber* mutable_originaldocumentrevisiondateandnumber();
  inline ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber* release_originaldocumentrevisiondateandnumber();
  inline void set_allocated_originaldocumentrevisiondateandnumber(::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber* originaldocumentrevisiondateandnumber);

  // optional .Diadoc.Api.Proto.Docflow.DocumentDateAndNumber OriginalDocumentCorrectionDateAndNumber = 10;
  inline bool has_originaldocumentcorrectiondateandnumber() const;
  inline void clear_originaldocumentcorrectiondateandnumber();
  static const int kOriginalDocumentCorrectionDateAndNumberFieldNumber = 10;
  inline const ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber& originaldocumentcorrectiondateandnumber() const;
  inline ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber* mutable_originaldocumentcorrectiondateandnumber();
  inline ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber* release_originaldocumentcorrectiondateandnumber();
  inline void set_allocated_originaldocumentcorrectiondateandnumber(::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber* originaldocumentcorrectiondateandnumber);

  // @@protoc_insertion_point(class_scope:Diadoc.Api.Proto.Docflow.UniversalCorrectionDocumentInfo)
 private:
  inline void set_has_totalinc();
  inline void clear_has_totalinc();
  inline void set_has_totaldec();
  inline void clear_has_totaldec();
  inline void set_has_vatinc();
  inline void clear_has_vatinc();
  inline void set_has_vatdec();
  inline void clear_has_vatdec();
  inline void set_has_currencycode();
  inline void clear_has_currencycode();
  inline void set_has_grounds();
  inline void clear_has_grounds();
  inline void set_has_function();
  inline void clear_has_function();
  inline void set_has_originaldocumentdateandnumber();
  inline void clear_has_originaldocumentdateandnumber();
  inline void set_has_originaldocumentrevisiondateandnumber();
  inline void clear_has_originaldocumentrevisiondateandnumber();
  inline void set_has_originaldocumentcorrectiondateandnumber();
  inline void clear_has_originaldocumentcorrectiondateandnumber();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* totalinc_;
  ::std::string* totaldec_;
  ::std::string* vatinc_;
  ::std::string* vatdec_;
  ::std::string* grounds_;
  ::google::protobuf::int32 currencycode_;
  int function_;
  ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber* originaldocumentdateandnumber_;
  ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber* originaldocumentrevisiondateandnumber_;
  ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber* originaldocumentcorrectiondateandnumber_;
  friend void  protobuf_AddDesc_Docflow_2fDocumentInfo_2eproto();
  friend void protobuf_AssignDesc_Docflow_2fDocumentInfo_2eproto();
  friend void protobuf_ShutdownFile_Docflow_2fDocumentInfo_2eproto();

  void InitAsDefaultInstance();
  static UniversalCorrectionDocumentInfo* default_instance_;
};
// ===================================================================


// ===================================================================

// DocumentInfo

// optional .Diadoc.Api.Proto.DocumentType DocumentType = 1 [default = UnknownDocumentType];
inline bool DocumentInfo::has_documenttype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DocumentInfo::set_has_documenttype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DocumentInfo::clear_has_documenttype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DocumentInfo::clear_documenttype() {
  documenttype_ = -1;
  clear_has_documenttype();
}
inline ::Diadoc::Api::Proto::DocumentType DocumentInfo::documenttype() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Docflow.DocumentInfo.DocumentType)
  return static_cast< ::Diadoc::Api::Proto::DocumentType >(documenttype_);
}
inline void DocumentInfo::set_documenttype(::Diadoc::Api::Proto::DocumentType value) {
  assert(::Diadoc::Api::Proto::DocumentType_IsValid(value));
  set_has_documenttype();
  documenttype_ = value;
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Docflow.DocumentInfo.DocumentType)
}

// optional .Diadoc.Api.Proto.DocumentDirection DocumentDirection = 2 [default = UnknownDocumentDirection];
inline bool DocumentInfo::has_documentdirection() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DocumentInfo::set_has_documentdirection() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DocumentInfo::clear_has_documentdirection() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DocumentInfo::clear_documentdirection() {
  documentdirection_ = 0;
  clear_has_documentdirection();
}
inline ::Diadoc::Api::Proto::DocumentDirection DocumentInfo::documentdirection() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Docflow.DocumentInfo.DocumentDirection)
  return static_cast< ::Diadoc::Api::Proto::DocumentDirection >(documentdirection_);
}
inline void DocumentInfo::set_documentdirection(::Diadoc::Api::Proto::DocumentDirection value) {
  assert(::Diadoc::Api::Proto::DocumentDirection_IsValid(value));
  set_has_documentdirection();
  documentdirection_ = value;
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Docflow.DocumentInfo.DocumentDirection)
}

// optional bool IsTest = 3;
inline bool DocumentInfo::has_istest() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DocumentInfo::set_has_istest() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DocumentInfo::clear_has_istest() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DocumentInfo::clear_istest() {
  istest_ = false;
  clear_has_istest();
}
inline bool DocumentInfo::istest() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Docflow.DocumentInfo.IsTest)
  return istest_;
}
inline void DocumentInfo::set_istest(bool value) {
  set_has_istest();
  istest_ = value;
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Docflow.DocumentInfo.IsTest)
}

// optional string CustomDocumentId = 4;
inline bool DocumentInfo::has_customdocumentid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DocumentInfo::set_has_customdocumentid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DocumentInfo::clear_has_customdocumentid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DocumentInfo::clear_customdocumentid() {
  if (customdocumentid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    customdocumentid_->clear();
  }
  clear_has_customdocumentid();
}
inline const ::std::string& DocumentInfo::customdocumentid() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Docflow.DocumentInfo.CustomDocumentId)
  return *customdocumentid_;
}
inline void DocumentInfo::set_customdocumentid(const ::std::string& value) {
  set_has_customdocumentid();
  if (customdocumentid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    customdocumentid_ = new ::std::string;
  }
  customdocumentid_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Docflow.DocumentInfo.CustomDocumentId)
}
inline void DocumentInfo::set_customdocumentid(const char* value) {
  set_has_customdocumentid();
  if (customdocumentid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    customdocumentid_ = new ::std::string;
  }
  customdocumentid_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Docflow.DocumentInfo.CustomDocumentId)
}
inline void DocumentInfo::set_customdocumentid(const char* value, size_t size) {
  set_has_customdocumentid();
  if (customdocumentid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    customdocumentid_ = new ::std::string;
  }
  customdocumentid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Docflow.DocumentInfo.CustomDocumentId)
}
inline ::std::string* DocumentInfo::mutable_customdocumentid() {
  set_has_customdocumentid();
  if (customdocumentid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    customdocumentid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Docflow.DocumentInfo.CustomDocumentId)
  return customdocumentid_;
}
inline ::std::string* DocumentInfo::release_customdocumentid() {
  clear_has_customdocumentid();
  if (customdocumentid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = customdocumentid_;
    customdocumentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void DocumentInfo::set_allocated_customdocumentid(::std::string* customdocumentid) {
  if (customdocumentid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete customdocumentid_;
  }
  if (customdocumentid) {
    set_has_customdocumentid();
    customdocumentid_ = customdocumentid;
  } else {
    clear_has_customdocumentid();
    customdocumentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Docflow.DocumentInfo.CustomDocumentId)
}

// optional string FromDepartmentId = 5;
inline bool DocumentInfo::has_fromdepartmentid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DocumentInfo::set_has_fromdepartmentid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DocumentInfo::clear_has_fromdepartmentid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DocumentInfo::clear_fromdepartmentid() {
  if (fromdepartmentid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fromdepartmentid_->clear();
  }
  clear_has_fromdepartmentid();
}
inline const ::std::string& DocumentInfo::fromdepartmentid() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Docflow.DocumentInfo.FromDepartmentId)
  return *fromdepartmentid_;
}
inline void DocumentInfo::set_fromdepartmentid(const ::std::string& value) {
  set_has_fromdepartmentid();
  if (fromdepartmentid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fromdepartmentid_ = new ::std::string;
  }
  fromdepartmentid_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Docflow.DocumentInfo.FromDepartmentId)
}
inline void DocumentInfo::set_fromdepartmentid(const char* value) {
  set_has_fromdepartmentid();
  if (fromdepartmentid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fromdepartmentid_ = new ::std::string;
  }
  fromdepartmentid_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Docflow.DocumentInfo.FromDepartmentId)
}
inline void DocumentInfo::set_fromdepartmentid(const char* value, size_t size) {
  set_has_fromdepartmentid();
  if (fromdepartmentid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fromdepartmentid_ = new ::std::string;
  }
  fromdepartmentid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Docflow.DocumentInfo.FromDepartmentId)
}
inline ::std::string* DocumentInfo::mutable_fromdepartmentid() {
  set_has_fromdepartmentid();
  if (fromdepartmentid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fromdepartmentid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Docflow.DocumentInfo.FromDepartmentId)
  return fromdepartmentid_;
}
inline ::std::string* DocumentInfo::release_fromdepartmentid() {
  clear_has_fromdepartmentid();
  if (fromdepartmentid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = fromdepartmentid_;
    fromdepartmentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void DocumentInfo::set_allocated_fromdepartmentid(::std::string* fromdepartmentid) {
  if (fromdepartmentid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete fromdepartmentid_;
  }
  if (fromdepartmentid) {
    set_has_fromdepartmentid();
    fromdepartmentid_ = fromdepartmentid;
  } else {
    clear_has_fromdepartmentid();
    fromdepartmentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Docflow.DocumentInfo.FromDepartmentId)
}

// optional string ToDepartmentId = 6;
inline bool DocumentInfo::has_todepartmentid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DocumentInfo::set_has_todepartmentid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void DocumentInfo::clear_has_todepartmentid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void DocumentInfo::clear_todepartmentid() {
  if (todepartmentid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    todepartmentid_->clear();
  }
  clear_has_todepartmentid();
}
inline const ::std::string& DocumentInfo::todepartmentid() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Docflow.DocumentInfo.ToDepartmentId)
  return *todepartmentid_;
}
inline void DocumentInfo::set_todepartmentid(const ::std::string& value) {
  set_has_todepartmentid();
  if (todepartmentid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    todepartmentid_ = new ::std::string;
  }
  todepartmentid_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Docflow.DocumentInfo.ToDepartmentId)
}
inline void DocumentInfo::set_todepartmentid(const char* value) {
  set_has_todepartmentid();
  if (todepartmentid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    todepartmentid_ = new ::std::string;
  }
  todepartmentid_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Docflow.DocumentInfo.ToDepartmentId)
}
inline void DocumentInfo::set_todepartmentid(const char* value, size_t size) {
  set_has_todepartmentid();
  if (todepartmentid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    todepartmentid_ = new ::std::string;
  }
  todepartmentid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Docflow.DocumentInfo.ToDepartmentId)
}
inline ::std::string* DocumentInfo::mutable_todepartmentid() {
  set_has_todepartmentid();
  if (todepartmentid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    todepartmentid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Docflow.DocumentInfo.ToDepartmentId)
  return todepartmentid_;
}
inline ::std::string* DocumentInfo::release_todepartmentid() {
  clear_has_todepartmentid();
  if (todepartmentid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = todepartmentid_;
    todepartmentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void DocumentInfo::set_allocated_todepartmentid(::std::string* todepartmentid) {
  if (todepartmentid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete todepartmentid_;
  }
  if (todepartmentid) {
    set_has_todepartmentid();
    todepartmentid_ = todepartmentid;
  } else {
    clear_has_todepartmentid();
    todepartmentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Docflow.DocumentInfo.ToDepartmentId)
}

// optional string CounteragentBoxId = 7;
inline bool DocumentInfo::has_counteragentboxid() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void DocumentInfo::set_has_counteragentboxid() {
  _has_bits_[0] |= 0x00000040u;
}
inline void DocumentInfo::clear_has_counteragentboxid() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void DocumentInfo::clear_counteragentboxid() {
  if (counteragentboxid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    counteragentboxid_->clear();
  }
  clear_has_counteragentboxid();
}
inline const ::std::string& DocumentInfo::counteragentboxid() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Docflow.DocumentInfo.CounteragentBoxId)
  return *counteragentboxid_;
}
inline void DocumentInfo::set_counteragentboxid(const ::std::string& value) {
  set_has_counteragentboxid();
  if (counteragentboxid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    counteragentboxid_ = new ::std::string;
  }
  counteragentboxid_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Docflow.DocumentInfo.CounteragentBoxId)
}
inline void DocumentInfo::set_counteragentboxid(const char* value) {
  set_has_counteragentboxid();
  if (counteragentboxid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    counteragentboxid_ = new ::std::string;
  }
  counteragentboxid_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Docflow.DocumentInfo.CounteragentBoxId)
}
inline void DocumentInfo::set_counteragentboxid(const char* value, size_t size) {
  set_has_counteragentboxid();
  if (counteragentboxid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    counteragentboxid_ = new ::std::string;
  }
  counteragentboxid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Docflow.DocumentInfo.CounteragentBoxId)
}
inline ::std::string* DocumentInfo::mutable_counteragentboxid() {
  set_has_counteragentboxid();
  if (counteragentboxid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    counteragentboxid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Docflow.DocumentInfo.CounteragentBoxId)
  return counteragentboxid_;
}
inline ::std::string* DocumentInfo::release_counteragentboxid() {
  clear_has_counteragentboxid();
  if (counteragentboxid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = counteragentboxid_;
    counteragentboxid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void DocumentInfo::set_allocated_counteragentboxid(::std::string* counteragentboxid) {
  if (counteragentboxid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete counteragentboxid_;
  }
  if (counteragentboxid) {
    set_has_counteragentboxid();
    counteragentboxid_ = counteragentboxid;
  } else {
    clear_has_counteragentboxid();
    counteragentboxid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Docflow.DocumentInfo.CounteragentBoxId)
}

// optional .Diadoc.Api.Proto.Docflow.DocumentDateAndNumber DocumentDateAndNumber = 8;
inline bool DocumentInfo::has_documentdateandnumber() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void DocumentInfo::set_has_documentdateandnumber() {
  _has_bits_[0] |= 0x00000080u;
}
inline void DocumentInfo::clear_has_documentdateandnumber() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void DocumentInfo::clear_documentdateandnumber() {
  if (documentdateandnumber_ != NULL) documentdateandnumber_->::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber::Clear();
  clear_has_documentdateandnumber();
}
inline const ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber& DocumentInfo::documentdateandnumber() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Docflow.DocumentInfo.DocumentDateAndNumber)
  return documentdateandnumber_ != NULL ? *documentdateandnumber_ : *default_instance_->documentdateandnumber_;
}
inline ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber* DocumentInfo::mutable_documentdateandnumber() {
  set_has_documentdateandnumber();
  if (documentdateandnumber_ == NULL) documentdateandnumber_ = new ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber;
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Docflow.DocumentInfo.DocumentDateAndNumber)
  return documentdateandnumber_;
}
inline ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber* DocumentInfo::release_documentdateandnumber() {
  clear_has_documentdateandnumber();
  ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber* temp = documentdateandnumber_;
  documentdateandnumber_ = NULL;
  return temp;
}
inline void DocumentInfo::set_allocated_documentdateandnumber(::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber* documentdateandnumber) {
  delete documentdateandnumber_;
  documentdateandnumber_ = documentdateandnumber;
  if (documentdateandnumber) {
    set_has_documentdateandnumber();
  } else {
    clear_has_documentdateandnumber();
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Docflow.DocumentInfo.DocumentDateAndNumber)
}

// optional .Diadoc.Api.Proto.Docflow.BasicDocumentInfo BasicDocumentInfo = 9;
inline bool DocumentInfo::has_basicdocumentinfo() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void DocumentInfo::set_has_basicdocumentinfo() {
  _has_bits_[0] |= 0x00000100u;
}
inline void DocumentInfo::clear_has_basicdocumentinfo() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void DocumentInfo::clear_basicdocumentinfo() {
  if (basicdocumentinfo_ != NULL) basicdocumentinfo_->::Diadoc::Api::Proto::Docflow::BasicDocumentInfo::Clear();
  clear_has_basicdocumentinfo();
}
inline const ::Diadoc::Api::Proto::Docflow::BasicDocumentInfo& DocumentInfo::basicdocumentinfo() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Docflow.DocumentInfo.BasicDocumentInfo)
  return basicdocumentinfo_ != NULL ? *basicdocumentinfo_ : *default_instance_->basicdocumentinfo_;
}
inline ::Diadoc::Api::Proto::Docflow::BasicDocumentInfo* DocumentInfo::mutable_basicdocumentinfo() {
  set_has_basicdocumentinfo();
  if (basicdocumentinfo_ == NULL) basicdocumentinfo_ = new ::Diadoc::Api::Proto::Docflow::BasicDocumentInfo;
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Docflow.DocumentInfo.BasicDocumentInfo)
  return basicdocumentinfo_;
}
inline ::Diadoc::Api::Proto::Docflow::BasicDocumentInfo* DocumentInfo::release_basicdocumentinfo() {
  clear_has_basicdocumentinfo();
  ::Diadoc::Api::Proto::Docflow::BasicDocumentInfo* temp = basicdocumentinfo_;
  basicdocumentinfo_ = NULL;
  return temp;
}
inline void DocumentInfo::set_allocated_basicdocumentinfo(::Diadoc::Api::Proto::Docflow::BasicDocumentInfo* basicdocumentinfo) {
  delete basicdocumentinfo_;
  basicdocumentinfo_ = basicdocumentinfo;
  if (basicdocumentinfo) {
    set_has_basicdocumentinfo();
  } else {
    clear_has_basicdocumentinfo();
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Docflow.DocumentInfo.BasicDocumentInfo)
}

// optional .Diadoc.Api.Proto.Docflow.InvoiceDocumentInfo InvoiceInfo = 10;
inline bool DocumentInfo::has_invoiceinfo() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void DocumentInfo::set_has_invoiceinfo() {
  _has_bits_[0] |= 0x00000200u;
}
inline void DocumentInfo::clear_has_invoiceinfo() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void DocumentInfo::clear_invoiceinfo() {
  if (invoiceinfo_ != NULL) invoiceinfo_->::Diadoc::Api::Proto::Docflow::InvoiceDocumentInfo::Clear();
  clear_has_invoiceinfo();
}
inline const ::Diadoc::Api::Proto::Docflow::InvoiceDocumentInfo& DocumentInfo::invoiceinfo() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Docflow.DocumentInfo.InvoiceInfo)
  return invoiceinfo_ != NULL ? *invoiceinfo_ : *default_instance_->invoiceinfo_;
}
inline ::Diadoc::Api::Proto::Docflow::InvoiceDocumentInfo* DocumentInfo::mutable_invoiceinfo() {
  set_has_invoiceinfo();
  if (invoiceinfo_ == NULL) invoiceinfo_ = new ::Diadoc::Api::Proto::Docflow::InvoiceDocumentInfo;
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Docflow.DocumentInfo.InvoiceInfo)
  return invoiceinfo_;
}
inline ::Diadoc::Api::Proto::Docflow::InvoiceDocumentInfo* DocumentInfo::release_invoiceinfo() {
  clear_has_invoiceinfo();
  ::Diadoc::Api::Proto::Docflow::InvoiceDocumentInfo* temp = invoiceinfo_;
  invoiceinfo_ = NULL;
  return temp;
}
inline void DocumentInfo::set_allocated_invoiceinfo(::Diadoc::Api::Proto::Docflow::InvoiceDocumentInfo* invoiceinfo) {
  delete invoiceinfo_;
  invoiceinfo_ = invoiceinfo;
  if (invoiceinfo) {
    set_has_invoiceinfo();
  } else {
    clear_has_invoiceinfo();
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Docflow.DocumentInfo.InvoiceInfo)
}

// optional .Diadoc.Api.Proto.Docflow.InvoiceCorrectionDocumentInfo InvoiceCorrectionInfo = 11;
inline bool DocumentInfo::has_invoicecorrectioninfo() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void DocumentInfo::set_has_invoicecorrectioninfo() {
  _has_bits_[0] |= 0x00000400u;
}
inline void DocumentInfo::clear_has_invoicecorrectioninfo() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void DocumentInfo::clear_invoicecorrectioninfo() {
  if (invoicecorrectioninfo_ != NULL) invoicecorrectioninfo_->::Diadoc::Api::Proto::Docflow::InvoiceCorrectionDocumentInfo::Clear();
  clear_has_invoicecorrectioninfo();
}
inline const ::Diadoc::Api::Proto::Docflow::InvoiceCorrectionDocumentInfo& DocumentInfo::invoicecorrectioninfo() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Docflow.DocumentInfo.InvoiceCorrectionInfo)
  return invoicecorrectioninfo_ != NULL ? *invoicecorrectioninfo_ : *default_instance_->invoicecorrectioninfo_;
}
inline ::Diadoc::Api::Proto::Docflow::InvoiceCorrectionDocumentInfo* DocumentInfo::mutable_invoicecorrectioninfo() {
  set_has_invoicecorrectioninfo();
  if (invoicecorrectioninfo_ == NULL) invoicecorrectioninfo_ = new ::Diadoc::Api::Proto::Docflow::InvoiceCorrectionDocumentInfo;
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Docflow.DocumentInfo.InvoiceCorrectionInfo)
  return invoicecorrectioninfo_;
}
inline ::Diadoc::Api::Proto::Docflow::InvoiceCorrectionDocumentInfo* DocumentInfo::release_invoicecorrectioninfo() {
  clear_has_invoicecorrectioninfo();
  ::Diadoc::Api::Proto::Docflow::InvoiceCorrectionDocumentInfo* temp = invoicecorrectioninfo_;
  invoicecorrectioninfo_ = NULL;
  return temp;
}
inline void DocumentInfo::set_allocated_invoicecorrectioninfo(::Diadoc::Api::Proto::Docflow::InvoiceCorrectionDocumentInfo* invoicecorrectioninfo) {
  delete invoicecorrectioninfo_;
  invoicecorrectioninfo_ = invoicecorrectioninfo;
  if (invoicecorrectioninfo) {
    set_has_invoicecorrectioninfo();
  } else {
    clear_has_invoicecorrectioninfo();
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Docflow.DocumentInfo.InvoiceCorrectionInfo)
}

// optional .Diadoc.Api.Proto.Docflow.PriceListDocumentInfo PriceListInfo = 12;
inline bool DocumentInfo::has_pricelistinfo() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void DocumentInfo::set_has_pricelistinfo() {
  _has_bits_[0] |= 0x00000800u;
}
inline void DocumentInfo::clear_has_pricelistinfo() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void DocumentInfo::clear_pricelistinfo() {
  if (pricelistinfo_ != NULL) pricelistinfo_->::Diadoc::Api::Proto::Docflow::PriceListDocumentInfo::Clear();
  clear_has_pricelistinfo();
}
inline const ::Diadoc::Api::Proto::Docflow::PriceListDocumentInfo& DocumentInfo::pricelistinfo() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Docflow.DocumentInfo.PriceListInfo)
  return pricelistinfo_ != NULL ? *pricelistinfo_ : *default_instance_->pricelistinfo_;
}
inline ::Diadoc::Api::Proto::Docflow::PriceListDocumentInfo* DocumentInfo::mutable_pricelistinfo() {
  set_has_pricelistinfo();
  if (pricelistinfo_ == NULL) pricelistinfo_ = new ::Diadoc::Api::Proto::Docflow::PriceListDocumentInfo;
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Docflow.DocumentInfo.PriceListInfo)
  return pricelistinfo_;
}
inline ::Diadoc::Api::Proto::Docflow::PriceListDocumentInfo* DocumentInfo::release_pricelistinfo() {
  clear_has_pricelistinfo();
  ::Diadoc::Api::Proto::Docflow::PriceListDocumentInfo* temp = pricelistinfo_;
  pricelistinfo_ = NULL;
  return temp;
}
inline void DocumentInfo::set_allocated_pricelistinfo(::Diadoc::Api::Proto::Docflow::PriceListDocumentInfo* pricelistinfo) {
  delete pricelistinfo_;
  pricelistinfo_ = pricelistinfo;
  if (pricelistinfo) {
    set_has_pricelistinfo();
  } else {
    clear_has_pricelistinfo();
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Docflow.DocumentInfo.PriceListInfo)
}

// optional .Diadoc.Api.Proto.Docflow.ContractDocumentInfo ContractInfo = 13;
inline bool DocumentInfo::has_contractinfo() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void DocumentInfo::set_has_contractinfo() {
  _has_bits_[0] |= 0x00001000u;
}
inline void DocumentInfo::clear_has_contractinfo() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void DocumentInfo::clear_contractinfo() {
  if (contractinfo_ != NULL) contractinfo_->::Diadoc::Api::Proto::Docflow::ContractDocumentInfo::Clear();
  clear_has_contractinfo();
}
inline const ::Diadoc::Api::Proto::Docflow::ContractDocumentInfo& DocumentInfo::contractinfo() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Docflow.DocumentInfo.ContractInfo)
  return contractinfo_ != NULL ? *contractinfo_ : *default_instance_->contractinfo_;
}
inline ::Diadoc::Api::Proto::Docflow::ContractDocumentInfo* DocumentInfo::mutable_contractinfo() {
  set_has_contractinfo();
  if (contractinfo_ == NULL) contractinfo_ = new ::Diadoc::Api::Proto::Docflow::ContractDocumentInfo;
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Docflow.DocumentInfo.ContractInfo)
  return contractinfo_;
}
inline ::Diadoc::Api::Proto::Docflow::ContractDocumentInfo* DocumentInfo::release_contractinfo() {
  clear_has_contractinfo();
  ::Diadoc::Api::Proto::Docflow::ContractDocumentInfo* temp = contractinfo_;
  contractinfo_ = NULL;
  return temp;
}
inline void DocumentInfo::set_allocated_contractinfo(::Diadoc::Api::Proto::Docflow::ContractDocumentInfo* contractinfo) {
  delete contractinfo_;
  contractinfo_ = contractinfo;
  if (contractinfo) {
    set_has_contractinfo();
  } else {
    clear_has_contractinfo();
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Docflow.DocumentInfo.ContractInfo)
}

// optional .Diadoc.Api.Proto.Docflow.SupplementaryAgreementDocumentInfo SupplementaryAgreementInfo = 14;
inline bool DocumentInfo::has_supplementaryagreementinfo() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void DocumentInfo::set_has_supplementaryagreementinfo() {
  _has_bits_[0] |= 0x00002000u;
}
inline void DocumentInfo::clear_has_supplementaryagreementinfo() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void DocumentInfo::clear_supplementaryagreementinfo() {
  if (supplementaryagreementinfo_ != NULL) supplementaryagreementinfo_->::Diadoc::Api::Proto::Docflow::SupplementaryAgreementDocumentInfo::Clear();
  clear_has_supplementaryagreementinfo();
}
inline const ::Diadoc::Api::Proto::Docflow::SupplementaryAgreementDocumentInfo& DocumentInfo::supplementaryagreementinfo() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Docflow.DocumentInfo.SupplementaryAgreementInfo)
  return supplementaryagreementinfo_ != NULL ? *supplementaryagreementinfo_ : *default_instance_->supplementaryagreementinfo_;
}
inline ::Diadoc::Api::Proto::Docflow::SupplementaryAgreementDocumentInfo* DocumentInfo::mutable_supplementaryagreementinfo() {
  set_has_supplementaryagreementinfo();
  if (supplementaryagreementinfo_ == NULL) supplementaryagreementinfo_ = new ::Diadoc::Api::Proto::Docflow::SupplementaryAgreementDocumentInfo;
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Docflow.DocumentInfo.SupplementaryAgreementInfo)
  return supplementaryagreementinfo_;
}
inline ::Diadoc::Api::Proto::Docflow::SupplementaryAgreementDocumentInfo* DocumentInfo::release_supplementaryagreementinfo() {
  clear_has_supplementaryagreementinfo();
  ::Diadoc::Api::Proto::Docflow::SupplementaryAgreementDocumentInfo* temp = supplementaryagreementinfo_;
  supplementaryagreementinfo_ = NULL;
  return temp;
}
inline void DocumentInfo::set_allocated_supplementaryagreementinfo(::Diadoc::Api::Proto::Docflow::SupplementaryAgreementDocumentInfo* supplementaryagreementinfo) {
  delete supplementaryagreementinfo_;
  supplementaryagreementinfo_ = supplementaryagreementinfo;
  if (supplementaryagreementinfo) {
    set_has_supplementaryagreementinfo();
  } else {
    clear_has_supplementaryagreementinfo();
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Docflow.DocumentInfo.SupplementaryAgreementInfo)
}

// optional .Diadoc.Api.Proto.Docflow.UniversalTransferDocumentInfo UniversalTransferDocumentInfo = 15;
inline bool DocumentInfo::has_universaltransferdocumentinfo() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void DocumentInfo::set_has_universaltransferdocumentinfo() {
  _has_bits_[0] |= 0x00004000u;
}
inline void DocumentInfo::clear_has_universaltransferdocumentinfo() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void DocumentInfo::clear_universaltransferdocumentinfo() {
  if (universaltransferdocumentinfo_ != NULL) universaltransferdocumentinfo_->::Diadoc::Api::Proto::Docflow::UniversalTransferDocumentInfo::Clear();
  clear_has_universaltransferdocumentinfo();
}
inline const ::Diadoc::Api::Proto::Docflow::UniversalTransferDocumentInfo& DocumentInfo::universaltransferdocumentinfo() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Docflow.DocumentInfo.UniversalTransferDocumentInfo)
  return universaltransferdocumentinfo_ != NULL ? *universaltransferdocumentinfo_ : *default_instance_->universaltransferdocumentinfo_;
}
inline ::Diadoc::Api::Proto::Docflow::UniversalTransferDocumentInfo* DocumentInfo::mutable_universaltransferdocumentinfo() {
  set_has_universaltransferdocumentinfo();
  if (universaltransferdocumentinfo_ == NULL) universaltransferdocumentinfo_ = new ::Diadoc::Api::Proto::Docflow::UniversalTransferDocumentInfo;
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Docflow.DocumentInfo.UniversalTransferDocumentInfo)
  return universaltransferdocumentinfo_;
}
inline ::Diadoc::Api::Proto::Docflow::UniversalTransferDocumentInfo* DocumentInfo::release_universaltransferdocumentinfo() {
  clear_has_universaltransferdocumentinfo();
  ::Diadoc::Api::Proto::Docflow::UniversalTransferDocumentInfo* temp = universaltransferdocumentinfo_;
  universaltransferdocumentinfo_ = NULL;
  return temp;
}
inline void DocumentInfo::set_allocated_universaltransferdocumentinfo(::Diadoc::Api::Proto::Docflow::UniversalTransferDocumentInfo* universaltransferdocumentinfo) {
  delete universaltransferdocumentinfo_;
  universaltransferdocumentinfo_ = universaltransferdocumentinfo;
  if (universaltransferdocumentinfo) {
    set_has_universaltransferdocumentinfo();
  } else {
    clear_has_universaltransferdocumentinfo();
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Docflow.DocumentInfo.UniversalTransferDocumentInfo)
}

// optional .Diadoc.Api.Proto.Docflow.UniversalCorrectionDocumentInfo UniversalCorrectionDocumentInfo = 16;
inline bool DocumentInfo::has_universalcorrectiondocumentinfo() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void DocumentInfo::set_has_universalcorrectiondocumentinfo() {
  _has_bits_[0] |= 0x00008000u;
}
inline void DocumentInfo::clear_has_universalcorrectiondocumentinfo() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void DocumentInfo::clear_universalcorrectiondocumentinfo() {
  if (universalcorrectiondocumentinfo_ != NULL) universalcorrectiondocumentinfo_->::Diadoc::Api::Proto::Docflow::UniversalCorrectionDocumentInfo::Clear();
  clear_has_universalcorrectiondocumentinfo();
}
inline const ::Diadoc::Api::Proto::Docflow::UniversalCorrectionDocumentInfo& DocumentInfo::universalcorrectiondocumentinfo() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Docflow.DocumentInfo.UniversalCorrectionDocumentInfo)
  return universalcorrectiondocumentinfo_ != NULL ? *universalcorrectiondocumentinfo_ : *default_instance_->universalcorrectiondocumentinfo_;
}
inline ::Diadoc::Api::Proto::Docflow::UniversalCorrectionDocumentInfo* DocumentInfo::mutable_universalcorrectiondocumentinfo() {
  set_has_universalcorrectiondocumentinfo();
  if (universalcorrectiondocumentinfo_ == NULL) universalcorrectiondocumentinfo_ = new ::Diadoc::Api::Proto::Docflow::UniversalCorrectionDocumentInfo;
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Docflow.DocumentInfo.UniversalCorrectionDocumentInfo)
  return universalcorrectiondocumentinfo_;
}
inline ::Diadoc::Api::Proto::Docflow::UniversalCorrectionDocumentInfo* DocumentInfo::release_universalcorrectiondocumentinfo() {
  clear_has_universalcorrectiondocumentinfo();
  ::Diadoc::Api::Proto::Docflow::UniversalCorrectionDocumentInfo* temp = universalcorrectiondocumentinfo_;
  universalcorrectiondocumentinfo_ = NULL;
  return temp;
}
inline void DocumentInfo::set_allocated_universalcorrectiondocumentinfo(::Diadoc::Api::Proto::Docflow::UniversalCorrectionDocumentInfo* universalcorrectiondocumentinfo) {
  delete universalcorrectiondocumentinfo_;
  universalcorrectiondocumentinfo_ = universalcorrectiondocumentinfo;
  if (universalcorrectiondocumentinfo) {
    set_has_universalcorrectiondocumentinfo();
  } else {
    clear_has_universalcorrectiondocumentinfo();
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Docflow.DocumentInfo.UniversalCorrectionDocumentInfo)
}

// optional string AttachmentVersion = 17;
inline bool DocumentInfo::has_attachmentversion() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void DocumentInfo::set_has_attachmentversion() {
  _has_bits_[0] |= 0x00010000u;
}
inline void DocumentInfo::clear_has_attachmentversion() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void DocumentInfo::clear_attachmentversion() {
  if (attachmentversion_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attachmentversion_->clear();
  }
  clear_has_attachmentversion();
}
inline const ::std::string& DocumentInfo::attachmentversion() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Docflow.DocumentInfo.AttachmentVersion)
  return *attachmentversion_;
}
inline void DocumentInfo::set_attachmentversion(const ::std::string& value) {
  set_has_attachmentversion();
  if (attachmentversion_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attachmentversion_ = new ::std::string;
  }
  attachmentversion_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Docflow.DocumentInfo.AttachmentVersion)
}
inline void DocumentInfo::set_attachmentversion(const char* value) {
  set_has_attachmentversion();
  if (attachmentversion_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attachmentversion_ = new ::std::string;
  }
  attachmentversion_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Docflow.DocumentInfo.AttachmentVersion)
}
inline void DocumentInfo::set_attachmentversion(const char* value, size_t size) {
  set_has_attachmentversion();
  if (attachmentversion_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attachmentversion_ = new ::std::string;
  }
  attachmentversion_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Docflow.DocumentInfo.AttachmentVersion)
}
inline ::std::string* DocumentInfo::mutable_attachmentversion() {
  set_has_attachmentversion();
  if (attachmentversion_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attachmentversion_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Docflow.DocumentInfo.AttachmentVersion)
  return attachmentversion_;
}
inline ::std::string* DocumentInfo::release_attachmentversion() {
  clear_has_attachmentversion();
  if (attachmentversion_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attachmentversion_;
    attachmentversion_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void DocumentInfo::set_allocated_attachmentversion(::std::string* attachmentversion) {
  if (attachmentversion_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attachmentversion_;
  }
  if (attachmentversion) {
    set_has_attachmentversion();
    attachmentversion_ = attachmentversion;
  } else {
    clear_has_attachmentversion();
    attachmentversion_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Docflow.DocumentInfo.AttachmentVersion)
}

// required string Version = 18;
inline bool DocumentInfo::has_version() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void DocumentInfo::set_has_version() {
  _has_bits_[0] |= 0x00020000u;
}
inline void DocumentInfo::clear_has_version() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void DocumentInfo::clear_version() {
  if (version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& DocumentInfo::version() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Docflow.DocumentInfo.Version)
  return *version_;
}
inline void DocumentInfo::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    version_ = new ::std::string;
  }
  version_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Docflow.DocumentInfo.Version)
}
inline void DocumentInfo::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    version_ = new ::std::string;
  }
  version_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Docflow.DocumentInfo.Version)
}
inline void DocumentInfo::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Docflow.DocumentInfo.Version)
}
inline ::std::string* DocumentInfo::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    version_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Docflow.DocumentInfo.Version)
  return version_;
}
inline ::std::string* DocumentInfo::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void DocumentInfo::set_allocated_version(::std::string* version) {
  if (version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete version_;
  }
  if (version) {
    set_has_version();
    version_ = version;
  } else {
    clear_has_version();
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Docflow.DocumentInfo.Version)
}

// -------------------------------------------------------------------

// DocumentDateAndNumber

// optional string DocumentDate = 1;
inline bool DocumentDateAndNumber::has_documentdate() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DocumentDateAndNumber::set_has_documentdate() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DocumentDateAndNumber::clear_has_documentdate() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DocumentDateAndNumber::clear_documentdate() {
  if (documentdate_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    documentdate_->clear();
  }
  clear_has_documentdate();
}
inline const ::std::string& DocumentDateAndNumber::documentdate() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Docflow.DocumentDateAndNumber.DocumentDate)
  return *documentdate_;
}
inline void DocumentDateAndNumber::set_documentdate(const ::std::string& value) {
  set_has_documentdate();
  if (documentdate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    documentdate_ = new ::std::string;
  }
  documentdate_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Docflow.DocumentDateAndNumber.DocumentDate)
}
inline void DocumentDateAndNumber::set_documentdate(const char* value) {
  set_has_documentdate();
  if (documentdate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    documentdate_ = new ::std::string;
  }
  documentdate_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Docflow.DocumentDateAndNumber.DocumentDate)
}
inline void DocumentDateAndNumber::set_documentdate(const char* value, size_t size) {
  set_has_documentdate();
  if (documentdate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    documentdate_ = new ::std::string;
  }
  documentdate_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Docflow.DocumentDateAndNumber.DocumentDate)
}
inline ::std::string* DocumentDateAndNumber::mutable_documentdate() {
  set_has_documentdate();
  if (documentdate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    documentdate_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Docflow.DocumentDateAndNumber.DocumentDate)
  return documentdate_;
}
inline ::std::string* DocumentDateAndNumber::release_documentdate() {
  clear_has_documentdate();
  if (documentdate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = documentdate_;
    documentdate_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void DocumentDateAndNumber::set_allocated_documentdate(::std::string* documentdate) {
  if (documentdate_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete documentdate_;
  }
  if (documentdate) {
    set_has_documentdate();
    documentdate_ = documentdate;
  } else {
    clear_has_documentdate();
    documentdate_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Docflow.DocumentDateAndNumber.DocumentDate)
}

// optional string DocumentNumber = 2;
inline bool DocumentDateAndNumber::has_documentnumber() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DocumentDateAndNumber::set_has_documentnumber() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DocumentDateAndNumber::clear_has_documentnumber() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DocumentDateAndNumber::clear_documentnumber() {
  if (documentnumber_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    documentnumber_->clear();
  }
  clear_has_documentnumber();
}
inline const ::std::string& DocumentDateAndNumber::documentnumber() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Docflow.DocumentDateAndNumber.DocumentNumber)
  return *documentnumber_;
}
inline void DocumentDateAndNumber::set_documentnumber(const ::std::string& value) {
  set_has_documentnumber();
  if (documentnumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    documentnumber_ = new ::std::string;
  }
  documentnumber_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Docflow.DocumentDateAndNumber.DocumentNumber)
}
inline void DocumentDateAndNumber::set_documentnumber(const char* value) {
  set_has_documentnumber();
  if (documentnumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    documentnumber_ = new ::std::string;
  }
  documentnumber_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Docflow.DocumentDateAndNumber.DocumentNumber)
}
inline void DocumentDateAndNumber::set_documentnumber(const char* value, size_t size) {
  set_has_documentnumber();
  if (documentnumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    documentnumber_ = new ::std::string;
  }
  documentnumber_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Docflow.DocumentDateAndNumber.DocumentNumber)
}
inline ::std::string* DocumentDateAndNumber::mutable_documentnumber() {
  set_has_documentnumber();
  if (documentnumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    documentnumber_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Docflow.DocumentDateAndNumber.DocumentNumber)
  return documentnumber_;
}
inline ::std::string* DocumentDateAndNumber::release_documentnumber() {
  clear_has_documentnumber();
  if (documentnumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = documentnumber_;
    documentnumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void DocumentDateAndNumber::set_allocated_documentnumber(::std::string* documentnumber) {
  if (documentnumber_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete documentnumber_;
  }
  if (documentnumber) {
    set_has_documentnumber();
    documentnumber_ = documentnumber;
  } else {
    clear_has_documentnumber();
    documentnumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Docflow.DocumentDateAndNumber.DocumentNumber)
}

// -------------------------------------------------------------------

// BasicDocumentInfo

// optional string Total = 1;
inline bool BasicDocumentInfo::has_total() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BasicDocumentInfo::set_has_total() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BasicDocumentInfo::clear_has_total() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BasicDocumentInfo::clear_total() {
  if (total_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    total_->clear();
  }
  clear_has_total();
}
inline const ::std::string& BasicDocumentInfo::total() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Docflow.BasicDocumentInfo.Total)
  return *total_;
}
inline void BasicDocumentInfo::set_total(const ::std::string& value) {
  set_has_total();
  if (total_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    total_ = new ::std::string;
  }
  total_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Docflow.BasicDocumentInfo.Total)
}
inline void BasicDocumentInfo::set_total(const char* value) {
  set_has_total();
  if (total_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    total_ = new ::std::string;
  }
  total_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Docflow.BasicDocumentInfo.Total)
}
inline void BasicDocumentInfo::set_total(const char* value, size_t size) {
  set_has_total();
  if (total_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    total_ = new ::std::string;
  }
  total_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Docflow.BasicDocumentInfo.Total)
}
inline ::std::string* BasicDocumentInfo::mutable_total() {
  set_has_total();
  if (total_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    total_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Docflow.BasicDocumentInfo.Total)
  return total_;
}
inline ::std::string* BasicDocumentInfo::release_total() {
  clear_has_total();
  if (total_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = total_;
    total_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void BasicDocumentInfo::set_allocated_total(::std::string* total) {
  if (total_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete total_;
  }
  if (total) {
    set_has_total();
    total_ = total;
  } else {
    clear_has_total();
    total_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Docflow.BasicDocumentInfo.Total)
}

// optional bool NoVat = 2;
inline bool BasicDocumentInfo::has_novat() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BasicDocumentInfo::set_has_novat() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BasicDocumentInfo::clear_has_novat() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BasicDocumentInfo::clear_novat() {
  novat_ = false;
  clear_has_novat();
}
inline bool BasicDocumentInfo::novat() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Docflow.BasicDocumentInfo.NoVat)
  return novat_;
}
inline void BasicDocumentInfo::set_novat(bool value) {
  set_has_novat();
  novat_ = value;
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Docflow.BasicDocumentInfo.NoVat)
}

// optional string Vat = 3;
inline bool BasicDocumentInfo::has_vat() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BasicDocumentInfo::set_has_vat() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BasicDocumentInfo::clear_has_vat() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BasicDocumentInfo::clear_vat() {
  if (vat_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vat_->clear();
  }
  clear_has_vat();
}
inline const ::std::string& BasicDocumentInfo::vat() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Docflow.BasicDocumentInfo.Vat)
  return *vat_;
}
inline void BasicDocumentInfo::set_vat(const ::std::string& value) {
  set_has_vat();
  if (vat_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vat_ = new ::std::string;
  }
  vat_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Docflow.BasicDocumentInfo.Vat)
}
inline void BasicDocumentInfo::set_vat(const char* value) {
  set_has_vat();
  if (vat_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vat_ = new ::std::string;
  }
  vat_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Docflow.BasicDocumentInfo.Vat)
}
inline void BasicDocumentInfo::set_vat(const char* value, size_t size) {
  set_has_vat();
  if (vat_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vat_ = new ::std::string;
  }
  vat_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Docflow.BasicDocumentInfo.Vat)
}
inline ::std::string* BasicDocumentInfo::mutable_vat() {
  set_has_vat();
  if (vat_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vat_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Docflow.BasicDocumentInfo.Vat)
  return vat_;
}
inline ::std::string* BasicDocumentInfo::release_vat() {
  clear_has_vat();
  if (vat_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = vat_;
    vat_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void BasicDocumentInfo::set_allocated_vat(::std::string* vat) {
  if (vat_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete vat_;
  }
  if (vat) {
    set_has_vat();
    vat_ = vat;
  } else {
    clear_has_vat();
    vat_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Docflow.BasicDocumentInfo.Vat)
}

// optional string Grounds = 4;
inline bool BasicDocumentInfo::has_grounds() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BasicDocumentInfo::set_has_grounds() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BasicDocumentInfo::clear_has_grounds() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BasicDocumentInfo::clear_grounds() {
  if (grounds_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    grounds_->clear();
  }
  clear_has_grounds();
}
inline const ::std::string& BasicDocumentInfo::grounds() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Docflow.BasicDocumentInfo.Grounds)
  return *grounds_;
}
inline void BasicDocumentInfo::set_grounds(const ::std::string& value) {
  set_has_grounds();
  if (grounds_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    grounds_ = new ::std::string;
  }
  grounds_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Docflow.BasicDocumentInfo.Grounds)
}
inline void BasicDocumentInfo::set_grounds(const char* value) {
  set_has_grounds();
  if (grounds_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    grounds_ = new ::std::string;
  }
  grounds_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Docflow.BasicDocumentInfo.Grounds)
}
inline void BasicDocumentInfo::set_grounds(const char* value, size_t size) {
  set_has_grounds();
  if (grounds_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    grounds_ = new ::std::string;
  }
  grounds_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Docflow.BasicDocumentInfo.Grounds)
}
inline ::std::string* BasicDocumentInfo::mutable_grounds() {
  set_has_grounds();
  if (grounds_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    grounds_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Docflow.BasicDocumentInfo.Grounds)
  return grounds_;
}
inline ::std::string* BasicDocumentInfo::release_grounds() {
  clear_has_grounds();
  if (grounds_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = grounds_;
    grounds_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void BasicDocumentInfo::set_allocated_grounds(::std::string* grounds) {
  if (grounds_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete grounds_;
  }
  if (grounds) {
    set_has_grounds();
    grounds_ = grounds;
  } else {
    clear_has_grounds();
    grounds_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Docflow.BasicDocumentInfo.Grounds)
}

// optional .Diadoc.Api.Proto.Docflow.DocumentDateAndNumber RevisionDateAndNumber = 5;
inline bool BasicDocumentInfo::has_revisiondateandnumber() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BasicDocumentInfo::set_has_revisiondateandnumber() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BasicDocumentInfo::clear_has_revisiondateandnumber() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BasicDocumentInfo::clear_revisiondateandnumber() {
  if (revisiondateandnumber_ != NULL) revisiondateandnumber_->::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber::Clear();
  clear_has_revisiondateandnumber();
}
inline const ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber& BasicDocumentInfo::revisiondateandnumber() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Docflow.BasicDocumentInfo.RevisionDateAndNumber)
  return revisiondateandnumber_ != NULL ? *revisiondateandnumber_ : *default_instance_->revisiondateandnumber_;
}
inline ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber* BasicDocumentInfo::mutable_revisiondateandnumber() {
  set_has_revisiondateandnumber();
  if (revisiondateandnumber_ == NULL) revisiondateandnumber_ = new ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber;
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Docflow.BasicDocumentInfo.RevisionDateAndNumber)
  return revisiondateandnumber_;
}
inline ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber* BasicDocumentInfo::release_revisiondateandnumber() {
  clear_has_revisiondateandnumber();
  ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber* temp = revisiondateandnumber_;
  revisiondateandnumber_ = NULL;
  return temp;
}
inline void BasicDocumentInfo::set_allocated_revisiondateandnumber(::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber* revisiondateandnumber) {
  delete revisiondateandnumber_;
  revisiondateandnumber_ = revisiondateandnumber;
  if (revisiondateandnumber) {
    set_has_revisiondateandnumber();
  } else {
    clear_has_revisiondateandnumber();
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Docflow.BasicDocumentInfo.RevisionDateAndNumber)
}

// -------------------------------------------------------------------

// InvoiceDocumentInfo

// optional string Total = 1;
inline bool InvoiceDocumentInfo::has_total() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InvoiceDocumentInfo::set_has_total() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InvoiceDocumentInfo::clear_has_total() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InvoiceDocumentInfo::clear_total() {
  if (total_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    total_->clear();
  }
  clear_has_total();
}
inline const ::std::string& InvoiceDocumentInfo::total() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Docflow.InvoiceDocumentInfo.Total)
  return *total_;
}
inline void InvoiceDocumentInfo::set_total(const ::std::string& value) {
  set_has_total();
  if (total_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    total_ = new ::std::string;
  }
  total_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Docflow.InvoiceDocumentInfo.Total)
}
inline void InvoiceDocumentInfo::set_total(const char* value) {
  set_has_total();
  if (total_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    total_ = new ::std::string;
  }
  total_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Docflow.InvoiceDocumentInfo.Total)
}
inline void InvoiceDocumentInfo::set_total(const char* value, size_t size) {
  set_has_total();
  if (total_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    total_ = new ::std::string;
  }
  total_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Docflow.InvoiceDocumentInfo.Total)
}
inline ::std::string* InvoiceDocumentInfo::mutable_total() {
  set_has_total();
  if (total_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    total_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Docflow.InvoiceDocumentInfo.Total)
  return total_;
}
inline ::std::string* InvoiceDocumentInfo::release_total() {
  clear_has_total();
  if (total_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = total_;
    total_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void InvoiceDocumentInfo::set_allocated_total(::std::string* total) {
  if (total_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete total_;
  }
  if (total) {
    set_has_total();
    total_ = total;
  } else {
    clear_has_total();
    total_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Docflow.InvoiceDocumentInfo.Total)
}

// optional string Vat = 2;
inline bool InvoiceDocumentInfo::has_vat() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InvoiceDocumentInfo::set_has_vat() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InvoiceDocumentInfo::clear_has_vat() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InvoiceDocumentInfo::clear_vat() {
  if (vat_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vat_->clear();
  }
  clear_has_vat();
}
inline const ::std::string& InvoiceDocumentInfo::vat() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Docflow.InvoiceDocumentInfo.Vat)
  return *vat_;
}
inline void InvoiceDocumentInfo::set_vat(const ::std::string& value) {
  set_has_vat();
  if (vat_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vat_ = new ::std::string;
  }
  vat_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Docflow.InvoiceDocumentInfo.Vat)
}
inline void InvoiceDocumentInfo::set_vat(const char* value) {
  set_has_vat();
  if (vat_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vat_ = new ::std::string;
  }
  vat_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Docflow.InvoiceDocumentInfo.Vat)
}
inline void InvoiceDocumentInfo::set_vat(const char* value, size_t size) {
  set_has_vat();
  if (vat_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vat_ = new ::std::string;
  }
  vat_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Docflow.InvoiceDocumentInfo.Vat)
}
inline ::std::string* InvoiceDocumentInfo::mutable_vat() {
  set_has_vat();
  if (vat_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vat_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Docflow.InvoiceDocumentInfo.Vat)
  return vat_;
}
inline ::std::string* InvoiceDocumentInfo::release_vat() {
  clear_has_vat();
  if (vat_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = vat_;
    vat_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void InvoiceDocumentInfo::set_allocated_vat(::std::string* vat) {
  if (vat_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete vat_;
  }
  if (vat) {
    set_has_vat();
    vat_ = vat;
  } else {
    clear_has_vat();
    vat_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Docflow.InvoiceDocumentInfo.Vat)
}

// optional int32 CurrencyCode = 3;
inline bool InvoiceDocumentInfo::has_currencycode() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InvoiceDocumentInfo::set_has_currencycode() {
  _has_bits_[0] |= 0x00000004u;
}
inline void InvoiceDocumentInfo::clear_has_currencycode() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void InvoiceDocumentInfo::clear_currencycode() {
  currencycode_ = 0;
  clear_has_currencycode();
}
inline ::google::protobuf::int32 InvoiceDocumentInfo::currencycode() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Docflow.InvoiceDocumentInfo.CurrencyCode)
  return currencycode_;
}
inline void InvoiceDocumentInfo::set_currencycode(::google::protobuf::int32 value) {
  set_has_currencycode();
  currencycode_ = value;
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Docflow.InvoiceDocumentInfo.CurrencyCode)
}

// optional .Diadoc.Api.Proto.Docflow.DocumentDateAndNumber OriginalInvoiceDateAndNumber = 4;
inline bool InvoiceDocumentInfo::has_originalinvoicedateandnumber() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void InvoiceDocumentInfo::set_has_originalinvoicedateandnumber() {
  _has_bits_[0] |= 0x00000008u;
}
inline void InvoiceDocumentInfo::clear_has_originalinvoicedateandnumber() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void InvoiceDocumentInfo::clear_originalinvoicedateandnumber() {
  if (originalinvoicedateandnumber_ != NULL) originalinvoicedateandnumber_->::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber::Clear();
  clear_has_originalinvoicedateandnumber();
}
inline const ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber& InvoiceDocumentInfo::originalinvoicedateandnumber() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Docflow.InvoiceDocumentInfo.OriginalInvoiceDateAndNumber)
  return originalinvoicedateandnumber_ != NULL ? *originalinvoicedateandnumber_ : *default_instance_->originalinvoicedateandnumber_;
}
inline ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber* InvoiceDocumentInfo::mutable_originalinvoicedateandnumber() {
  set_has_originalinvoicedateandnumber();
  if (originalinvoicedateandnumber_ == NULL) originalinvoicedateandnumber_ = new ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber;
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Docflow.InvoiceDocumentInfo.OriginalInvoiceDateAndNumber)
  return originalinvoicedateandnumber_;
}
inline ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber* InvoiceDocumentInfo::release_originalinvoicedateandnumber() {
  clear_has_originalinvoicedateandnumber();
  ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber* temp = originalinvoicedateandnumber_;
  originalinvoicedateandnumber_ = NULL;
  return temp;
}
inline void InvoiceDocumentInfo::set_allocated_originalinvoicedateandnumber(::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber* originalinvoicedateandnumber) {
  delete originalinvoicedateandnumber_;
  originalinvoicedateandnumber_ = originalinvoicedateandnumber;
  if (originalinvoicedateandnumber) {
    set_has_originalinvoicedateandnumber();
  } else {
    clear_has_originalinvoicedateandnumber();
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Docflow.InvoiceDocumentInfo.OriginalInvoiceDateAndNumber)
}

// -------------------------------------------------------------------

// InvoiceCorrectionDocumentInfo

// optional string TotalInc = 1;
inline bool InvoiceCorrectionDocumentInfo::has_totalinc() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InvoiceCorrectionDocumentInfo::set_has_totalinc() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InvoiceCorrectionDocumentInfo::clear_has_totalinc() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InvoiceCorrectionDocumentInfo::clear_totalinc() {
  if (totalinc_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    totalinc_->clear();
  }
  clear_has_totalinc();
}
inline const ::std::string& InvoiceCorrectionDocumentInfo::totalinc() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Docflow.InvoiceCorrectionDocumentInfo.TotalInc)
  return *totalinc_;
}
inline void InvoiceCorrectionDocumentInfo::set_totalinc(const ::std::string& value) {
  set_has_totalinc();
  if (totalinc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    totalinc_ = new ::std::string;
  }
  totalinc_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Docflow.InvoiceCorrectionDocumentInfo.TotalInc)
}
inline void InvoiceCorrectionDocumentInfo::set_totalinc(const char* value) {
  set_has_totalinc();
  if (totalinc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    totalinc_ = new ::std::string;
  }
  totalinc_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Docflow.InvoiceCorrectionDocumentInfo.TotalInc)
}
inline void InvoiceCorrectionDocumentInfo::set_totalinc(const char* value, size_t size) {
  set_has_totalinc();
  if (totalinc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    totalinc_ = new ::std::string;
  }
  totalinc_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Docflow.InvoiceCorrectionDocumentInfo.TotalInc)
}
inline ::std::string* InvoiceCorrectionDocumentInfo::mutable_totalinc() {
  set_has_totalinc();
  if (totalinc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    totalinc_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Docflow.InvoiceCorrectionDocumentInfo.TotalInc)
  return totalinc_;
}
inline ::std::string* InvoiceCorrectionDocumentInfo::release_totalinc() {
  clear_has_totalinc();
  if (totalinc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = totalinc_;
    totalinc_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void InvoiceCorrectionDocumentInfo::set_allocated_totalinc(::std::string* totalinc) {
  if (totalinc_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete totalinc_;
  }
  if (totalinc) {
    set_has_totalinc();
    totalinc_ = totalinc;
  } else {
    clear_has_totalinc();
    totalinc_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Docflow.InvoiceCorrectionDocumentInfo.TotalInc)
}

// optional string TotalDec = 2;
inline bool InvoiceCorrectionDocumentInfo::has_totaldec() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InvoiceCorrectionDocumentInfo::set_has_totaldec() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InvoiceCorrectionDocumentInfo::clear_has_totaldec() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InvoiceCorrectionDocumentInfo::clear_totaldec() {
  if (totaldec_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    totaldec_->clear();
  }
  clear_has_totaldec();
}
inline const ::std::string& InvoiceCorrectionDocumentInfo::totaldec() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Docflow.InvoiceCorrectionDocumentInfo.TotalDec)
  return *totaldec_;
}
inline void InvoiceCorrectionDocumentInfo::set_totaldec(const ::std::string& value) {
  set_has_totaldec();
  if (totaldec_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    totaldec_ = new ::std::string;
  }
  totaldec_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Docflow.InvoiceCorrectionDocumentInfo.TotalDec)
}
inline void InvoiceCorrectionDocumentInfo::set_totaldec(const char* value) {
  set_has_totaldec();
  if (totaldec_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    totaldec_ = new ::std::string;
  }
  totaldec_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Docflow.InvoiceCorrectionDocumentInfo.TotalDec)
}
inline void InvoiceCorrectionDocumentInfo::set_totaldec(const char* value, size_t size) {
  set_has_totaldec();
  if (totaldec_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    totaldec_ = new ::std::string;
  }
  totaldec_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Docflow.InvoiceCorrectionDocumentInfo.TotalDec)
}
inline ::std::string* InvoiceCorrectionDocumentInfo::mutable_totaldec() {
  set_has_totaldec();
  if (totaldec_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    totaldec_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Docflow.InvoiceCorrectionDocumentInfo.TotalDec)
  return totaldec_;
}
inline ::std::string* InvoiceCorrectionDocumentInfo::release_totaldec() {
  clear_has_totaldec();
  if (totaldec_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = totaldec_;
    totaldec_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void InvoiceCorrectionDocumentInfo::set_allocated_totaldec(::std::string* totaldec) {
  if (totaldec_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete totaldec_;
  }
  if (totaldec) {
    set_has_totaldec();
    totaldec_ = totaldec;
  } else {
    clear_has_totaldec();
    totaldec_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Docflow.InvoiceCorrectionDocumentInfo.TotalDec)
}

// optional string VatInc = 3;
inline bool InvoiceCorrectionDocumentInfo::has_vatinc() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InvoiceCorrectionDocumentInfo::set_has_vatinc() {
  _has_bits_[0] |= 0x00000004u;
}
inline void InvoiceCorrectionDocumentInfo::clear_has_vatinc() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void InvoiceCorrectionDocumentInfo::clear_vatinc() {
  if (vatinc_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vatinc_->clear();
  }
  clear_has_vatinc();
}
inline const ::std::string& InvoiceCorrectionDocumentInfo::vatinc() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Docflow.InvoiceCorrectionDocumentInfo.VatInc)
  return *vatinc_;
}
inline void InvoiceCorrectionDocumentInfo::set_vatinc(const ::std::string& value) {
  set_has_vatinc();
  if (vatinc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vatinc_ = new ::std::string;
  }
  vatinc_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Docflow.InvoiceCorrectionDocumentInfo.VatInc)
}
inline void InvoiceCorrectionDocumentInfo::set_vatinc(const char* value) {
  set_has_vatinc();
  if (vatinc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vatinc_ = new ::std::string;
  }
  vatinc_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Docflow.InvoiceCorrectionDocumentInfo.VatInc)
}
inline void InvoiceCorrectionDocumentInfo::set_vatinc(const char* value, size_t size) {
  set_has_vatinc();
  if (vatinc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vatinc_ = new ::std::string;
  }
  vatinc_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Docflow.InvoiceCorrectionDocumentInfo.VatInc)
}
inline ::std::string* InvoiceCorrectionDocumentInfo::mutable_vatinc() {
  set_has_vatinc();
  if (vatinc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vatinc_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Docflow.InvoiceCorrectionDocumentInfo.VatInc)
  return vatinc_;
}
inline ::std::string* InvoiceCorrectionDocumentInfo::release_vatinc() {
  clear_has_vatinc();
  if (vatinc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = vatinc_;
    vatinc_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void InvoiceCorrectionDocumentInfo::set_allocated_vatinc(::std::string* vatinc) {
  if (vatinc_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete vatinc_;
  }
  if (vatinc) {
    set_has_vatinc();
    vatinc_ = vatinc;
  } else {
    clear_has_vatinc();
    vatinc_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Docflow.InvoiceCorrectionDocumentInfo.VatInc)
}

// optional string VatDec = 4;
inline bool InvoiceCorrectionDocumentInfo::has_vatdec() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void InvoiceCorrectionDocumentInfo::set_has_vatdec() {
  _has_bits_[0] |= 0x00000008u;
}
inline void InvoiceCorrectionDocumentInfo::clear_has_vatdec() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void InvoiceCorrectionDocumentInfo::clear_vatdec() {
  if (vatdec_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vatdec_->clear();
  }
  clear_has_vatdec();
}
inline const ::std::string& InvoiceCorrectionDocumentInfo::vatdec() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Docflow.InvoiceCorrectionDocumentInfo.VatDec)
  return *vatdec_;
}
inline void InvoiceCorrectionDocumentInfo::set_vatdec(const ::std::string& value) {
  set_has_vatdec();
  if (vatdec_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vatdec_ = new ::std::string;
  }
  vatdec_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Docflow.InvoiceCorrectionDocumentInfo.VatDec)
}
inline void InvoiceCorrectionDocumentInfo::set_vatdec(const char* value) {
  set_has_vatdec();
  if (vatdec_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vatdec_ = new ::std::string;
  }
  vatdec_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Docflow.InvoiceCorrectionDocumentInfo.VatDec)
}
inline void InvoiceCorrectionDocumentInfo::set_vatdec(const char* value, size_t size) {
  set_has_vatdec();
  if (vatdec_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vatdec_ = new ::std::string;
  }
  vatdec_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Docflow.InvoiceCorrectionDocumentInfo.VatDec)
}
inline ::std::string* InvoiceCorrectionDocumentInfo::mutable_vatdec() {
  set_has_vatdec();
  if (vatdec_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vatdec_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Docflow.InvoiceCorrectionDocumentInfo.VatDec)
  return vatdec_;
}
inline ::std::string* InvoiceCorrectionDocumentInfo::release_vatdec() {
  clear_has_vatdec();
  if (vatdec_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = vatdec_;
    vatdec_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void InvoiceCorrectionDocumentInfo::set_allocated_vatdec(::std::string* vatdec) {
  if (vatdec_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete vatdec_;
  }
  if (vatdec) {
    set_has_vatdec();
    vatdec_ = vatdec;
  } else {
    clear_has_vatdec();
    vatdec_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Docflow.InvoiceCorrectionDocumentInfo.VatDec)
}

// optional int32 CurrencyCode = 5;
inline bool InvoiceCorrectionDocumentInfo::has_currencycode() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void InvoiceCorrectionDocumentInfo::set_has_currencycode() {
  _has_bits_[0] |= 0x00000010u;
}
inline void InvoiceCorrectionDocumentInfo::clear_has_currencycode() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void InvoiceCorrectionDocumentInfo::clear_currencycode() {
  currencycode_ = 0;
  clear_has_currencycode();
}
inline ::google::protobuf::int32 InvoiceCorrectionDocumentInfo::currencycode() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Docflow.InvoiceCorrectionDocumentInfo.CurrencyCode)
  return currencycode_;
}
inline void InvoiceCorrectionDocumentInfo::set_currencycode(::google::protobuf::int32 value) {
  set_has_currencycode();
  currencycode_ = value;
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Docflow.InvoiceCorrectionDocumentInfo.CurrencyCode)
}

// optional .Diadoc.Api.Proto.Docflow.DocumentDateAndNumber OriginalInvoiceDateAndNumber = 6;
inline bool InvoiceCorrectionDocumentInfo::has_originalinvoicedateandnumber() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void InvoiceCorrectionDocumentInfo::set_has_originalinvoicedateandnumber() {
  _has_bits_[0] |= 0x00000020u;
}
inline void InvoiceCorrectionDocumentInfo::clear_has_originalinvoicedateandnumber() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void InvoiceCorrectionDocumentInfo::clear_originalinvoicedateandnumber() {
  if (originalinvoicedateandnumber_ != NULL) originalinvoicedateandnumber_->::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber::Clear();
  clear_has_originalinvoicedateandnumber();
}
inline const ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber& InvoiceCorrectionDocumentInfo::originalinvoicedateandnumber() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Docflow.InvoiceCorrectionDocumentInfo.OriginalInvoiceDateAndNumber)
  return originalinvoicedateandnumber_ != NULL ? *originalinvoicedateandnumber_ : *default_instance_->originalinvoicedateandnumber_;
}
inline ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber* InvoiceCorrectionDocumentInfo::mutable_originalinvoicedateandnumber() {
  set_has_originalinvoicedateandnumber();
  if (originalinvoicedateandnumber_ == NULL) originalinvoicedateandnumber_ = new ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber;
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Docflow.InvoiceCorrectionDocumentInfo.OriginalInvoiceDateAndNumber)
  return originalinvoicedateandnumber_;
}
inline ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber* InvoiceCorrectionDocumentInfo::release_originalinvoicedateandnumber() {
  clear_has_originalinvoicedateandnumber();
  ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber* temp = originalinvoicedateandnumber_;
  originalinvoicedateandnumber_ = NULL;
  return temp;
}
inline void InvoiceCorrectionDocumentInfo::set_allocated_originalinvoicedateandnumber(::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber* originalinvoicedateandnumber) {
  delete originalinvoicedateandnumber_;
  originalinvoicedateandnumber_ = originalinvoicedateandnumber;
  if (originalinvoicedateandnumber) {
    set_has_originalinvoicedateandnumber();
  } else {
    clear_has_originalinvoicedateandnumber();
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Docflow.InvoiceCorrectionDocumentInfo.OriginalInvoiceDateAndNumber)
}

// optional .Diadoc.Api.Proto.Docflow.DocumentDateAndNumber OriginalInvoiceRevisionDateAndNumber = 7;
inline bool InvoiceCorrectionDocumentInfo::has_originalinvoicerevisiondateandnumber() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void InvoiceCorrectionDocumentInfo::set_has_originalinvoicerevisiondateandnumber() {
  _has_bits_[0] |= 0x00000040u;
}
inline void InvoiceCorrectionDocumentInfo::clear_has_originalinvoicerevisiondateandnumber() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void InvoiceCorrectionDocumentInfo::clear_originalinvoicerevisiondateandnumber() {
  if (originalinvoicerevisiondateandnumber_ != NULL) originalinvoicerevisiondateandnumber_->::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber::Clear();
  clear_has_originalinvoicerevisiondateandnumber();
}
inline const ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber& InvoiceCorrectionDocumentInfo::originalinvoicerevisiondateandnumber() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Docflow.InvoiceCorrectionDocumentInfo.OriginalInvoiceRevisionDateAndNumber)
  return originalinvoicerevisiondateandnumber_ != NULL ? *originalinvoicerevisiondateandnumber_ : *default_instance_->originalinvoicerevisiondateandnumber_;
}
inline ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber* InvoiceCorrectionDocumentInfo::mutable_originalinvoicerevisiondateandnumber() {
  set_has_originalinvoicerevisiondateandnumber();
  if (originalinvoicerevisiondateandnumber_ == NULL) originalinvoicerevisiondateandnumber_ = new ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber;
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Docflow.InvoiceCorrectionDocumentInfo.OriginalInvoiceRevisionDateAndNumber)
  return originalinvoicerevisiondateandnumber_;
}
inline ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber* InvoiceCorrectionDocumentInfo::release_originalinvoicerevisiondateandnumber() {
  clear_has_originalinvoicerevisiondateandnumber();
  ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber* temp = originalinvoicerevisiondateandnumber_;
  originalinvoicerevisiondateandnumber_ = NULL;
  return temp;
}
inline void InvoiceCorrectionDocumentInfo::set_allocated_originalinvoicerevisiondateandnumber(::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber* originalinvoicerevisiondateandnumber) {
  delete originalinvoicerevisiondateandnumber_;
  originalinvoicerevisiondateandnumber_ = originalinvoicerevisiondateandnumber;
  if (originalinvoicerevisiondateandnumber) {
    set_has_originalinvoicerevisiondateandnumber();
  } else {
    clear_has_originalinvoicerevisiondateandnumber();
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Docflow.InvoiceCorrectionDocumentInfo.OriginalInvoiceRevisionDateAndNumber)
}

// optional .Diadoc.Api.Proto.Docflow.DocumentDateAndNumber OriginalInvoiceCorrectionDateAndNumber = 8;
inline bool InvoiceCorrectionDocumentInfo::has_originalinvoicecorrectiondateandnumber() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void InvoiceCorrectionDocumentInfo::set_has_originalinvoicecorrectiondateandnumber() {
  _has_bits_[0] |= 0x00000080u;
}
inline void InvoiceCorrectionDocumentInfo::clear_has_originalinvoicecorrectiondateandnumber() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void InvoiceCorrectionDocumentInfo::clear_originalinvoicecorrectiondateandnumber() {
  if (originalinvoicecorrectiondateandnumber_ != NULL) originalinvoicecorrectiondateandnumber_->::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber::Clear();
  clear_has_originalinvoicecorrectiondateandnumber();
}
inline const ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber& InvoiceCorrectionDocumentInfo::originalinvoicecorrectiondateandnumber() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Docflow.InvoiceCorrectionDocumentInfo.OriginalInvoiceCorrectionDateAndNumber)
  return originalinvoicecorrectiondateandnumber_ != NULL ? *originalinvoicecorrectiondateandnumber_ : *default_instance_->originalinvoicecorrectiondateandnumber_;
}
inline ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber* InvoiceCorrectionDocumentInfo::mutable_originalinvoicecorrectiondateandnumber() {
  set_has_originalinvoicecorrectiondateandnumber();
  if (originalinvoicecorrectiondateandnumber_ == NULL) originalinvoicecorrectiondateandnumber_ = new ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber;
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Docflow.InvoiceCorrectionDocumentInfo.OriginalInvoiceCorrectionDateAndNumber)
  return originalinvoicecorrectiondateandnumber_;
}
inline ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber* InvoiceCorrectionDocumentInfo::release_originalinvoicecorrectiondateandnumber() {
  clear_has_originalinvoicecorrectiondateandnumber();
  ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber* temp = originalinvoicecorrectiondateandnumber_;
  originalinvoicecorrectiondateandnumber_ = NULL;
  return temp;
}
inline void InvoiceCorrectionDocumentInfo::set_allocated_originalinvoicecorrectiondateandnumber(::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber* originalinvoicecorrectiondateandnumber) {
  delete originalinvoicecorrectiondateandnumber_;
  originalinvoicecorrectiondateandnumber_ = originalinvoicecorrectiondateandnumber;
  if (originalinvoicecorrectiondateandnumber) {
    set_has_originalinvoicecorrectiondateandnumber();
  } else {
    clear_has_originalinvoicecorrectiondateandnumber();
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Docflow.InvoiceCorrectionDocumentInfo.OriginalInvoiceCorrectionDateAndNumber)
}

// -------------------------------------------------------------------

// PriceListDocumentInfo

// optional string PriceListEffectiveDate = 1;
inline bool PriceListDocumentInfo::has_pricelisteffectivedate() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PriceListDocumentInfo::set_has_pricelisteffectivedate() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PriceListDocumentInfo::clear_has_pricelisteffectivedate() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PriceListDocumentInfo::clear_pricelisteffectivedate() {
  if (pricelisteffectivedate_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pricelisteffectivedate_->clear();
  }
  clear_has_pricelisteffectivedate();
}
inline const ::std::string& PriceListDocumentInfo::pricelisteffectivedate() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Docflow.PriceListDocumentInfo.PriceListEffectiveDate)
  return *pricelisteffectivedate_;
}
inline void PriceListDocumentInfo::set_pricelisteffectivedate(const ::std::string& value) {
  set_has_pricelisteffectivedate();
  if (pricelisteffectivedate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pricelisteffectivedate_ = new ::std::string;
  }
  pricelisteffectivedate_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Docflow.PriceListDocumentInfo.PriceListEffectiveDate)
}
inline void PriceListDocumentInfo::set_pricelisteffectivedate(const char* value) {
  set_has_pricelisteffectivedate();
  if (pricelisteffectivedate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pricelisteffectivedate_ = new ::std::string;
  }
  pricelisteffectivedate_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Docflow.PriceListDocumentInfo.PriceListEffectiveDate)
}
inline void PriceListDocumentInfo::set_pricelisteffectivedate(const char* value, size_t size) {
  set_has_pricelisteffectivedate();
  if (pricelisteffectivedate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pricelisteffectivedate_ = new ::std::string;
  }
  pricelisteffectivedate_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Docflow.PriceListDocumentInfo.PriceListEffectiveDate)
}
inline ::std::string* PriceListDocumentInfo::mutable_pricelisteffectivedate() {
  set_has_pricelisteffectivedate();
  if (pricelisteffectivedate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pricelisteffectivedate_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Docflow.PriceListDocumentInfo.PriceListEffectiveDate)
  return pricelisteffectivedate_;
}
inline ::std::string* PriceListDocumentInfo::release_pricelisteffectivedate() {
  clear_has_pricelisteffectivedate();
  if (pricelisteffectivedate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = pricelisteffectivedate_;
    pricelisteffectivedate_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PriceListDocumentInfo::set_allocated_pricelisteffectivedate(::std::string* pricelisteffectivedate) {
  if (pricelisteffectivedate_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete pricelisteffectivedate_;
  }
  if (pricelisteffectivedate) {
    set_has_pricelisteffectivedate();
    pricelisteffectivedate_ = pricelisteffectivedate;
  } else {
    clear_has_pricelisteffectivedate();
    pricelisteffectivedate_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Docflow.PriceListDocumentInfo.PriceListEffectiveDate)
}

// optional .Diadoc.Api.Proto.Docflow.DocumentDateAndNumber ContractDocumentDateAndNumber = 2;
inline bool PriceListDocumentInfo::has_contractdocumentdateandnumber() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PriceListDocumentInfo::set_has_contractdocumentdateandnumber() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PriceListDocumentInfo::clear_has_contractdocumentdateandnumber() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PriceListDocumentInfo::clear_contractdocumentdateandnumber() {
  if (contractdocumentdateandnumber_ != NULL) contractdocumentdateandnumber_->::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber::Clear();
  clear_has_contractdocumentdateandnumber();
}
inline const ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber& PriceListDocumentInfo::contractdocumentdateandnumber() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Docflow.PriceListDocumentInfo.ContractDocumentDateAndNumber)
  return contractdocumentdateandnumber_ != NULL ? *contractdocumentdateandnumber_ : *default_instance_->contractdocumentdateandnumber_;
}
inline ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber* PriceListDocumentInfo::mutable_contractdocumentdateandnumber() {
  set_has_contractdocumentdateandnumber();
  if (contractdocumentdateandnumber_ == NULL) contractdocumentdateandnumber_ = new ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber;
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Docflow.PriceListDocumentInfo.ContractDocumentDateAndNumber)
  return contractdocumentdateandnumber_;
}
inline ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber* PriceListDocumentInfo::release_contractdocumentdateandnumber() {
  clear_has_contractdocumentdateandnumber();
  ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber* temp = contractdocumentdateandnumber_;
  contractdocumentdateandnumber_ = NULL;
  return temp;
}
inline void PriceListDocumentInfo::set_allocated_contractdocumentdateandnumber(::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber* contractdocumentdateandnumber) {
  delete contractdocumentdateandnumber_;
  contractdocumentdateandnumber_ = contractdocumentdateandnumber;
  if (contractdocumentdateandnumber) {
    set_has_contractdocumentdateandnumber();
  } else {
    clear_has_contractdocumentdateandnumber();
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Docflow.PriceListDocumentInfo.ContractDocumentDateAndNumber)
}

// -------------------------------------------------------------------

// ContractDocumentInfo

// optional string ContractPrice = 1;
inline bool ContractDocumentInfo::has_contractprice() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ContractDocumentInfo::set_has_contractprice() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ContractDocumentInfo::clear_has_contractprice() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ContractDocumentInfo::clear_contractprice() {
  if (contractprice_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    contractprice_->clear();
  }
  clear_has_contractprice();
}
inline const ::std::string& ContractDocumentInfo::contractprice() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Docflow.ContractDocumentInfo.ContractPrice)
  return *contractprice_;
}
inline void ContractDocumentInfo::set_contractprice(const ::std::string& value) {
  set_has_contractprice();
  if (contractprice_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    contractprice_ = new ::std::string;
  }
  contractprice_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Docflow.ContractDocumentInfo.ContractPrice)
}
inline void ContractDocumentInfo::set_contractprice(const char* value) {
  set_has_contractprice();
  if (contractprice_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    contractprice_ = new ::std::string;
  }
  contractprice_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Docflow.ContractDocumentInfo.ContractPrice)
}
inline void ContractDocumentInfo::set_contractprice(const char* value, size_t size) {
  set_has_contractprice();
  if (contractprice_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    contractprice_ = new ::std::string;
  }
  contractprice_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Docflow.ContractDocumentInfo.ContractPrice)
}
inline ::std::string* ContractDocumentInfo::mutable_contractprice() {
  set_has_contractprice();
  if (contractprice_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    contractprice_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Docflow.ContractDocumentInfo.ContractPrice)
  return contractprice_;
}
inline ::std::string* ContractDocumentInfo::release_contractprice() {
  clear_has_contractprice();
  if (contractprice_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = contractprice_;
    contractprice_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ContractDocumentInfo::set_allocated_contractprice(::std::string* contractprice) {
  if (contractprice_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete contractprice_;
  }
  if (contractprice) {
    set_has_contractprice();
    contractprice_ = contractprice;
  } else {
    clear_has_contractprice();
    contractprice_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Docflow.ContractDocumentInfo.ContractPrice)
}

// optional string ContractType = 2;
inline bool ContractDocumentInfo::has_contracttype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ContractDocumentInfo::set_has_contracttype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ContractDocumentInfo::clear_has_contracttype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ContractDocumentInfo::clear_contracttype() {
  if (contracttype_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    contracttype_->clear();
  }
  clear_has_contracttype();
}
inline const ::std::string& ContractDocumentInfo::contracttype() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Docflow.ContractDocumentInfo.ContractType)
  return *contracttype_;
}
inline void ContractDocumentInfo::set_contracttype(const ::std::string& value) {
  set_has_contracttype();
  if (contracttype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    contracttype_ = new ::std::string;
  }
  contracttype_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Docflow.ContractDocumentInfo.ContractType)
}
inline void ContractDocumentInfo::set_contracttype(const char* value) {
  set_has_contracttype();
  if (contracttype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    contracttype_ = new ::std::string;
  }
  contracttype_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Docflow.ContractDocumentInfo.ContractType)
}
inline void ContractDocumentInfo::set_contracttype(const char* value, size_t size) {
  set_has_contracttype();
  if (contracttype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    contracttype_ = new ::std::string;
  }
  contracttype_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Docflow.ContractDocumentInfo.ContractType)
}
inline ::std::string* ContractDocumentInfo::mutable_contracttype() {
  set_has_contracttype();
  if (contracttype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    contracttype_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Docflow.ContractDocumentInfo.ContractType)
  return contracttype_;
}
inline ::std::string* ContractDocumentInfo::release_contracttype() {
  clear_has_contracttype();
  if (contracttype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = contracttype_;
    contracttype_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ContractDocumentInfo::set_allocated_contracttype(::std::string* contracttype) {
  if (contracttype_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete contracttype_;
  }
  if (contracttype) {
    set_has_contracttype();
    contracttype_ = contracttype;
  } else {
    clear_has_contracttype();
    contracttype_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Docflow.ContractDocumentInfo.ContractType)
}

// -------------------------------------------------------------------

// SupplementaryAgreementDocumentInfo

// optional string ContractType = 1;
inline bool SupplementaryAgreementDocumentInfo::has_contracttype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SupplementaryAgreementDocumentInfo::set_has_contracttype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SupplementaryAgreementDocumentInfo::clear_has_contracttype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SupplementaryAgreementDocumentInfo::clear_contracttype() {
  if (contracttype_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    contracttype_->clear();
  }
  clear_has_contracttype();
}
inline const ::std::string& SupplementaryAgreementDocumentInfo::contracttype() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Docflow.SupplementaryAgreementDocumentInfo.ContractType)
  return *contracttype_;
}
inline void SupplementaryAgreementDocumentInfo::set_contracttype(const ::std::string& value) {
  set_has_contracttype();
  if (contracttype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    contracttype_ = new ::std::string;
  }
  contracttype_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Docflow.SupplementaryAgreementDocumentInfo.ContractType)
}
inline void SupplementaryAgreementDocumentInfo::set_contracttype(const char* value) {
  set_has_contracttype();
  if (contracttype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    contracttype_ = new ::std::string;
  }
  contracttype_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Docflow.SupplementaryAgreementDocumentInfo.ContractType)
}
inline void SupplementaryAgreementDocumentInfo::set_contracttype(const char* value, size_t size) {
  set_has_contracttype();
  if (contracttype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    contracttype_ = new ::std::string;
  }
  contracttype_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Docflow.SupplementaryAgreementDocumentInfo.ContractType)
}
inline ::std::string* SupplementaryAgreementDocumentInfo::mutable_contracttype() {
  set_has_contracttype();
  if (contracttype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    contracttype_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Docflow.SupplementaryAgreementDocumentInfo.ContractType)
  return contracttype_;
}
inline ::std::string* SupplementaryAgreementDocumentInfo::release_contracttype() {
  clear_has_contracttype();
  if (contracttype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = contracttype_;
    contracttype_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SupplementaryAgreementDocumentInfo::set_allocated_contracttype(::std::string* contracttype) {
  if (contracttype_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete contracttype_;
  }
  if (contracttype) {
    set_has_contracttype();
    contracttype_ = contracttype;
  } else {
    clear_has_contracttype();
    contracttype_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Docflow.SupplementaryAgreementDocumentInfo.ContractType)
}

// required .Diadoc.Api.Proto.Docflow.DocumentDateAndNumber ContractDocumentDateAndNumber = 2;
inline bool SupplementaryAgreementDocumentInfo::has_contractdocumentdateandnumber() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SupplementaryAgreementDocumentInfo::set_has_contractdocumentdateandnumber() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SupplementaryAgreementDocumentInfo::clear_has_contractdocumentdateandnumber() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SupplementaryAgreementDocumentInfo::clear_contractdocumentdateandnumber() {
  if (contractdocumentdateandnumber_ != NULL) contractdocumentdateandnumber_->::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber::Clear();
  clear_has_contractdocumentdateandnumber();
}
inline const ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber& SupplementaryAgreementDocumentInfo::contractdocumentdateandnumber() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Docflow.SupplementaryAgreementDocumentInfo.ContractDocumentDateAndNumber)
  return contractdocumentdateandnumber_ != NULL ? *contractdocumentdateandnumber_ : *default_instance_->contractdocumentdateandnumber_;
}
inline ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber* SupplementaryAgreementDocumentInfo::mutable_contractdocumentdateandnumber() {
  set_has_contractdocumentdateandnumber();
  if (contractdocumentdateandnumber_ == NULL) contractdocumentdateandnumber_ = new ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber;
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Docflow.SupplementaryAgreementDocumentInfo.ContractDocumentDateAndNumber)
  return contractdocumentdateandnumber_;
}
inline ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber* SupplementaryAgreementDocumentInfo::release_contractdocumentdateandnumber() {
  clear_has_contractdocumentdateandnumber();
  ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber* temp = contractdocumentdateandnumber_;
  contractdocumentdateandnumber_ = NULL;
  return temp;
}
inline void SupplementaryAgreementDocumentInfo::set_allocated_contractdocumentdateandnumber(::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber* contractdocumentdateandnumber) {
  delete contractdocumentdateandnumber_;
  contractdocumentdateandnumber_ = contractdocumentdateandnumber;
  if (contractdocumentdateandnumber) {
    set_has_contractdocumentdateandnumber();
  } else {
    clear_has_contractdocumentdateandnumber();
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Docflow.SupplementaryAgreementDocumentInfo.ContractDocumentDateAndNumber)
}

// required .Diadoc.Api.Proto.Docflow.DocumentDateAndNumber DocumentDateAndNumber = 3;
inline bool SupplementaryAgreementDocumentInfo::has_documentdateandnumber() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SupplementaryAgreementDocumentInfo::set_has_documentdateandnumber() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SupplementaryAgreementDocumentInfo::clear_has_documentdateandnumber() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SupplementaryAgreementDocumentInfo::clear_documentdateandnumber() {
  if (documentdateandnumber_ != NULL) documentdateandnumber_->::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber::Clear();
  clear_has_documentdateandnumber();
}
inline const ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber& SupplementaryAgreementDocumentInfo::documentdateandnumber() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Docflow.SupplementaryAgreementDocumentInfo.DocumentDateAndNumber)
  return documentdateandnumber_ != NULL ? *documentdateandnumber_ : *default_instance_->documentdateandnumber_;
}
inline ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber* SupplementaryAgreementDocumentInfo::mutable_documentdateandnumber() {
  set_has_documentdateandnumber();
  if (documentdateandnumber_ == NULL) documentdateandnumber_ = new ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber;
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Docflow.SupplementaryAgreementDocumentInfo.DocumentDateAndNumber)
  return documentdateandnumber_;
}
inline ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber* SupplementaryAgreementDocumentInfo::release_documentdateandnumber() {
  clear_has_documentdateandnumber();
  ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber* temp = documentdateandnumber_;
  documentdateandnumber_ = NULL;
  return temp;
}
inline void SupplementaryAgreementDocumentInfo::set_allocated_documentdateandnumber(::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber* documentdateandnumber) {
  delete documentdateandnumber_;
  documentdateandnumber_ = documentdateandnumber;
  if (documentdateandnumber) {
    set_has_documentdateandnumber();
  } else {
    clear_has_documentdateandnumber();
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Docflow.SupplementaryAgreementDocumentInfo.DocumentDateAndNumber)
}

// optional string Total = 4;
inline bool SupplementaryAgreementDocumentInfo::has_total() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SupplementaryAgreementDocumentInfo::set_has_total() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SupplementaryAgreementDocumentInfo::clear_has_total() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SupplementaryAgreementDocumentInfo::clear_total() {
  if (total_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    total_->clear();
  }
  clear_has_total();
}
inline const ::std::string& SupplementaryAgreementDocumentInfo::total() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Docflow.SupplementaryAgreementDocumentInfo.Total)
  return *total_;
}
inline void SupplementaryAgreementDocumentInfo::set_total(const ::std::string& value) {
  set_has_total();
  if (total_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    total_ = new ::std::string;
  }
  total_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Docflow.SupplementaryAgreementDocumentInfo.Total)
}
inline void SupplementaryAgreementDocumentInfo::set_total(const char* value) {
  set_has_total();
  if (total_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    total_ = new ::std::string;
  }
  total_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Docflow.SupplementaryAgreementDocumentInfo.Total)
}
inline void SupplementaryAgreementDocumentInfo::set_total(const char* value, size_t size) {
  set_has_total();
  if (total_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    total_ = new ::std::string;
  }
  total_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Docflow.SupplementaryAgreementDocumentInfo.Total)
}
inline ::std::string* SupplementaryAgreementDocumentInfo::mutable_total() {
  set_has_total();
  if (total_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    total_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Docflow.SupplementaryAgreementDocumentInfo.Total)
  return total_;
}
inline ::std::string* SupplementaryAgreementDocumentInfo::release_total() {
  clear_has_total();
  if (total_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = total_;
    total_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SupplementaryAgreementDocumentInfo::set_allocated_total(::std::string* total) {
  if (total_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete total_;
  }
  if (total) {
    set_has_total();
    total_ = total;
  } else {
    clear_has_total();
    total_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Docflow.SupplementaryAgreementDocumentInfo.Total)
}

// -------------------------------------------------------------------

// UniversalTransferDocumentInfo

// optional string Total = 1;
inline bool UniversalTransferDocumentInfo::has_total() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UniversalTransferDocumentInfo::set_has_total() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UniversalTransferDocumentInfo::clear_has_total() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UniversalTransferDocumentInfo::clear_total() {
  if (total_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    total_->clear();
  }
  clear_has_total();
}
inline const ::std::string& UniversalTransferDocumentInfo::total() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Docflow.UniversalTransferDocumentInfo.Total)
  return *total_;
}
inline void UniversalTransferDocumentInfo::set_total(const ::std::string& value) {
  set_has_total();
  if (total_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    total_ = new ::std::string;
  }
  total_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Docflow.UniversalTransferDocumentInfo.Total)
}
inline void UniversalTransferDocumentInfo::set_total(const char* value) {
  set_has_total();
  if (total_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    total_ = new ::std::string;
  }
  total_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Docflow.UniversalTransferDocumentInfo.Total)
}
inline void UniversalTransferDocumentInfo::set_total(const char* value, size_t size) {
  set_has_total();
  if (total_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    total_ = new ::std::string;
  }
  total_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Docflow.UniversalTransferDocumentInfo.Total)
}
inline ::std::string* UniversalTransferDocumentInfo::mutable_total() {
  set_has_total();
  if (total_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    total_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Docflow.UniversalTransferDocumentInfo.Total)
  return total_;
}
inline ::std::string* UniversalTransferDocumentInfo::release_total() {
  clear_has_total();
  if (total_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = total_;
    total_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UniversalTransferDocumentInfo::set_allocated_total(::std::string* total) {
  if (total_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete total_;
  }
  if (total) {
    set_has_total();
    total_ = total;
  } else {
    clear_has_total();
    total_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Docflow.UniversalTransferDocumentInfo.Total)
}

// optional string Vat = 2;
inline bool UniversalTransferDocumentInfo::has_vat() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UniversalTransferDocumentInfo::set_has_vat() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UniversalTransferDocumentInfo::clear_has_vat() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UniversalTransferDocumentInfo::clear_vat() {
  if (vat_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vat_->clear();
  }
  clear_has_vat();
}
inline const ::std::string& UniversalTransferDocumentInfo::vat() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Docflow.UniversalTransferDocumentInfo.Vat)
  return *vat_;
}
inline void UniversalTransferDocumentInfo::set_vat(const ::std::string& value) {
  set_has_vat();
  if (vat_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vat_ = new ::std::string;
  }
  vat_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Docflow.UniversalTransferDocumentInfo.Vat)
}
inline void UniversalTransferDocumentInfo::set_vat(const char* value) {
  set_has_vat();
  if (vat_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vat_ = new ::std::string;
  }
  vat_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Docflow.UniversalTransferDocumentInfo.Vat)
}
inline void UniversalTransferDocumentInfo::set_vat(const char* value, size_t size) {
  set_has_vat();
  if (vat_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vat_ = new ::std::string;
  }
  vat_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Docflow.UniversalTransferDocumentInfo.Vat)
}
inline ::std::string* UniversalTransferDocumentInfo::mutable_vat() {
  set_has_vat();
  if (vat_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vat_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Docflow.UniversalTransferDocumentInfo.Vat)
  return vat_;
}
inline ::std::string* UniversalTransferDocumentInfo::release_vat() {
  clear_has_vat();
  if (vat_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = vat_;
    vat_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UniversalTransferDocumentInfo::set_allocated_vat(::std::string* vat) {
  if (vat_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete vat_;
  }
  if (vat) {
    set_has_vat();
    vat_ = vat;
  } else {
    clear_has_vat();
    vat_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Docflow.UniversalTransferDocumentInfo.Vat)
}

// optional int32 CurrencyCode = 3;
inline bool UniversalTransferDocumentInfo::has_currencycode() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UniversalTransferDocumentInfo::set_has_currencycode() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UniversalTransferDocumentInfo::clear_has_currencycode() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UniversalTransferDocumentInfo::clear_currencycode() {
  currencycode_ = 0;
  clear_has_currencycode();
}
inline ::google::protobuf::int32 UniversalTransferDocumentInfo::currencycode() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Docflow.UniversalTransferDocumentInfo.CurrencyCode)
  return currencycode_;
}
inline void UniversalTransferDocumentInfo::set_currencycode(::google::protobuf::int32 value) {
  set_has_currencycode();
  currencycode_ = value;
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Docflow.UniversalTransferDocumentInfo.CurrencyCode)
}

// optional string Grounds = 4;
inline bool UniversalTransferDocumentInfo::has_grounds() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UniversalTransferDocumentInfo::set_has_grounds() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UniversalTransferDocumentInfo::clear_has_grounds() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UniversalTransferDocumentInfo::clear_grounds() {
  if (grounds_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    grounds_->clear();
  }
  clear_has_grounds();
}
inline const ::std::string& UniversalTransferDocumentInfo::grounds() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Docflow.UniversalTransferDocumentInfo.Grounds)
  return *grounds_;
}
inline void UniversalTransferDocumentInfo::set_grounds(const ::std::string& value) {
  set_has_grounds();
  if (grounds_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    grounds_ = new ::std::string;
  }
  grounds_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Docflow.UniversalTransferDocumentInfo.Grounds)
}
inline void UniversalTransferDocumentInfo::set_grounds(const char* value) {
  set_has_grounds();
  if (grounds_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    grounds_ = new ::std::string;
  }
  grounds_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Docflow.UniversalTransferDocumentInfo.Grounds)
}
inline void UniversalTransferDocumentInfo::set_grounds(const char* value, size_t size) {
  set_has_grounds();
  if (grounds_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    grounds_ = new ::std::string;
  }
  grounds_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Docflow.UniversalTransferDocumentInfo.Grounds)
}
inline ::std::string* UniversalTransferDocumentInfo::mutable_grounds() {
  set_has_grounds();
  if (grounds_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    grounds_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Docflow.UniversalTransferDocumentInfo.Grounds)
  return grounds_;
}
inline ::std::string* UniversalTransferDocumentInfo::release_grounds() {
  clear_has_grounds();
  if (grounds_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = grounds_;
    grounds_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UniversalTransferDocumentInfo::set_allocated_grounds(::std::string* grounds) {
  if (grounds_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete grounds_;
  }
  if (grounds) {
    set_has_grounds();
    grounds_ = grounds;
  } else {
    clear_has_grounds();
    grounds_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Docflow.UniversalTransferDocumentInfo.Grounds)
}

// required .Diadoc.Api.Proto.Invoicing.FunctionType Function = 5;
inline bool UniversalTransferDocumentInfo::has_function() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UniversalTransferDocumentInfo::set_has_function() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UniversalTransferDocumentInfo::clear_has_function() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UniversalTransferDocumentInfo::clear_function() {
  function_ = 0;
  clear_has_function();
}
inline ::Diadoc::Api::Proto::Invoicing::FunctionType UniversalTransferDocumentInfo::function() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Docflow.UniversalTransferDocumentInfo.Function)
  return static_cast< ::Diadoc::Api::Proto::Invoicing::FunctionType >(function_);
}
inline void UniversalTransferDocumentInfo::set_function(::Diadoc::Api::Proto::Invoicing::FunctionType value) {
  assert(::Diadoc::Api::Proto::Invoicing::FunctionType_IsValid(value));
  set_has_function();
  function_ = value;
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Docflow.UniversalTransferDocumentInfo.Function)
}

// optional .Diadoc.Api.Proto.Docflow.DocumentDateAndNumber OriginalDocumentDateAndNumber = 6;
inline bool UniversalTransferDocumentInfo::has_originaldocumentdateandnumber() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UniversalTransferDocumentInfo::set_has_originaldocumentdateandnumber() {
  _has_bits_[0] |= 0x00000020u;
}
inline void UniversalTransferDocumentInfo::clear_has_originaldocumentdateandnumber() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void UniversalTransferDocumentInfo::clear_originaldocumentdateandnumber() {
  if (originaldocumentdateandnumber_ != NULL) originaldocumentdateandnumber_->::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber::Clear();
  clear_has_originaldocumentdateandnumber();
}
inline const ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber& UniversalTransferDocumentInfo::originaldocumentdateandnumber() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Docflow.UniversalTransferDocumentInfo.OriginalDocumentDateAndNumber)
  return originaldocumentdateandnumber_ != NULL ? *originaldocumentdateandnumber_ : *default_instance_->originaldocumentdateandnumber_;
}
inline ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber* UniversalTransferDocumentInfo::mutable_originaldocumentdateandnumber() {
  set_has_originaldocumentdateandnumber();
  if (originaldocumentdateandnumber_ == NULL) originaldocumentdateandnumber_ = new ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber;
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Docflow.UniversalTransferDocumentInfo.OriginalDocumentDateAndNumber)
  return originaldocumentdateandnumber_;
}
inline ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber* UniversalTransferDocumentInfo::release_originaldocumentdateandnumber() {
  clear_has_originaldocumentdateandnumber();
  ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber* temp = originaldocumentdateandnumber_;
  originaldocumentdateandnumber_ = NULL;
  return temp;
}
inline void UniversalTransferDocumentInfo::set_allocated_originaldocumentdateandnumber(::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber* originaldocumentdateandnumber) {
  delete originaldocumentdateandnumber_;
  originaldocumentdateandnumber_ = originaldocumentdateandnumber;
  if (originaldocumentdateandnumber) {
    set_has_originaldocumentdateandnumber();
  } else {
    clear_has_originaldocumentdateandnumber();
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Docflow.UniversalTransferDocumentInfo.OriginalDocumentDateAndNumber)
}

// -------------------------------------------------------------------

// UniversalCorrectionDocumentInfo

// optional string TotalInc = 1;
inline bool UniversalCorrectionDocumentInfo::has_totalinc() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UniversalCorrectionDocumentInfo::set_has_totalinc() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UniversalCorrectionDocumentInfo::clear_has_totalinc() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UniversalCorrectionDocumentInfo::clear_totalinc() {
  if (totalinc_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    totalinc_->clear();
  }
  clear_has_totalinc();
}
inline const ::std::string& UniversalCorrectionDocumentInfo::totalinc() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Docflow.UniversalCorrectionDocumentInfo.TotalInc)
  return *totalinc_;
}
inline void UniversalCorrectionDocumentInfo::set_totalinc(const ::std::string& value) {
  set_has_totalinc();
  if (totalinc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    totalinc_ = new ::std::string;
  }
  totalinc_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Docflow.UniversalCorrectionDocumentInfo.TotalInc)
}
inline void UniversalCorrectionDocumentInfo::set_totalinc(const char* value) {
  set_has_totalinc();
  if (totalinc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    totalinc_ = new ::std::string;
  }
  totalinc_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Docflow.UniversalCorrectionDocumentInfo.TotalInc)
}
inline void UniversalCorrectionDocumentInfo::set_totalinc(const char* value, size_t size) {
  set_has_totalinc();
  if (totalinc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    totalinc_ = new ::std::string;
  }
  totalinc_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Docflow.UniversalCorrectionDocumentInfo.TotalInc)
}
inline ::std::string* UniversalCorrectionDocumentInfo::mutable_totalinc() {
  set_has_totalinc();
  if (totalinc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    totalinc_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Docflow.UniversalCorrectionDocumentInfo.TotalInc)
  return totalinc_;
}
inline ::std::string* UniversalCorrectionDocumentInfo::release_totalinc() {
  clear_has_totalinc();
  if (totalinc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = totalinc_;
    totalinc_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UniversalCorrectionDocumentInfo::set_allocated_totalinc(::std::string* totalinc) {
  if (totalinc_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete totalinc_;
  }
  if (totalinc) {
    set_has_totalinc();
    totalinc_ = totalinc;
  } else {
    clear_has_totalinc();
    totalinc_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Docflow.UniversalCorrectionDocumentInfo.TotalInc)
}

// optional string TotalDec = 2;
inline bool UniversalCorrectionDocumentInfo::has_totaldec() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UniversalCorrectionDocumentInfo::set_has_totaldec() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UniversalCorrectionDocumentInfo::clear_has_totaldec() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UniversalCorrectionDocumentInfo::clear_totaldec() {
  if (totaldec_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    totaldec_->clear();
  }
  clear_has_totaldec();
}
inline const ::std::string& UniversalCorrectionDocumentInfo::totaldec() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Docflow.UniversalCorrectionDocumentInfo.TotalDec)
  return *totaldec_;
}
inline void UniversalCorrectionDocumentInfo::set_totaldec(const ::std::string& value) {
  set_has_totaldec();
  if (totaldec_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    totaldec_ = new ::std::string;
  }
  totaldec_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Docflow.UniversalCorrectionDocumentInfo.TotalDec)
}
inline void UniversalCorrectionDocumentInfo::set_totaldec(const char* value) {
  set_has_totaldec();
  if (totaldec_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    totaldec_ = new ::std::string;
  }
  totaldec_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Docflow.UniversalCorrectionDocumentInfo.TotalDec)
}
inline void UniversalCorrectionDocumentInfo::set_totaldec(const char* value, size_t size) {
  set_has_totaldec();
  if (totaldec_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    totaldec_ = new ::std::string;
  }
  totaldec_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Docflow.UniversalCorrectionDocumentInfo.TotalDec)
}
inline ::std::string* UniversalCorrectionDocumentInfo::mutable_totaldec() {
  set_has_totaldec();
  if (totaldec_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    totaldec_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Docflow.UniversalCorrectionDocumentInfo.TotalDec)
  return totaldec_;
}
inline ::std::string* UniversalCorrectionDocumentInfo::release_totaldec() {
  clear_has_totaldec();
  if (totaldec_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = totaldec_;
    totaldec_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UniversalCorrectionDocumentInfo::set_allocated_totaldec(::std::string* totaldec) {
  if (totaldec_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete totaldec_;
  }
  if (totaldec) {
    set_has_totaldec();
    totaldec_ = totaldec;
  } else {
    clear_has_totaldec();
    totaldec_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Docflow.UniversalCorrectionDocumentInfo.TotalDec)
}

// optional string VatInc = 3;
inline bool UniversalCorrectionDocumentInfo::has_vatinc() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UniversalCorrectionDocumentInfo::set_has_vatinc() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UniversalCorrectionDocumentInfo::clear_has_vatinc() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UniversalCorrectionDocumentInfo::clear_vatinc() {
  if (vatinc_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vatinc_->clear();
  }
  clear_has_vatinc();
}
inline const ::std::string& UniversalCorrectionDocumentInfo::vatinc() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Docflow.UniversalCorrectionDocumentInfo.VatInc)
  return *vatinc_;
}
inline void UniversalCorrectionDocumentInfo::set_vatinc(const ::std::string& value) {
  set_has_vatinc();
  if (vatinc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vatinc_ = new ::std::string;
  }
  vatinc_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Docflow.UniversalCorrectionDocumentInfo.VatInc)
}
inline void UniversalCorrectionDocumentInfo::set_vatinc(const char* value) {
  set_has_vatinc();
  if (vatinc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vatinc_ = new ::std::string;
  }
  vatinc_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Docflow.UniversalCorrectionDocumentInfo.VatInc)
}
inline void UniversalCorrectionDocumentInfo::set_vatinc(const char* value, size_t size) {
  set_has_vatinc();
  if (vatinc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vatinc_ = new ::std::string;
  }
  vatinc_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Docflow.UniversalCorrectionDocumentInfo.VatInc)
}
inline ::std::string* UniversalCorrectionDocumentInfo::mutable_vatinc() {
  set_has_vatinc();
  if (vatinc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vatinc_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Docflow.UniversalCorrectionDocumentInfo.VatInc)
  return vatinc_;
}
inline ::std::string* UniversalCorrectionDocumentInfo::release_vatinc() {
  clear_has_vatinc();
  if (vatinc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = vatinc_;
    vatinc_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UniversalCorrectionDocumentInfo::set_allocated_vatinc(::std::string* vatinc) {
  if (vatinc_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete vatinc_;
  }
  if (vatinc) {
    set_has_vatinc();
    vatinc_ = vatinc;
  } else {
    clear_has_vatinc();
    vatinc_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Docflow.UniversalCorrectionDocumentInfo.VatInc)
}

// optional string VatDec = 4;
inline bool UniversalCorrectionDocumentInfo::has_vatdec() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UniversalCorrectionDocumentInfo::set_has_vatdec() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UniversalCorrectionDocumentInfo::clear_has_vatdec() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UniversalCorrectionDocumentInfo::clear_vatdec() {
  if (vatdec_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vatdec_->clear();
  }
  clear_has_vatdec();
}
inline const ::std::string& UniversalCorrectionDocumentInfo::vatdec() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Docflow.UniversalCorrectionDocumentInfo.VatDec)
  return *vatdec_;
}
inline void UniversalCorrectionDocumentInfo::set_vatdec(const ::std::string& value) {
  set_has_vatdec();
  if (vatdec_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vatdec_ = new ::std::string;
  }
  vatdec_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Docflow.UniversalCorrectionDocumentInfo.VatDec)
}
inline void UniversalCorrectionDocumentInfo::set_vatdec(const char* value) {
  set_has_vatdec();
  if (vatdec_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vatdec_ = new ::std::string;
  }
  vatdec_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Docflow.UniversalCorrectionDocumentInfo.VatDec)
}
inline void UniversalCorrectionDocumentInfo::set_vatdec(const char* value, size_t size) {
  set_has_vatdec();
  if (vatdec_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vatdec_ = new ::std::string;
  }
  vatdec_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Docflow.UniversalCorrectionDocumentInfo.VatDec)
}
inline ::std::string* UniversalCorrectionDocumentInfo::mutable_vatdec() {
  set_has_vatdec();
  if (vatdec_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vatdec_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Docflow.UniversalCorrectionDocumentInfo.VatDec)
  return vatdec_;
}
inline ::std::string* UniversalCorrectionDocumentInfo::release_vatdec() {
  clear_has_vatdec();
  if (vatdec_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = vatdec_;
    vatdec_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UniversalCorrectionDocumentInfo::set_allocated_vatdec(::std::string* vatdec) {
  if (vatdec_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete vatdec_;
  }
  if (vatdec) {
    set_has_vatdec();
    vatdec_ = vatdec;
  } else {
    clear_has_vatdec();
    vatdec_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Docflow.UniversalCorrectionDocumentInfo.VatDec)
}

// optional int32 CurrencyCode = 5;
inline bool UniversalCorrectionDocumentInfo::has_currencycode() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UniversalCorrectionDocumentInfo::set_has_currencycode() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UniversalCorrectionDocumentInfo::clear_has_currencycode() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UniversalCorrectionDocumentInfo::clear_currencycode() {
  currencycode_ = 0;
  clear_has_currencycode();
}
inline ::google::protobuf::int32 UniversalCorrectionDocumentInfo::currencycode() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Docflow.UniversalCorrectionDocumentInfo.CurrencyCode)
  return currencycode_;
}
inline void UniversalCorrectionDocumentInfo::set_currencycode(::google::protobuf::int32 value) {
  set_has_currencycode();
  currencycode_ = value;
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Docflow.UniversalCorrectionDocumentInfo.CurrencyCode)
}

// optional string Grounds = 6;
inline bool UniversalCorrectionDocumentInfo::has_grounds() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UniversalCorrectionDocumentInfo::set_has_grounds() {
  _has_bits_[0] |= 0x00000020u;
}
inline void UniversalCorrectionDocumentInfo::clear_has_grounds() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void UniversalCorrectionDocumentInfo::clear_grounds() {
  if (grounds_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    grounds_->clear();
  }
  clear_has_grounds();
}
inline const ::std::string& UniversalCorrectionDocumentInfo::grounds() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Docflow.UniversalCorrectionDocumentInfo.Grounds)
  return *grounds_;
}
inline void UniversalCorrectionDocumentInfo::set_grounds(const ::std::string& value) {
  set_has_grounds();
  if (grounds_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    grounds_ = new ::std::string;
  }
  grounds_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Docflow.UniversalCorrectionDocumentInfo.Grounds)
}
inline void UniversalCorrectionDocumentInfo::set_grounds(const char* value) {
  set_has_grounds();
  if (grounds_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    grounds_ = new ::std::string;
  }
  grounds_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Docflow.UniversalCorrectionDocumentInfo.Grounds)
}
inline void UniversalCorrectionDocumentInfo::set_grounds(const char* value, size_t size) {
  set_has_grounds();
  if (grounds_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    grounds_ = new ::std::string;
  }
  grounds_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Docflow.UniversalCorrectionDocumentInfo.Grounds)
}
inline ::std::string* UniversalCorrectionDocumentInfo::mutable_grounds() {
  set_has_grounds();
  if (grounds_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    grounds_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Docflow.UniversalCorrectionDocumentInfo.Grounds)
  return grounds_;
}
inline ::std::string* UniversalCorrectionDocumentInfo::release_grounds() {
  clear_has_grounds();
  if (grounds_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = grounds_;
    grounds_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UniversalCorrectionDocumentInfo::set_allocated_grounds(::std::string* grounds) {
  if (grounds_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete grounds_;
  }
  if (grounds) {
    set_has_grounds();
    grounds_ = grounds;
  } else {
    clear_has_grounds();
    grounds_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Docflow.UniversalCorrectionDocumentInfo.Grounds)
}

// required .Diadoc.Api.Proto.Invoicing.FunctionType Function = 7;
inline bool UniversalCorrectionDocumentInfo::has_function() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void UniversalCorrectionDocumentInfo::set_has_function() {
  _has_bits_[0] |= 0x00000040u;
}
inline void UniversalCorrectionDocumentInfo::clear_has_function() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void UniversalCorrectionDocumentInfo::clear_function() {
  function_ = 0;
  clear_has_function();
}
inline ::Diadoc::Api::Proto::Invoicing::FunctionType UniversalCorrectionDocumentInfo::function() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Docflow.UniversalCorrectionDocumentInfo.Function)
  return static_cast< ::Diadoc::Api::Proto::Invoicing::FunctionType >(function_);
}
inline void UniversalCorrectionDocumentInfo::set_function(::Diadoc::Api::Proto::Invoicing::FunctionType value) {
  assert(::Diadoc::Api::Proto::Invoicing::FunctionType_IsValid(value));
  set_has_function();
  function_ = value;
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Docflow.UniversalCorrectionDocumentInfo.Function)
}

// optional .Diadoc.Api.Proto.Docflow.DocumentDateAndNumber OriginalDocumentDateAndNumber = 8;
inline bool UniversalCorrectionDocumentInfo::has_originaldocumentdateandnumber() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void UniversalCorrectionDocumentInfo::set_has_originaldocumentdateandnumber() {
  _has_bits_[0] |= 0x00000080u;
}
inline void UniversalCorrectionDocumentInfo::clear_has_originaldocumentdateandnumber() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void UniversalCorrectionDocumentInfo::clear_originaldocumentdateandnumber() {
  if (originaldocumentdateandnumber_ != NULL) originaldocumentdateandnumber_->::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber::Clear();
  clear_has_originaldocumentdateandnumber();
}
inline const ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber& UniversalCorrectionDocumentInfo::originaldocumentdateandnumber() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Docflow.UniversalCorrectionDocumentInfo.OriginalDocumentDateAndNumber)
  return originaldocumentdateandnumber_ != NULL ? *originaldocumentdateandnumber_ : *default_instance_->originaldocumentdateandnumber_;
}
inline ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber* UniversalCorrectionDocumentInfo::mutable_originaldocumentdateandnumber() {
  set_has_originaldocumentdateandnumber();
  if (originaldocumentdateandnumber_ == NULL) originaldocumentdateandnumber_ = new ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber;
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Docflow.UniversalCorrectionDocumentInfo.OriginalDocumentDateAndNumber)
  return originaldocumentdateandnumber_;
}
inline ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber* UniversalCorrectionDocumentInfo::release_originaldocumentdateandnumber() {
  clear_has_originaldocumentdateandnumber();
  ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber* temp = originaldocumentdateandnumber_;
  originaldocumentdateandnumber_ = NULL;
  return temp;
}
inline void UniversalCorrectionDocumentInfo::set_allocated_originaldocumentdateandnumber(::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber* originaldocumentdateandnumber) {
  delete originaldocumentdateandnumber_;
  originaldocumentdateandnumber_ = originaldocumentdateandnumber;
  if (originaldocumentdateandnumber) {
    set_has_originaldocumentdateandnumber();
  } else {
    clear_has_originaldocumentdateandnumber();
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Docflow.UniversalCorrectionDocumentInfo.OriginalDocumentDateAndNumber)
}

// optional .Diadoc.Api.Proto.Docflow.DocumentDateAndNumber OriginalDocumentRevisionDateAndNumber = 9;
inline bool UniversalCorrectionDocumentInfo::has_originaldocumentrevisiondateandnumber() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void UniversalCorrectionDocumentInfo::set_has_originaldocumentrevisiondateandnumber() {
  _has_bits_[0] |= 0x00000100u;
}
inline void UniversalCorrectionDocumentInfo::clear_has_originaldocumentrevisiondateandnumber() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void UniversalCorrectionDocumentInfo::clear_originaldocumentrevisiondateandnumber() {
  if (originaldocumentrevisiondateandnumber_ != NULL) originaldocumentrevisiondateandnumber_->::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber::Clear();
  clear_has_originaldocumentrevisiondateandnumber();
}
inline const ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber& UniversalCorrectionDocumentInfo::originaldocumentrevisiondateandnumber() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Docflow.UniversalCorrectionDocumentInfo.OriginalDocumentRevisionDateAndNumber)
  return originaldocumentrevisiondateandnumber_ != NULL ? *originaldocumentrevisiondateandnumber_ : *default_instance_->originaldocumentrevisiondateandnumber_;
}
inline ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber* UniversalCorrectionDocumentInfo::mutable_originaldocumentrevisiondateandnumber() {
  set_has_originaldocumentrevisiondateandnumber();
  if (originaldocumentrevisiondateandnumber_ == NULL) originaldocumentrevisiondateandnumber_ = new ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber;
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Docflow.UniversalCorrectionDocumentInfo.OriginalDocumentRevisionDateAndNumber)
  return originaldocumentrevisiondateandnumber_;
}
inline ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber* UniversalCorrectionDocumentInfo::release_originaldocumentrevisiondateandnumber() {
  clear_has_originaldocumentrevisiondateandnumber();
  ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber* temp = originaldocumentrevisiondateandnumber_;
  originaldocumentrevisiondateandnumber_ = NULL;
  return temp;
}
inline void UniversalCorrectionDocumentInfo::set_allocated_originaldocumentrevisiondateandnumber(::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber* originaldocumentrevisiondateandnumber) {
  delete originaldocumentrevisiondateandnumber_;
  originaldocumentrevisiondateandnumber_ = originaldocumentrevisiondateandnumber;
  if (originaldocumentrevisiondateandnumber) {
    set_has_originaldocumentrevisiondateandnumber();
  } else {
    clear_has_originaldocumentrevisiondateandnumber();
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Docflow.UniversalCorrectionDocumentInfo.OriginalDocumentRevisionDateAndNumber)
}

// optional .Diadoc.Api.Proto.Docflow.DocumentDateAndNumber OriginalDocumentCorrectionDateAndNumber = 10;
inline bool UniversalCorrectionDocumentInfo::has_originaldocumentcorrectiondateandnumber() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void UniversalCorrectionDocumentInfo::set_has_originaldocumentcorrectiondateandnumber() {
  _has_bits_[0] |= 0x00000200u;
}
inline void UniversalCorrectionDocumentInfo::clear_has_originaldocumentcorrectiondateandnumber() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void UniversalCorrectionDocumentInfo::clear_originaldocumentcorrectiondateandnumber() {
  if (originaldocumentcorrectiondateandnumber_ != NULL) originaldocumentcorrectiondateandnumber_->::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber::Clear();
  clear_has_originaldocumentcorrectiondateandnumber();
}
inline const ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber& UniversalCorrectionDocumentInfo::originaldocumentcorrectiondateandnumber() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Docflow.UniversalCorrectionDocumentInfo.OriginalDocumentCorrectionDateAndNumber)
  return originaldocumentcorrectiondateandnumber_ != NULL ? *originaldocumentcorrectiondateandnumber_ : *default_instance_->originaldocumentcorrectiondateandnumber_;
}
inline ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber* UniversalCorrectionDocumentInfo::mutable_originaldocumentcorrectiondateandnumber() {
  set_has_originaldocumentcorrectiondateandnumber();
  if (originaldocumentcorrectiondateandnumber_ == NULL) originaldocumentcorrectiondateandnumber_ = new ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber;
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Docflow.UniversalCorrectionDocumentInfo.OriginalDocumentCorrectionDateAndNumber)
  return originaldocumentcorrectiondateandnumber_;
}
inline ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber* UniversalCorrectionDocumentInfo::release_originaldocumentcorrectiondateandnumber() {
  clear_has_originaldocumentcorrectiondateandnumber();
  ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber* temp = originaldocumentcorrectiondateandnumber_;
  originaldocumentcorrectiondateandnumber_ = NULL;
  return temp;
}
inline void UniversalCorrectionDocumentInfo::set_allocated_originaldocumentcorrectiondateandnumber(::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber* originaldocumentcorrectiondateandnumber) {
  delete originaldocumentcorrectiondateandnumber_;
  originaldocumentcorrectiondateandnumber_ = originaldocumentcorrectiondateandnumber;
  if (originaldocumentcorrectiondateandnumber) {
    set_has_originaldocumentcorrectiondateandnumber();
  } else {
    clear_has_originaldocumentcorrectiondateandnumber();
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Docflow.UniversalCorrectionDocumentInfo.OriginalDocumentCorrectionDateAndNumber)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace Docflow
}  // namespace Proto
}  // namespace Api
}  // namespace Diadoc

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_Docflow_2fDocumentInfo_2eproto__INCLUDED
