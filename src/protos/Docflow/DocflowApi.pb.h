// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Docflow/DocflowApi.proto

#ifndef PROTOBUF_Docflow_2fDocflowApi_2eproto__INCLUDED
#define PROTOBUF_Docflow_2fDocflowApi_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "Timestamp.pb.h"
#include "DocumentId.pb.h"
#include "TotalCountType.pb.h"
#include "TimeBasedFilter.pb.h"
#include "Docflow/DocumentWithDocflow.pb.h"
// @@protoc_insertion_point(includes)

namespace Diadoc {
namespace Api {
namespace Proto {
namespace Docflow {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_Docflow_2fDocflowApi_2eproto();
void protobuf_AssignDesc_Docflow_2fDocflowApi_2eproto();
void protobuf_ShutdownFile_Docflow_2fDocflowApi_2eproto();

class GetDocflowBatchRequest;
class GetDocflowRequest;
class GetDocflowBatchResponse;
class SearchDocflowsRequest;
class SearchDocflowsResponse;
class GetDocflowsByPacketIdRequest;
class FetchedDocument;
class GetDocflowsByPacketIdResponse;
class GetDocflowEventsRequest;
class GetDocflowEventsResponse;
class DocflowEvent;

enum SearchScope {
  SearchScopeAny = 0,
  SearchScopeIncoming = 1,
  SearchScopeOutgoing = 2,
  SearchScopeDeleted = 3,
  SearchScopeInternal = 4
};
bool SearchScope_IsValid(int value);
const SearchScope SearchScope_MIN = SearchScopeAny;
const SearchScope SearchScope_MAX = SearchScopeInternal;
const int SearchScope_ARRAYSIZE = SearchScope_MAX + 1;

const ::google::protobuf::EnumDescriptor* SearchScope_descriptor();
inline const ::std::string& SearchScope_Name(SearchScope value) {
  return ::google::protobuf::internal::NameOfEnum(
    SearchScope_descriptor(), value);
}
inline bool SearchScope_Parse(
    const ::std::string& name, SearchScope* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SearchScope>(
    SearchScope_descriptor(), name, value);
}
// ===================================================================

class GetDocflowBatchRequest : public ::google::protobuf::Message {
 public:
  GetDocflowBatchRequest();
  virtual ~GetDocflowBatchRequest();

  GetDocflowBatchRequest(const GetDocflowBatchRequest& from);

  inline GetDocflowBatchRequest& operator=(const GetDocflowBatchRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetDocflowBatchRequest& default_instance();

  void Swap(GetDocflowBatchRequest* other);

  // implements Message ----------------------------------------------

  GetDocflowBatchRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetDocflowBatchRequest& from);
  void MergeFrom(const GetDocflowBatchRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Diadoc.Api.Proto.Docflow.GetDocflowRequest Requests = 1;
  inline int requests_size() const;
  inline void clear_requests();
  static const int kRequestsFieldNumber = 1;
  inline const ::Diadoc::Api::Proto::Docflow::GetDocflowRequest& requests(int index) const;
  inline ::Diadoc::Api::Proto::Docflow::GetDocflowRequest* mutable_requests(int index);
  inline ::Diadoc::Api::Proto::Docflow::GetDocflowRequest* add_requests();
  inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Docflow::GetDocflowRequest >&
      requests() const;
  inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Docflow::GetDocflowRequest >*
      mutable_requests();

  // @@protoc_insertion_point(class_scope:Diadoc.Api.Proto.Docflow.GetDocflowBatchRequest)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Docflow::GetDocflowRequest > requests_;
  friend void  protobuf_AddDesc_Docflow_2fDocflowApi_2eproto();
  friend void protobuf_AssignDesc_Docflow_2fDocflowApi_2eproto();
  friend void protobuf_ShutdownFile_Docflow_2fDocflowApi_2eproto();

  void InitAsDefaultInstance();
  static GetDocflowBatchRequest* default_instance_;
};
// -------------------------------------------------------------------

class GetDocflowRequest : public ::google::protobuf::Message {
 public:
  GetDocflowRequest();
  virtual ~GetDocflowRequest();

  GetDocflowRequest(const GetDocflowRequest& from);

  inline GetDocflowRequest& operator=(const GetDocflowRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetDocflowRequest& default_instance();

  void Swap(GetDocflowRequest* other);

  // implements Message ----------------------------------------------

  GetDocflowRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetDocflowRequest& from);
  void MergeFrom(const GetDocflowRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Diadoc.Api.Proto.DocumentId DocumentId = 1;
  inline bool has_documentid() const;
  inline void clear_documentid();
  static const int kDocumentIdFieldNumber = 1;
  inline const ::Diadoc::Api::Proto::DocumentId& documentid() const;
  inline ::Diadoc::Api::Proto::DocumentId* mutable_documentid();
  inline ::Diadoc::Api::Proto::DocumentId* release_documentid();
  inline void set_allocated_documentid(::Diadoc::Api::Proto::DocumentId* documentid);

  // optional string LastEventId = 2;
  inline bool has_lasteventid() const;
  inline void clear_lasteventid();
  static const int kLastEventIdFieldNumber = 2;
  inline const ::std::string& lasteventid() const;
  inline void set_lasteventid(const ::std::string& value);
  inline void set_lasteventid(const char* value);
  inline void set_lasteventid(const char* value, size_t size);
  inline ::std::string* mutable_lasteventid();
  inline ::std::string* release_lasteventid();
  inline void set_allocated_lasteventid(::std::string* lasteventid);

  // optional bool InjectEntityContent = 3 [default = false];
  inline bool has_injectentitycontent() const;
  inline void clear_injectentitycontent();
  static const int kInjectEntityContentFieldNumber = 3;
  inline bool injectentitycontent() const;
  inline void set_injectentitycontent(bool value);

  // @@protoc_insertion_point(class_scope:Diadoc.Api.Proto.Docflow.GetDocflowRequest)
 private:
  inline void set_has_documentid();
  inline void clear_has_documentid();
  inline void set_has_lasteventid();
  inline void clear_has_lasteventid();
  inline void set_has_injectentitycontent();
  inline void clear_has_injectentitycontent();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::Diadoc::Api::Proto::DocumentId* documentid_;
  ::std::string* lasteventid_;
  bool injectentitycontent_;
  friend void  protobuf_AddDesc_Docflow_2fDocflowApi_2eproto();
  friend void protobuf_AssignDesc_Docflow_2fDocflowApi_2eproto();
  friend void protobuf_ShutdownFile_Docflow_2fDocflowApi_2eproto();

  void InitAsDefaultInstance();
  static GetDocflowRequest* default_instance_;
};
// -------------------------------------------------------------------

class GetDocflowBatchResponse : public ::google::protobuf::Message {
 public:
  GetDocflowBatchResponse();
  virtual ~GetDocflowBatchResponse();

  GetDocflowBatchResponse(const GetDocflowBatchResponse& from);

  inline GetDocflowBatchResponse& operator=(const GetDocflowBatchResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetDocflowBatchResponse& default_instance();

  void Swap(GetDocflowBatchResponse* other);

  // implements Message ----------------------------------------------

  GetDocflowBatchResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetDocflowBatchResponse& from);
  void MergeFrom(const GetDocflowBatchResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Diadoc.Api.Proto.Docflow.DocumentWithDocflow Documents = 1;
  inline int documents_size() const;
  inline void clear_documents();
  static const int kDocumentsFieldNumber = 1;
  inline const ::Diadoc::Api::Proto::Docflow::DocumentWithDocflow& documents(int index) const;
  inline ::Diadoc::Api::Proto::Docflow::DocumentWithDocflow* mutable_documents(int index);
  inline ::Diadoc::Api::Proto::Docflow::DocumentWithDocflow* add_documents();
  inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Docflow::DocumentWithDocflow >&
      documents() const;
  inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Docflow::DocumentWithDocflow >*
      mutable_documents();

  // @@protoc_insertion_point(class_scope:Diadoc.Api.Proto.Docflow.GetDocflowBatchResponse)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Docflow::DocumentWithDocflow > documents_;
  friend void  protobuf_AddDesc_Docflow_2fDocflowApi_2eproto();
  friend void protobuf_AssignDesc_Docflow_2fDocflowApi_2eproto();
  friend void protobuf_ShutdownFile_Docflow_2fDocflowApi_2eproto();

  void InitAsDefaultInstance();
  static GetDocflowBatchResponse* default_instance_;
};
// -------------------------------------------------------------------

class SearchDocflowsRequest : public ::google::protobuf::Message {
 public:
  SearchDocflowsRequest();
  virtual ~SearchDocflowsRequest();

  SearchDocflowsRequest(const SearchDocflowsRequest& from);

  inline SearchDocflowsRequest& operator=(const SearchDocflowsRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SearchDocflowsRequest& default_instance();

  void Swap(SearchDocflowsRequest* other);

  // implements Message ----------------------------------------------

  SearchDocflowsRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SearchDocflowsRequest& from);
  void MergeFrom(const SearchDocflowsRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string QueryString = 1;
  inline bool has_querystring() const;
  inline void clear_querystring();
  static const int kQueryStringFieldNumber = 1;
  inline const ::std::string& querystring() const;
  inline void set_querystring(const ::std::string& value);
  inline void set_querystring(const char* value);
  inline void set_querystring(const char* value, size_t size);
  inline ::std::string* mutable_querystring();
  inline ::std::string* release_querystring();
  inline void set_allocated_querystring(::std::string* querystring);

  // optional int32 Count = 2 [default = 100];
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 2;
  inline ::google::protobuf::int32 count() const;
  inline void set_count(::google::protobuf::int32 value);

  // optional int32 FirstIndex = 3;
  inline bool has_firstindex() const;
  inline void clear_firstindex();
  static const int kFirstIndexFieldNumber = 3;
  inline ::google::protobuf::int32 firstindex() const;
  inline void set_firstindex(::google::protobuf::int32 value);

  // optional .Diadoc.Api.Proto.Docflow.SearchScope Scope = 4 [default = SearchScopeAny];
  inline bool has_scope() const;
  inline void clear_scope();
  static const int kScopeFieldNumber = 4;
  inline ::Diadoc::Api::Proto::Docflow::SearchScope scope() const;
  inline void set_scope(::Diadoc::Api::Proto::Docflow::SearchScope value);

  // optional bool InjectEntityContent = 5 [default = false];
  inline bool has_injectentitycontent() const;
  inline void clear_injectentitycontent();
  static const int kInjectEntityContentFieldNumber = 5;
  inline bool injectentitycontent() const;
  inline void set_injectentitycontent(bool value);

  // @@protoc_insertion_point(class_scope:Diadoc.Api.Proto.Docflow.SearchDocflowsRequest)
 private:
  inline void set_has_querystring();
  inline void clear_has_querystring();
  inline void set_has_count();
  inline void clear_has_count();
  inline void set_has_firstindex();
  inline void clear_has_firstindex();
  inline void set_has_scope();
  inline void clear_has_scope();
  inline void set_has_injectentitycontent();
  inline void clear_has_injectentitycontent();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* querystring_;
  ::google::protobuf::int32 count_;
  ::google::protobuf::int32 firstindex_;
  int scope_;
  bool injectentitycontent_;
  friend void  protobuf_AddDesc_Docflow_2fDocflowApi_2eproto();
  friend void protobuf_AssignDesc_Docflow_2fDocflowApi_2eproto();
  friend void protobuf_ShutdownFile_Docflow_2fDocflowApi_2eproto();

  void InitAsDefaultInstance();
  static SearchDocflowsRequest* default_instance_;
};
// -------------------------------------------------------------------

class SearchDocflowsResponse : public ::google::protobuf::Message {
 public:
  SearchDocflowsResponse();
  virtual ~SearchDocflowsResponse();

  SearchDocflowsResponse(const SearchDocflowsResponse& from);

  inline SearchDocflowsResponse& operator=(const SearchDocflowsResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SearchDocflowsResponse& default_instance();

  void Swap(SearchDocflowsResponse* other);

  // implements Message ----------------------------------------------

  SearchDocflowsResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SearchDocflowsResponse& from);
  void MergeFrom(const SearchDocflowsResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Diadoc.Api.Proto.Docflow.DocumentWithDocflow Documents = 1;
  inline int documents_size() const;
  inline void clear_documents();
  static const int kDocumentsFieldNumber = 1;
  inline const ::Diadoc::Api::Proto::Docflow::DocumentWithDocflow& documents(int index) const;
  inline ::Diadoc::Api::Proto::Docflow::DocumentWithDocflow* mutable_documents(int index);
  inline ::Diadoc::Api::Proto::Docflow::DocumentWithDocflow* add_documents();
  inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Docflow::DocumentWithDocflow >&
      documents() const;
  inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Docflow::DocumentWithDocflow >*
      mutable_documents();

  // optional bool HaveMoreDocuments = 2;
  inline bool has_havemoredocuments() const;
  inline void clear_havemoredocuments();
  static const int kHaveMoreDocumentsFieldNumber = 2;
  inline bool havemoredocuments() const;
  inline void set_havemoredocuments(bool value);

  // @@protoc_insertion_point(class_scope:Diadoc.Api.Proto.Docflow.SearchDocflowsResponse)
 private:
  inline void set_has_havemoredocuments();
  inline void clear_has_havemoredocuments();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Docflow::DocumentWithDocflow > documents_;
  bool havemoredocuments_;
  friend void  protobuf_AddDesc_Docflow_2fDocflowApi_2eproto();
  friend void protobuf_AssignDesc_Docflow_2fDocflowApi_2eproto();
  friend void protobuf_ShutdownFile_Docflow_2fDocflowApi_2eproto();

  void InitAsDefaultInstance();
  static SearchDocflowsResponse* default_instance_;
};
// -------------------------------------------------------------------

class GetDocflowsByPacketIdRequest : public ::google::protobuf::Message {
 public:
  GetDocflowsByPacketIdRequest();
  virtual ~GetDocflowsByPacketIdRequest();

  GetDocflowsByPacketIdRequest(const GetDocflowsByPacketIdRequest& from);

  inline GetDocflowsByPacketIdRequest& operator=(const GetDocflowsByPacketIdRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetDocflowsByPacketIdRequest& default_instance();

  void Swap(GetDocflowsByPacketIdRequest* other);

  // implements Message ----------------------------------------------

  GetDocflowsByPacketIdRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetDocflowsByPacketIdRequest& from);
  void MergeFrom(const GetDocflowsByPacketIdRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string PacketId = 1;
  inline bool has_packetid() const;
  inline void clear_packetid();
  static const int kPacketIdFieldNumber = 1;
  inline const ::std::string& packetid() const;
  inline void set_packetid(const ::std::string& value);
  inline void set_packetid(const char* value);
  inline void set_packetid(const char* value, size_t size);
  inline ::std::string* mutable_packetid();
  inline ::std::string* release_packetid();
  inline void set_allocated_packetid(::std::string* packetid);

  // optional int32 Count = 2 [default = 100];
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 2;
  inline ::google::protobuf::int32 count() const;
  inline void set_count(::google::protobuf::int32 value);

  // optional bool InjectEntityContent = 3 [default = false];
  inline bool has_injectentitycontent() const;
  inline void clear_injectentitycontent();
  static const int kInjectEntityContentFieldNumber = 3;
  inline bool injectentitycontent() const;
  inline void set_injectentitycontent(bool value);

  // optional bytes AfterIndexKey = 4;
  inline bool has_afterindexkey() const;
  inline void clear_afterindexkey();
  static const int kAfterIndexKeyFieldNumber = 4;
  inline const ::std::string& afterindexkey() const;
  inline void set_afterindexkey(const ::std::string& value);
  inline void set_afterindexkey(const char* value);
  inline void set_afterindexkey(const void* value, size_t size);
  inline ::std::string* mutable_afterindexkey();
  inline ::std::string* release_afterindexkey();
  inline void set_allocated_afterindexkey(::std::string* afterindexkey);

  // @@protoc_insertion_point(class_scope:Diadoc.Api.Proto.Docflow.GetDocflowsByPacketIdRequest)
 private:
  inline void set_has_packetid();
  inline void clear_has_packetid();
  inline void set_has_count();
  inline void clear_has_count();
  inline void set_has_injectentitycontent();
  inline void clear_has_injectentitycontent();
  inline void set_has_afterindexkey();
  inline void clear_has_afterindexkey();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* packetid_;
  ::google::protobuf::int32 count_;
  bool injectentitycontent_;
  ::std::string* afterindexkey_;
  friend void  protobuf_AddDesc_Docflow_2fDocflowApi_2eproto();
  friend void protobuf_AssignDesc_Docflow_2fDocflowApi_2eproto();
  friend void protobuf_ShutdownFile_Docflow_2fDocflowApi_2eproto();

  void InitAsDefaultInstance();
  static GetDocflowsByPacketIdRequest* default_instance_;
};
// -------------------------------------------------------------------

class FetchedDocument : public ::google::protobuf::Message {
 public:
  FetchedDocument();
  virtual ~FetchedDocument();

  FetchedDocument(const FetchedDocument& from);

  inline FetchedDocument& operator=(const FetchedDocument& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FetchedDocument& default_instance();

  void Swap(FetchedDocument* other);

  // implements Message ----------------------------------------------

  FetchedDocument* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FetchedDocument& from);
  void MergeFrom(const FetchedDocument& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Diadoc.Api.Proto.Docflow.DocumentWithDocflow Document = 1;
  inline bool has_document() const;
  inline void clear_document();
  static const int kDocumentFieldNumber = 1;
  inline const ::Diadoc::Api::Proto::Docflow::DocumentWithDocflow& document() const;
  inline ::Diadoc::Api::Proto::Docflow::DocumentWithDocflow* mutable_document();
  inline ::Diadoc::Api::Proto::Docflow::DocumentWithDocflow* release_document();
  inline void set_allocated_document(::Diadoc::Api::Proto::Docflow::DocumentWithDocflow* document);

  // required bytes IndexKey = 2;
  inline bool has_indexkey() const;
  inline void clear_indexkey();
  static const int kIndexKeyFieldNumber = 2;
  inline const ::std::string& indexkey() const;
  inline void set_indexkey(const ::std::string& value);
  inline void set_indexkey(const char* value);
  inline void set_indexkey(const void* value, size_t size);
  inline ::std::string* mutable_indexkey();
  inline ::std::string* release_indexkey();
  inline void set_allocated_indexkey(::std::string* indexkey);

  // @@protoc_insertion_point(class_scope:Diadoc.Api.Proto.Docflow.FetchedDocument)
 private:
  inline void set_has_document();
  inline void clear_has_document();
  inline void set_has_indexkey();
  inline void clear_has_indexkey();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::Diadoc::Api::Proto::Docflow::DocumentWithDocflow* document_;
  ::std::string* indexkey_;
  friend void  protobuf_AddDesc_Docflow_2fDocflowApi_2eproto();
  friend void protobuf_AssignDesc_Docflow_2fDocflowApi_2eproto();
  friend void protobuf_ShutdownFile_Docflow_2fDocflowApi_2eproto();

  void InitAsDefaultInstance();
  static FetchedDocument* default_instance_;
};
// -------------------------------------------------------------------

class GetDocflowsByPacketIdResponse : public ::google::protobuf::Message {
 public:
  GetDocflowsByPacketIdResponse();
  virtual ~GetDocflowsByPacketIdResponse();

  GetDocflowsByPacketIdResponse(const GetDocflowsByPacketIdResponse& from);

  inline GetDocflowsByPacketIdResponse& operator=(const GetDocflowsByPacketIdResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetDocflowsByPacketIdResponse& default_instance();

  void Swap(GetDocflowsByPacketIdResponse* other);

  // implements Message ----------------------------------------------

  GetDocflowsByPacketIdResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetDocflowsByPacketIdResponse& from);
  void MergeFrom(const GetDocflowsByPacketIdResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Diadoc.Api.Proto.Docflow.FetchedDocument Documents = 1;
  inline int documents_size() const;
  inline void clear_documents();
  static const int kDocumentsFieldNumber = 1;
  inline const ::Diadoc::Api::Proto::Docflow::FetchedDocument& documents(int index) const;
  inline ::Diadoc::Api::Proto::Docflow::FetchedDocument* mutable_documents(int index);
  inline ::Diadoc::Api::Proto::Docflow::FetchedDocument* add_documents();
  inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Docflow::FetchedDocument >&
      documents() const;
  inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Docflow::FetchedDocument >*
      mutable_documents();

  // optional bytes NextPageIndexKey = 2;
  inline bool has_nextpageindexkey() const;
  inline void clear_nextpageindexkey();
  static const int kNextPageIndexKeyFieldNumber = 2;
  inline const ::std::string& nextpageindexkey() const;
  inline void set_nextpageindexkey(const ::std::string& value);
  inline void set_nextpageindexkey(const char* value);
  inline void set_nextpageindexkey(const void* value, size_t size);
  inline ::std::string* mutable_nextpageindexkey();
  inline ::std::string* release_nextpageindexkey();
  inline void set_allocated_nextpageindexkey(::std::string* nextpageindexkey);

  // @@protoc_insertion_point(class_scope:Diadoc.Api.Proto.Docflow.GetDocflowsByPacketIdResponse)
 private:
  inline void set_has_nextpageindexkey();
  inline void clear_has_nextpageindexkey();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Docflow::FetchedDocument > documents_;
  ::std::string* nextpageindexkey_;
  friend void  protobuf_AddDesc_Docflow_2fDocflowApi_2eproto();
  friend void protobuf_AssignDesc_Docflow_2fDocflowApi_2eproto();
  friend void protobuf_ShutdownFile_Docflow_2fDocflowApi_2eproto();

  void InitAsDefaultInstance();
  static GetDocflowsByPacketIdResponse* default_instance_;
};
// -------------------------------------------------------------------

class GetDocflowEventsRequest : public ::google::protobuf::Message {
 public:
  GetDocflowEventsRequest();
  virtual ~GetDocflowEventsRequest();

  GetDocflowEventsRequest(const GetDocflowEventsRequest& from);

  inline GetDocflowEventsRequest& operator=(const GetDocflowEventsRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetDocflowEventsRequest& default_instance();

  void Swap(GetDocflowEventsRequest* other);

  // implements Message ----------------------------------------------

  GetDocflowEventsRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetDocflowEventsRequest& from);
  void MergeFrom(const GetDocflowEventsRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Diadoc.Api.Proto.TimeBasedFilter Filter = 1;
  inline bool has_filter() const;
  inline void clear_filter();
  static const int kFilterFieldNumber = 1;
  inline const ::Diadoc::Api::Proto::TimeBasedFilter& filter() const;
  inline ::Diadoc::Api::Proto::TimeBasedFilter* mutable_filter();
  inline ::Diadoc::Api::Proto::TimeBasedFilter* release_filter();
  inline void set_allocated_filter(::Diadoc::Api::Proto::TimeBasedFilter* filter);

  // optional bytes AfterIndexKey = 2;
  inline bool has_afterindexkey() const;
  inline void clear_afterindexkey();
  static const int kAfterIndexKeyFieldNumber = 2;
  inline const ::std::string& afterindexkey() const;
  inline void set_afterindexkey(const ::std::string& value);
  inline void set_afterindexkey(const char* value);
  inline void set_afterindexkey(const void* value, size_t size);
  inline ::std::string* mutable_afterindexkey();
  inline ::std::string* release_afterindexkey();
  inline void set_allocated_afterindexkey(::std::string* afterindexkey);

  // optional bool PopulateDocuments = 3 [default = false];
  inline bool has_populatedocuments() const;
  inline void clear_populatedocuments();
  static const int kPopulateDocumentsFieldNumber = 3;
  inline bool populatedocuments() const;
  inline void set_populatedocuments(bool value);

  // optional bool InjectEntityContent = 4 [default = false];
  inline bool has_injectentitycontent() const;
  inline void clear_injectentitycontent();
  static const int kInjectEntityContentFieldNumber = 4;
  inline bool injectentitycontent() const;
  inline void set_injectentitycontent(bool value);

  // optional bool PopulatePreviousDocumentStates = 5 [default = false];
  inline bool has_populatepreviousdocumentstates() const;
  inline void clear_populatepreviousdocumentstates();
  static const int kPopulatePreviousDocumentStatesFieldNumber = 5;
  inline bool populatepreviousdocumentstates() const;
  inline void set_populatepreviousdocumentstates(bool value);

  // @@protoc_insertion_point(class_scope:Diadoc.Api.Proto.Docflow.GetDocflowEventsRequest)
 private:
  inline void set_has_filter();
  inline void clear_has_filter();
  inline void set_has_afterindexkey();
  inline void clear_has_afterindexkey();
  inline void set_has_populatedocuments();
  inline void clear_has_populatedocuments();
  inline void set_has_injectentitycontent();
  inline void clear_has_injectentitycontent();
  inline void set_has_populatepreviousdocumentstates();
  inline void clear_has_populatepreviousdocumentstates();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::Diadoc::Api::Proto::TimeBasedFilter* filter_;
  ::std::string* afterindexkey_;
  bool populatedocuments_;
  bool injectentitycontent_;
  bool populatepreviousdocumentstates_;
  friend void  protobuf_AddDesc_Docflow_2fDocflowApi_2eproto();
  friend void protobuf_AssignDesc_Docflow_2fDocflowApi_2eproto();
  friend void protobuf_ShutdownFile_Docflow_2fDocflowApi_2eproto();

  void InitAsDefaultInstance();
  static GetDocflowEventsRequest* default_instance_;
};
// -------------------------------------------------------------------

class GetDocflowEventsResponse : public ::google::protobuf::Message {
 public:
  GetDocflowEventsResponse();
  virtual ~GetDocflowEventsResponse();

  GetDocflowEventsResponse(const GetDocflowEventsResponse& from);

  inline GetDocflowEventsResponse& operator=(const GetDocflowEventsResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetDocflowEventsResponse& default_instance();

  void Swap(GetDocflowEventsResponse* other);

  // implements Message ----------------------------------------------

  GetDocflowEventsResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetDocflowEventsResponse& from);
  void MergeFrom(const GetDocflowEventsResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 TotalCount = 1;
  inline bool has_totalcount() const;
  inline void clear_totalcount();
  static const int kTotalCountFieldNumber = 1;
  inline ::google::protobuf::int32 totalcount() const;
  inline void set_totalcount(::google::protobuf::int32 value);

  // repeated .Diadoc.Api.Proto.Docflow.DocflowEvent Events = 2;
  inline int events_size() const;
  inline void clear_events();
  static const int kEventsFieldNumber = 2;
  inline const ::Diadoc::Api::Proto::Docflow::DocflowEvent& events(int index) const;
  inline ::Diadoc::Api::Proto::Docflow::DocflowEvent* mutable_events(int index);
  inline ::Diadoc::Api::Proto::Docflow::DocflowEvent* add_events();
  inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Docflow::DocflowEvent >&
      events() const;
  inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Docflow::DocflowEvent >*
      mutable_events();

  // required .Diadoc.Api.Proto.TotalCountType TotalCountType = 3;
  inline bool has_totalcounttype() const;
  inline void clear_totalcounttype();
  static const int kTotalCountTypeFieldNumber = 3;
  inline ::Diadoc::Api::Proto::TotalCountType totalcounttype() const;
  inline void set_totalcounttype(::Diadoc::Api::Proto::TotalCountType value);

  // @@protoc_insertion_point(class_scope:Diadoc.Api.Proto.Docflow.GetDocflowEventsResponse)
 private:
  inline void set_has_totalcount();
  inline void clear_has_totalcount();
  inline void set_has_totalcounttype();
  inline void clear_has_totalcounttype();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Docflow::DocflowEvent > events_;
  ::google::protobuf::int32 totalcount_;
  int totalcounttype_;
  friend void  protobuf_AddDesc_Docflow_2fDocflowApi_2eproto();
  friend void protobuf_AssignDesc_Docflow_2fDocflowApi_2eproto();
  friend void protobuf_ShutdownFile_Docflow_2fDocflowApi_2eproto();

  void InitAsDefaultInstance();
  static GetDocflowEventsResponse* default_instance_;
};
// -------------------------------------------------------------------

class DocflowEvent : public ::google::protobuf::Message {
 public:
  DocflowEvent();
  virtual ~DocflowEvent();

  DocflowEvent(const DocflowEvent& from);

  inline DocflowEvent& operator=(const DocflowEvent& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DocflowEvent& default_instance();

  void Swap(DocflowEvent* other);

  // implements Message ----------------------------------------------

  DocflowEvent* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DocflowEvent& from);
  void MergeFrom(const DocflowEvent& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string EventId = 1;
  inline bool has_eventid() const;
  inline void clear_eventid();
  static const int kEventIdFieldNumber = 1;
  inline const ::std::string& eventid() const;
  inline void set_eventid(const ::std::string& value);
  inline void set_eventid(const char* value);
  inline void set_eventid(const char* value, size_t size);
  inline ::std::string* mutable_eventid();
  inline ::std::string* release_eventid();
  inline void set_allocated_eventid(::std::string* eventid);

  // optional .Diadoc.Api.Proto.Timestamp Timestamp = 2;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 2;
  inline const ::Diadoc::Api::Proto::Timestamp& timestamp() const;
  inline ::Diadoc::Api::Proto::Timestamp* mutable_timestamp();
  inline ::Diadoc::Api::Proto::Timestamp* release_timestamp();
  inline void set_allocated_timestamp(::Diadoc::Api::Proto::Timestamp* timestamp);

  // optional .Diadoc.Api.Proto.DocumentId DocumentId = 3;
  inline bool has_documentid() const;
  inline void clear_documentid();
  static const int kDocumentIdFieldNumber = 3;
  inline const ::Diadoc::Api::Proto::DocumentId& documentid() const;
  inline ::Diadoc::Api::Proto::DocumentId* mutable_documentid();
  inline ::Diadoc::Api::Proto::DocumentId* release_documentid();
  inline void set_allocated_documentid(::Diadoc::Api::Proto::DocumentId* documentid);

  // optional bytes IndexKey = 4;
  inline bool has_indexkey() const;
  inline void clear_indexkey();
  static const int kIndexKeyFieldNumber = 4;
  inline const ::std::string& indexkey() const;
  inline void set_indexkey(const ::std::string& value);
  inline void set_indexkey(const char* value);
  inline void set_indexkey(const void* value, size_t size);
  inline ::std::string* mutable_indexkey();
  inline ::std::string* release_indexkey();
  inline void set_allocated_indexkey(::std::string* indexkey);

  // optional .Diadoc.Api.Proto.Docflow.DocumentWithDocflow Document = 5;
  inline bool has_document() const;
  inline void clear_document();
  static const int kDocumentFieldNumber = 5;
  inline const ::Diadoc::Api::Proto::Docflow::DocumentWithDocflow& document() const;
  inline ::Diadoc::Api::Proto::Docflow::DocumentWithDocflow* mutable_document();
  inline ::Diadoc::Api::Proto::Docflow::DocumentWithDocflow* release_document();
  inline void set_allocated_document(::Diadoc::Api::Proto::Docflow::DocumentWithDocflow* document);

  // optional string PreviousEventId = 6;
  inline bool has_previouseventid() const;
  inline void clear_previouseventid();
  static const int kPreviousEventIdFieldNumber = 6;
  inline const ::std::string& previouseventid() const;
  inline void set_previouseventid(const ::std::string& value);
  inline void set_previouseventid(const char* value);
  inline void set_previouseventid(const char* value, size_t size);
  inline ::std::string* mutable_previouseventid();
  inline ::std::string* release_previouseventid();
  inline void set_allocated_previouseventid(::std::string* previouseventid);

  // optional .Diadoc.Api.Proto.Docflow.DocumentWithDocflow PreviousDocumentState = 7;
  inline bool has_previousdocumentstate() const;
  inline void clear_previousdocumentstate();
  static const int kPreviousDocumentStateFieldNumber = 7;
  inline const ::Diadoc::Api::Proto::Docflow::DocumentWithDocflow& previousdocumentstate() const;
  inline ::Diadoc::Api::Proto::Docflow::DocumentWithDocflow* mutable_previousdocumentstate();
  inline ::Diadoc::Api::Proto::Docflow::DocumentWithDocflow* release_previousdocumentstate();
  inline void set_allocated_previousdocumentstate(::Diadoc::Api::Proto::Docflow::DocumentWithDocflow* previousdocumentstate);

  // @@protoc_insertion_point(class_scope:Diadoc.Api.Proto.Docflow.DocflowEvent)
 private:
  inline void set_has_eventid();
  inline void clear_has_eventid();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_documentid();
  inline void clear_has_documentid();
  inline void set_has_indexkey();
  inline void clear_has_indexkey();
  inline void set_has_document();
  inline void clear_has_document();
  inline void set_has_previouseventid();
  inline void clear_has_previouseventid();
  inline void set_has_previousdocumentstate();
  inline void clear_has_previousdocumentstate();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* eventid_;
  ::Diadoc::Api::Proto::Timestamp* timestamp_;
  ::Diadoc::Api::Proto::DocumentId* documentid_;
  ::std::string* indexkey_;
  ::Diadoc::Api::Proto::Docflow::DocumentWithDocflow* document_;
  ::std::string* previouseventid_;
  ::Diadoc::Api::Proto::Docflow::DocumentWithDocflow* previousdocumentstate_;
  friend void  protobuf_AddDesc_Docflow_2fDocflowApi_2eproto();
  friend void protobuf_AssignDesc_Docflow_2fDocflowApi_2eproto();
  friend void protobuf_ShutdownFile_Docflow_2fDocflowApi_2eproto();

  void InitAsDefaultInstance();
  static DocflowEvent* default_instance_;
};
// ===================================================================


// ===================================================================

// GetDocflowBatchRequest

// repeated .Diadoc.Api.Proto.Docflow.GetDocflowRequest Requests = 1;
inline int GetDocflowBatchRequest::requests_size() const {
  return requests_.size();
}
inline void GetDocflowBatchRequest::clear_requests() {
  requests_.Clear();
}
inline const ::Diadoc::Api::Proto::Docflow::GetDocflowRequest& GetDocflowBatchRequest::requests(int index) const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Docflow.GetDocflowBatchRequest.Requests)
  return requests_.Get(index);
}
inline ::Diadoc::Api::Proto::Docflow::GetDocflowRequest* GetDocflowBatchRequest::mutable_requests(int index) {
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Docflow.GetDocflowBatchRequest.Requests)
  return requests_.Mutable(index);
}
inline ::Diadoc::Api::Proto::Docflow::GetDocflowRequest* GetDocflowBatchRequest::add_requests() {
  // @@protoc_insertion_point(field_add:Diadoc.Api.Proto.Docflow.GetDocflowBatchRequest.Requests)
  return requests_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Docflow::GetDocflowRequest >&
GetDocflowBatchRequest::requests() const {
  // @@protoc_insertion_point(field_list:Diadoc.Api.Proto.Docflow.GetDocflowBatchRequest.Requests)
  return requests_;
}
inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Docflow::GetDocflowRequest >*
GetDocflowBatchRequest::mutable_requests() {
  // @@protoc_insertion_point(field_mutable_list:Diadoc.Api.Proto.Docflow.GetDocflowBatchRequest.Requests)
  return &requests_;
}

// -------------------------------------------------------------------

// GetDocflowRequest

// required .Diadoc.Api.Proto.DocumentId DocumentId = 1;
inline bool GetDocflowRequest::has_documentid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetDocflowRequest::set_has_documentid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetDocflowRequest::clear_has_documentid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetDocflowRequest::clear_documentid() {
  if (documentid_ != NULL) documentid_->::Diadoc::Api::Proto::DocumentId::Clear();
  clear_has_documentid();
}
inline const ::Diadoc::Api::Proto::DocumentId& GetDocflowRequest::documentid() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Docflow.GetDocflowRequest.DocumentId)
  return documentid_ != NULL ? *documentid_ : *default_instance_->documentid_;
}
inline ::Diadoc::Api::Proto::DocumentId* GetDocflowRequest::mutable_documentid() {
  set_has_documentid();
  if (documentid_ == NULL) documentid_ = new ::Diadoc::Api::Proto::DocumentId;
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Docflow.GetDocflowRequest.DocumentId)
  return documentid_;
}
inline ::Diadoc::Api::Proto::DocumentId* GetDocflowRequest::release_documentid() {
  clear_has_documentid();
  ::Diadoc::Api::Proto::DocumentId* temp = documentid_;
  documentid_ = NULL;
  return temp;
}
inline void GetDocflowRequest::set_allocated_documentid(::Diadoc::Api::Proto::DocumentId* documentid) {
  delete documentid_;
  documentid_ = documentid;
  if (documentid) {
    set_has_documentid();
  } else {
    clear_has_documentid();
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Docflow.GetDocflowRequest.DocumentId)
}

// optional string LastEventId = 2;
inline bool GetDocflowRequest::has_lasteventid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetDocflowRequest::set_has_lasteventid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetDocflowRequest::clear_has_lasteventid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetDocflowRequest::clear_lasteventid() {
  if (lasteventid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    lasteventid_->clear();
  }
  clear_has_lasteventid();
}
inline const ::std::string& GetDocflowRequest::lasteventid() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Docflow.GetDocflowRequest.LastEventId)
  return *lasteventid_;
}
inline void GetDocflowRequest::set_lasteventid(const ::std::string& value) {
  set_has_lasteventid();
  if (lasteventid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    lasteventid_ = new ::std::string;
  }
  lasteventid_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Docflow.GetDocflowRequest.LastEventId)
}
inline void GetDocflowRequest::set_lasteventid(const char* value) {
  set_has_lasteventid();
  if (lasteventid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    lasteventid_ = new ::std::string;
  }
  lasteventid_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Docflow.GetDocflowRequest.LastEventId)
}
inline void GetDocflowRequest::set_lasteventid(const char* value, size_t size) {
  set_has_lasteventid();
  if (lasteventid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    lasteventid_ = new ::std::string;
  }
  lasteventid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Docflow.GetDocflowRequest.LastEventId)
}
inline ::std::string* GetDocflowRequest::mutable_lasteventid() {
  set_has_lasteventid();
  if (lasteventid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    lasteventid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Docflow.GetDocflowRequest.LastEventId)
  return lasteventid_;
}
inline ::std::string* GetDocflowRequest::release_lasteventid() {
  clear_has_lasteventid();
  if (lasteventid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = lasteventid_;
    lasteventid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GetDocflowRequest::set_allocated_lasteventid(::std::string* lasteventid) {
  if (lasteventid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete lasteventid_;
  }
  if (lasteventid) {
    set_has_lasteventid();
    lasteventid_ = lasteventid;
  } else {
    clear_has_lasteventid();
    lasteventid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Docflow.GetDocflowRequest.LastEventId)
}

// optional bool InjectEntityContent = 3 [default = false];
inline bool GetDocflowRequest::has_injectentitycontent() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetDocflowRequest::set_has_injectentitycontent() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetDocflowRequest::clear_has_injectentitycontent() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetDocflowRequest::clear_injectentitycontent() {
  injectentitycontent_ = false;
  clear_has_injectentitycontent();
}
inline bool GetDocflowRequest::injectentitycontent() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Docflow.GetDocflowRequest.InjectEntityContent)
  return injectentitycontent_;
}
inline void GetDocflowRequest::set_injectentitycontent(bool value) {
  set_has_injectentitycontent();
  injectentitycontent_ = value;
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Docflow.GetDocflowRequest.InjectEntityContent)
}

// -------------------------------------------------------------------

// GetDocflowBatchResponse

// repeated .Diadoc.Api.Proto.Docflow.DocumentWithDocflow Documents = 1;
inline int GetDocflowBatchResponse::documents_size() const {
  return documents_.size();
}
inline void GetDocflowBatchResponse::clear_documents() {
  documents_.Clear();
}
inline const ::Diadoc::Api::Proto::Docflow::DocumentWithDocflow& GetDocflowBatchResponse::documents(int index) const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Docflow.GetDocflowBatchResponse.Documents)
  return documents_.Get(index);
}
inline ::Diadoc::Api::Proto::Docflow::DocumentWithDocflow* GetDocflowBatchResponse::mutable_documents(int index) {
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Docflow.GetDocflowBatchResponse.Documents)
  return documents_.Mutable(index);
}
inline ::Diadoc::Api::Proto::Docflow::DocumentWithDocflow* GetDocflowBatchResponse::add_documents() {
  // @@protoc_insertion_point(field_add:Diadoc.Api.Proto.Docflow.GetDocflowBatchResponse.Documents)
  return documents_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Docflow::DocumentWithDocflow >&
GetDocflowBatchResponse::documents() const {
  // @@protoc_insertion_point(field_list:Diadoc.Api.Proto.Docflow.GetDocflowBatchResponse.Documents)
  return documents_;
}
inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Docflow::DocumentWithDocflow >*
GetDocflowBatchResponse::mutable_documents() {
  // @@protoc_insertion_point(field_mutable_list:Diadoc.Api.Proto.Docflow.GetDocflowBatchResponse.Documents)
  return &documents_;
}

// -------------------------------------------------------------------

// SearchDocflowsRequest

// required string QueryString = 1;
inline bool SearchDocflowsRequest::has_querystring() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SearchDocflowsRequest::set_has_querystring() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SearchDocflowsRequest::clear_has_querystring() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SearchDocflowsRequest::clear_querystring() {
  if (querystring_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    querystring_->clear();
  }
  clear_has_querystring();
}
inline const ::std::string& SearchDocflowsRequest::querystring() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Docflow.SearchDocflowsRequest.QueryString)
  return *querystring_;
}
inline void SearchDocflowsRequest::set_querystring(const ::std::string& value) {
  set_has_querystring();
  if (querystring_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    querystring_ = new ::std::string;
  }
  querystring_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Docflow.SearchDocflowsRequest.QueryString)
}
inline void SearchDocflowsRequest::set_querystring(const char* value) {
  set_has_querystring();
  if (querystring_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    querystring_ = new ::std::string;
  }
  querystring_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Docflow.SearchDocflowsRequest.QueryString)
}
inline void SearchDocflowsRequest::set_querystring(const char* value, size_t size) {
  set_has_querystring();
  if (querystring_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    querystring_ = new ::std::string;
  }
  querystring_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Docflow.SearchDocflowsRequest.QueryString)
}
inline ::std::string* SearchDocflowsRequest::mutable_querystring() {
  set_has_querystring();
  if (querystring_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    querystring_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Docflow.SearchDocflowsRequest.QueryString)
  return querystring_;
}
inline ::std::string* SearchDocflowsRequest::release_querystring() {
  clear_has_querystring();
  if (querystring_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = querystring_;
    querystring_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SearchDocflowsRequest::set_allocated_querystring(::std::string* querystring) {
  if (querystring_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete querystring_;
  }
  if (querystring) {
    set_has_querystring();
    querystring_ = querystring;
  } else {
    clear_has_querystring();
    querystring_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Docflow.SearchDocflowsRequest.QueryString)
}

// optional int32 Count = 2 [default = 100];
inline bool SearchDocflowsRequest::has_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SearchDocflowsRequest::set_has_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SearchDocflowsRequest::clear_has_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SearchDocflowsRequest::clear_count() {
  count_ = 100;
  clear_has_count();
}
inline ::google::protobuf::int32 SearchDocflowsRequest::count() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Docflow.SearchDocflowsRequest.Count)
  return count_;
}
inline void SearchDocflowsRequest::set_count(::google::protobuf::int32 value) {
  set_has_count();
  count_ = value;
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Docflow.SearchDocflowsRequest.Count)
}

// optional int32 FirstIndex = 3;
inline bool SearchDocflowsRequest::has_firstindex() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SearchDocflowsRequest::set_has_firstindex() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SearchDocflowsRequest::clear_has_firstindex() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SearchDocflowsRequest::clear_firstindex() {
  firstindex_ = 0;
  clear_has_firstindex();
}
inline ::google::protobuf::int32 SearchDocflowsRequest::firstindex() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Docflow.SearchDocflowsRequest.FirstIndex)
  return firstindex_;
}
inline void SearchDocflowsRequest::set_firstindex(::google::protobuf::int32 value) {
  set_has_firstindex();
  firstindex_ = value;
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Docflow.SearchDocflowsRequest.FirstIndex)
}

// optional .Diadoc.Api.Proto.Docflow.SearchScope Scope = 4 [default = SearchScopeAny];
inline bool SearchDocflowsRequest::has_scope() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SearchDocflowsRequest::set_has_scope() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SearchDocflowsRequest::clear_has_scope() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SearchDocflowsRequest::clear_scope() {
  scope_ = 0;
  clear_has_scope();
}
inline ::Diadoc::Api::Proto::Docflow::SearchScope SearchDocflowsRequest::scope() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Docflow.SearchDocflowsRequest.Scope)
  return static_cast< ::Diadoc::Api::Proto::Docflow::SearchScope >(scope_);
}
inline void SearchDocflowsRequest::set_scope(::Diadoc::Api::Proto::Docflow::SearchScope value) {
  assert(::Diadoc::Api::Proto::Docflow::SearchScope_IsValid(value));
  set_has_scope();
  scope_ = value;
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Docflow.SearchDocflowsRequest.Scope)
}

// optional bool InjectEntityContent = 5 [default = false];
inline bool SearchDocflowsRequest::has_injectentitycontent() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SearchDocflowsRequest::set_has_injectentitycontent() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SearchDocflowsRequest::clear_has_injectentitycontent() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SearchDocflowsRequest::clear_injectentitycontent() {
  injectentitycontent_ = false;
  clear_has_injectentitycontent();
}
inline bool SearchDocflowsRequest::injectentitycontent() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Docflow.SearchDocflowsRequest.InjectEntityContent)
  return injectentitycontent_;
}
inline void SearchDocflowsRequest::set_injectentitycontent(bool value) {
  set_has_injectentitycontent();
  injectentitycontent_ = value;
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Docflow.SearchDocflowsRequest.InjectEntityContent)
}

// -------------------------------------------------------------------

// SearchDocflowsResponse

// repeated .Diadoc.Api.Proto.Docflow.DocumentWithDocflow Documents = 1;
inline int SearchDocflowsResponse::documents_size() const {
  return documents_.size();
}
inline void SearchDocflowsResponse::clear_documents() {
  documents_.Clear();
}
inline const ::Diadoc::Api::Proto::Docflow::DocumentWithDocflow& SearchDocflowsResponse::documents(int index) const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Docflow.SearchDocflowsResponse.Documents)
  return documents_.Get(index);
}
inline ::Diadoc::Api::Proto::Docflow::DocumentWithDocflow* SearchDocflowsResponse::mutable_documents(int index) {
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Docflow.SearchDocflowsResponse.Documents)
  return documents_.Mutable(index);
}
inline ::Diadoc::Api::Proto::Docflow::DocumentWithDocflow* SearchDocflowsResponse::add_documents() {
  // @@protoc_insertion_point(field_add:Diadoc.Api.Proto.Docflow.SearchDocflowsResponse.Documents)
  return documents_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Docflow::DocumentWithDocflow >&
SearchDocflowsResponse::documents() const {
  // @@protoc_insertion_point(field_list:Diadoc.Api.Proto.Docflow.SearchDocflowsResponse.Documents)
  return documents_;
}
inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Docflow::DocumentWithDocflow >*
SearchDocflowsResponse::mutable_documents() {
  // @@protoc_insertion_point(field_mutable_list:Diadoc.Api.Proto.Docflow.SearchDocflowsResponse.Documents)
  return &documents_;
}

// optional bool HaveMoreDocuments = 2;
inline bool SearchDocflowsResponse::has_havemoredocuments() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SearchDocflowsResponse::set_has_havemoredocuments() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SearchDocflowsResponse::clear_has_havemoredocuments() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SearchDocflowsResponse::clear_havemoredocuments() {
  havemoredocuments_ = false;
  clear_has_havemoredocuments();
}
inline bool SearchDocflowsResponse::havemoredocuments() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Docflow.SearchDocflowsResponse.HaveMoreDocuments)
  return havemoredocuments_;
}
inline void SearchDocflowsResponse::set_havemoredocuments(bool value) {
  set_has_havemoredocuments();
  havemoredocuments_ = value;
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Docflow.SearchDocflowsResponse.HaveMoreDocuments)
}

// -------------------------------------------------------------------

// GetDocflowsByPacketIdRequest

// required string PacketId = 1;
inline bool GetDocflowsByPacketIdRequest::has_packetid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetDocflowsByPacketIdRequest::set_has_packetid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetDocflowsByPacketIdRequest::clear_has_packetid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetDocflowsByPacketIdRequest::clear_packetid() {
  if (packetid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    packetid_->clear();
  }
  clear_has_packetid();
}
inline const ::std::string& GetDocflowsByPacketIdRequest::packetid() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Docflow.GetDocflowsByPacketIdRequest.PacketId)
  return *packetid_;
}
inline void GetDocflowsByPacketIdRequest::set_packetid(const ::std::string& value) {
  set_has_packetid();
  if (packetid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    packetid_ = new ::std::string;
  }
  packetid_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Docflow.GetDocflowsByPacketIdRequest.PacketId)
}
inline void GetDocflowsByPacketIdRequest::set_packetid(const char* value) {
  set_has_packetid();
  if (packetid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    packetid_ = new ::std::string;
  }
  packetid_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Docflow.GetDocflowsByPacketIdRequest.PacketId)
}
inline void GetDocflowsByPacketIdRequest::set_packetid(const char* value, size_t size) {
  set_has_packetid();
  if (packetid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    packetid_ = new ::std::string;
  }
  packetid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Docflow.GetDocflowsByPacketIdRequest.PacketId)
}
inline ::std::string* GetDocflowsByPacketIdRequest::mutable_packetid() {
  set_has_packetid();
  if (packetid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    packetid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Docflow.GetDocflowsByPacketIdRequest.PacketId)
  return packetid_;
}
inline ::std::string* GetDocflowsByPacketIdRequest::release_packetid() {
  clear_has_packetid();
  if (packetid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = packetid_;
    packetid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GetDocflowsByPacketIdRequest::set_allocated_packetid(::std::string* packetid) {
  if (packetid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete packetid_;
  }
  if (packetid) {
    set_has_packetid();
    packetid_ = packetid;
  } else {
    clear_has_packetid();
    packetid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Docflow.GetDocflowsByPacketIdRequest.PacketId)
}

// optional int32 Count = 2 [default = 100];
inline bool GetDocflowsByPacketIdRequest::has_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetDocflowsByPacketIdRequest::set_has_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetDocflowsByPacketIdRequest::clear_has_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetDocflowsByPacketIdRequest::clear_count() {
  count_ = 100;
  clear_has_count();
}
inline ::google::protobuf::int32 GetDocflowsByPacketIdRequest::count() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Docflow.GetDocflowsByPacketIdRequest.Count)
  return count_;
}
inline void GetDocflowsByPacketIdRequest::set_count(::google::protobuf::int32 value) {
  set_has_count();
  count_ = value;
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Docflow.GetDocflowsByPacketIdRequest.Count)
}

// optional bool InjectEntityContent = 3 [default = false];
inline bool GetDocflowsByPacketIdRequest::has_injectentitycontent() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetDocflowsByPacketIdRequest::set_has_injectentitycontent() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetDocflowsByPacketIdRequest::clear_has_injectentitycontent() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetDocflowsByPacketIdRequest::clear_injectentitycontent() {
  injectentitycontent_ = false;
  clear_has_injectentitycontent();
}
inline bool GetDocflowsByPacketIdRequest::injectentitycontent() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Docflow.GetDocflowsByPacketIdRequest.InjectEntityContent)
  return injectentitycontent_;
}
inline void GetDocflowsByPacketIdRequest::set_injectentitycontent(bool value) {
  set_has_injectentitycontent();
  injectentitycontent_ = value;
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Docflow.GetDocflowsByPacketIdRequest.InjectEntityContent)
}

// optional bytes AfterIndexKey = 4;
inline bool GetDocflowsByPacketIdRequest::has_afterindexkey() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GetDocflowsByPacketIdRequest::set_has_afterindexkey() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GetDocflowsByPacketIdRequest::clear_has_afterindexkey() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GetDocflowsByPacketIdRequest::clear_afterindexkey() {
  if (afterindexkey_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    afterindexkey_->clear();
  }
  clear_has_afterindexkey();
}
inline const ::std::string& GetDocflowsByPacketIdRequest::afterindexkey() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Docflow.GetDocflowsByPacketIdRequest.AfterIndexKey)
  return *afterindexkey_;
}
inline void GetDocflowsByPacketIdRequest::set_afterindexkey(const ::std::string& value) {
  set_has_afterindexkey();
  if (afterindexkey_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    afterindexkey_ = new ::std::string;
  }
  afterindexkey_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Docflow.GetDocflowsByPacketIdRequest.AfterIndexKey)
}
inline void GetDocflowsByPacketIdRequest::set_afterindexkey(const char* value) {
  set_has_afterindexkey();
  if (afterindexkey_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    afterindexkey_ = new ::std::string;
  }
  afterindexkey_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Docflow.GetDocflowsByPacketIdRequest.AfterIndexKey)
}
inline void GetDocflowsByPacketIdRequest::set_afterindexkey(const void* value, size_t size) {
  set_has_afterindexkey();
  if (afterindexkey_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    afterindexkey_ = new ::std::string;
  }
  afterindexkey_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Docflow.GetDocflowsByPacketIdRequest.AfterIndexKey)
}
inline ::std::string* GetDocflowsByPacketIdRequest::mutable_afterindexkey() {
  set_has_afterindexkey();
  if (afterindexkey_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    afterindexkey_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Docflow.GetDocflowsByPacketIdRequest.AfterIndexKey)
  return afterindexkey_;
}
inline ::std::string* GetDocflowsByPacketIdRequest::release_afterindexkey() {
  clear_has_afterindexkey();
  if (afterindexkey_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = afterindexkey_;
    afterindexkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GetDocflowsByPacketIdRequest::set_allocated_afterindexkey(::std::string* afterindexkey) {
  if (afterindexkey_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete afterindexkey_;
  }
  if (afterindexkey) {
    set_has_afterindexkey();
    afterindexkey_ = afterindexkey;
  } else {
    clear_has_afterindexkey();
    afterindexkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Docflow.GetDocflowsByPacketIdRequest.AfterIndexKey)
}

// -------------------------------------------------------------------

// FetchedDocument

// required .Diadoc.Api.Proto.Docflow.DocumentWithDocflow Document = 1;
inline bool FetchedDocument::has_document() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FetchedDocument::set_has_document() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FetchedDocument::clear_has_document() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FetchedDocument::clear_document() {
  if (document_ != NULL) document_->::Diadoc::Api::Proto::Docflow::DocumentWithDocflow::Clear();
  clear_has_document();
}
inline const ::Diadoc::Api::Proto::Docflow::DocumentWithDocflow& FetchedDocument::document() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Docflow.FetchedDocument.Document)
  return document_ != NULL ? *document_ : *default_instance_->document_;
}
inline ::Diadoc::Api::Proto::Docflow::DocumentWithDocflow* FetchedDocument::mutable_document() {
  set_has_document();
  if (document_ == NULL) document_ = new ::Diadoc::Api::Proto::Docflow::DocumentWithDocflow;
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Docflow.FetchedDocument.Document)
  return document_;
}
inline ::Diadoc::Api::Proto::Docflow::DocumentWithDocflow* FetchedDocument::release_document() {
  clear_has_document();
  ::Diadoc::Api::Proto::Docflow::DocumentWithDocflow* temp = document_;
  document_ = NULL;
  return temp;
}
inline void FetchedDocument::set_allocated_document(::Diadoc::Api::Proto::Docflow::DocumentWithDocflow* document) {
  delete document_;
  document_ = document;
  if (document) {
    set_has_document();
  } else {
    clear_has_document();
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Docflow.FetchedDocument.Document)
}

// required bytes IndexKey = 2;
inline bool FetchedDocument::has_indexkey() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FetchedDocument::set_has_indexkey() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FetchedDocument::clear_has_indexkey() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FetchedDocument::clear_indexkey() {
  if (indexkey_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    indexkey_->clear();
  }
  clear_has_indexkey();
}
inline const ::std::string& FetchedDocument::indexkey() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Docflow.FetchedDocument.IndexKey)
  return *indexkey_;
}
inline void FetchedDocument::set_indexkey(const ::std::string& value) {
  set_has_indexkey();
  if (indexkey_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    indexkey_ = new ::std::string;
  }
  indexkey_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Docflow.FetchedDocument.IndexKey)
}
inline void FetchedDocument::set_indexkey(const char* value) {
  set_has_indexkey();
  if (indexkey_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    indexkey_ = new ::std::string;
  }
  indexkey_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Docflow.FetchedDocument.IndexKey)
}
inline void FetchedDocument::set_indexkey(const void* value, size_t size) {
  set_has_indexkey();
  if (indexkey_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    indexkey_ = new ::std::string;
  }
  indexkey_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Docflow.FetchedDocument.IndexKey)
}
inline ::std::string* FetchedDocument::mutable_indexkey() {
  set_has_indexkey();
  if (indexkey_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    indexkey_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Docflow.FetchedDocument.IndexKey)
  return indexkey_;
}
inline ::std::string* FetchedDocument::release_indexkey() {
  clear_has_indexkey();
  if (indexkey_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = indexkey_;
    indexkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void FetchedDocument::set_allocated_indexkey(::std::string* indexkey) {
  if (indexkey_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete indexkey_;
  }
  if (indexkey) {
    set_has_indexkey();
    indexkey_ = indexkey;
  } else {
    clear_has_indexkey();
    indexkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Docflow.FetchedDocument.IndexKey)
}

// -------------------------------------------------------------------

// GetDocflowsByPacketIdResponse

// repeated .Diadoc.Api.Proto.Docflow.FetchedDocument Documents = 1;
inline int GetDocflowsByPacketIdResponse::documents_size() const {
  return documents_.size();
}
inline void GetDocflowsByPacketIdResponse::clear_documents() {
  documents_.Clear();
}
inline const ::Diadoc::Api::Proto::Docflow::FetchedDocument& GetDocflowsByPacketIdResponse::documents(int index) const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Docflow.GetDocflowsByPacketIdResponse.Documents)
  return documents_.Get(index);
}
inline ::Diadoc::Api::Proto::Docflow::FetchedDocument* GetDocflowsByPacketIdResponse::mutable_documents(int index) {
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Docflow.GetDocflowsByPacketIdResponse.Documents)
  return documents_.Mutable(index);
}
inline ::Diadoc::Api::Proto::Docflow::FetchedDocument* GetDocflowsByPacketIdResponse::add_documents() {
  // @@protoc_insertion_point(field_add:Diadoc.Api.Proto.Docflow.GetDocflowsByPacketIdResponse.Documents)
  return documents_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Docflow::FetchedDocument >&
GetDocflowsByPacketIdResponse::documents() const {
  // @@protoc_insertion_point(field_list:Diadoc.Api.Proto.Docflow.GetDocflowsByPacketIdResponse.Documents)
  return documents_;
}
inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Docflow::FetchedDocument >*
GetDocflowsByPacketIdResponse::mutable_documents() {
  // @@protoc_insertion_point(field_mutable_list:Diadoc.Api.Proto.Docflow.GetDocflowsByPacketIdResponse.Documents)
  return &documents_;
}

// optional bytes NextPageIndexKey = 2;
inline bool GetDocflowsByPacketIdResponse::has_nextpageindexkey() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetDocflowsByPacketIdResponse::set_has_nextpageindexkey() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetDocflowsByPacketIdResponse::clear_has_nextpageindexkey() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetDocflowsByPacketIdResponse::clear_nextpageindexkey() {
  if (nextpageindexkey_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nextpageindexkey_->clear();
  }
  clear_has_nextpageindexkey();
}
inline const ::std::string& GetDocflowsByPacketIdResponse::nextpageindexkey() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Docflow.GetDocflowsByPacketIdResponse.NextPageIndexKey)
  return *nextpageindexkey_;
}
inline void GetDocflowsByPacketIdResponse::set_nextpageindexkey(const ::std::string& value) {
  set_has_nextpageindexkey();
  if (nextpageindexkey_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nextpageindexkey_ = new ::std::string;
  }
  nextpageindexkey_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Docflow.GetDocflowsByPacketIdResponse.NextPageIndexKey)
}
inline void GetDocflowsByPacketIdResponse::set_nextpageindexkey(const char* value) {
  set_has_nextpageindexkey();
  if (nextpageindexkey_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nextpageindexkey_ = new ::std::string;
  }
  nextpageindexkey_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Docflow.GetDocflowsByPacketIdResponse.NextPageIndexKey)
}
inline void GetDocflowsByPacketIdResponse::set_nextpageindexkey(const void* value, size_t size) {
  set_has_nextpageindexkey();
  if (nextpageindexkey_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nextpageindexkey_ = new ::std::string;
  }
  nextpageindexkey_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Docflow.GetDocflowsByPacketIdResponse.NextPageIndexKey)
}
inline ::std::string* GetDocflowsByPacketIdResponse::mutable_nextpageindexkey() {
  set_has_nextpageindexkey();
  if (nextpageindexkey_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nextpageindexkey_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Docflow.GetDocflowsByPacketIdResponse.NextPageIndexKey)
  return nextpageindexkey_;
}
inline ::std::string* GetDocflowsByPacketIdResponse::release_nextpageindexkey() {
  clear_has_nextpageindexkey();
  if (nextpageindexkey_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = nextpageindexkey_;
    nextpageindexkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GetDocflowsByPacketIdResponse::set_allocated_nextpageindexkey(::std::string* nextpageindexkey) {
  if (nextpageindexkey_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete nextpageindexkey_;
  }
  if (nextpageindexkey) {
    set_has_nextpageindexkey();
    nextpageindexkey_ = nextpageindexkey;
  } else {
    clear_has_nextpageindexkey();
    nextpageindexkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Docflow.GetDocflowsByPacketIdResponse.NextPageIndexKey)
}

// -------------------------------------------------------------------

// GetDocflowEventsRequest

// required .Diadoc.Api.Proto.TimeBasedFilter Filter = 1;
inline bool GetDocflowEventsRequest::has_filter() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetDocflowEventsRequest::set_has_filter() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetDocflowEventsRequest::clear_has_filter() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetDocflowEventsRequest::clear_filter() {
  if (filter_ != NULL) filter_->::Diadoc::Api::Proto::TimeBasedFilter::Clear();
  clear_has_filter();
}
inline const ::Diadoc::Api::Proto::TimeBasedFilter& GetDocflowEventsRequest::filter() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Docflow.GetDocflowEventsRequest.Filter)
  return filter_ != NULL ? *filter_ : *default_instance_->filter_;
}
inline ::Diadoc::Api::Proto::TimeBasedFilter* GetDocflowEventsRequest::mutable_filter() {
  set_has_filter();
  if (filter_ == NULL) filter_ = new ::Diadoc::Api::Proto::TimeBasedFilter;
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Docflow.GetDocflowEventsRequest.Filter)
  return filter_;
}
inline ::Diadoc::Api::Proto::TimeBasedFilter* GetDocflowEventsRequest::release_filter() {
  clear_has_filter();
  ::Diadoc::Api::Proto::TimeBasedFilter* temp = filter_;
  filter_ = NULL;
  return temp;
}
inline void GetDocflowEventsRequest::set_allocated_filter(::Diadoc::Api::Proto::TimeBasedFilter* filter) {
  delete filter_;
  filter_ = filter;
  if (filter) {
    set_has_filter();
  } else {
    clear_has_filter();
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Docflow.GetDocflowEventsRequest.Filter)
}

// optional bytes AfterIndexKey = 2;
inline bool GetDocflowEventsRequest::has_afterindexkey() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetDocflowEventsRequest::set_has_afterindexkey() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetDocflowEventsRequest::clear_has_afterindexkey() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetDocflowEventsRequest::clear_afterindexkey() {
  if (afterindexkey_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    afterindexkey_->clear();
  }
  clear_has_afterindexkey();
}
inline const ::std::string& GetDocflowEventsRequest::afterindexkey() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Docflow.GetDocflowEventsRequest.AfterIndexKey)
  return *afterindexkey_;
}
inline void GetDocflowEventsRequest::set_afterindexkey(const ::std::string& value) {
  set_has_afterindexkey();
  if (afterindexkey_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    afterindexkey_ = new ::std::string;
  }
  afterindexkey_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Docflow.GetDocflowEventsRequest.AfterIndexKey)
}
inline void GetDocflowEventsRequest::set_afterindexkey(const char* value) {
  set_has_afterindexkey();
  if (afterindexkey_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    afterindexkey_ = new ::std::string;
  }
  afterindexkey_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Docflow.GetDocflowEventsRequest.AfterIndexKey)
}
inline void GetDocflowEventsRequest::set_afterindexkey(const void* value, size_t size) {
  set_has_afterindexkey();
  if (afterindexkey_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    afterindexkey_ = new ::std::string;
  }
  afterindexkey_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Docflow.GetDocflowEventsRequest.AfterIndexKey)
}
inline ::std::string* GetDocflowEventsRequest::mutable_afterindexkey() {
  set_has_afterindexkey();
  if (afterindexkey_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    afterindexkey_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Docflow.GetDocflowEventsRequest.AfterIndexKey)
  return afterindexkey_;
}
inline ::std::string* GetDocflowEventsRequest::release_afterindexkey() {
  clear_has_afterindexkey();
  if (afterindexkey_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = afterindexkey_;
    afterindexkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GetDocflowEventsRequest::set_allocated_afterindexkey(::std::string* afterindexkey) {
  if (afterindexkey_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete afterindexkey_;
  }
  if (afterindexkey) {
    set_has_afterindexkey();
    afterindexkey_ = afterindexkey;
  } else {
    clear_has_afterindexkey();
    afterindexkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Docflow.GetDocflowEventsRequest.AfterIndexKey)
}

// optional bool PopulateDocuments = 3 [default = false];
inline bool GetDocflowEventsRequest::has_populatedocuments() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetDocflowEventsRequest::set_has_populatedocuments() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetDocflowEventsRequest::clear_has_populatedocuments() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetDocflowEventsRequest::clear_populatedocuments() {
  populatedocuments_ = false;
  clear_has_populatedocuments();
}
inline bool GetDocflowEventsRequest::populatedocuments() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Docflow.GetDocflowEventsRequest.PopulateDocuments)
  return populatedocuments_;
}
inline void GetDocflowEventsRequest::set_populatedocuments(bool value) {
  set_has_populatedocuments();
  populatedocuments_ = value;
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Docflow.GetDocflowEventsRequest.PopulateDocuments)
}

// optional bool InjectEntityContent = 4 [default = false];
inline bool GetDocflowEventsRequest::has_injectentitycontent() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GetDocflowEventsRequest::set_has_injectentitycontent() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GetDocflowEventsRequest::clear_has_injectentitycontent() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GetDocflowEventsRequest::clear_injectentitycontent() {
  injectentitycontent_ = false;
  clear_has_injectentitycontent();
}
inline bool GetDocflowEventsRequest::injectentitycontent() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Docflow.GetDocflowEventsRequest.InjectEntityContent)
  return injectentitycontent_;
}
inline void GetDocflowEventsRequest::set_injectentitycontent(bool value) {
  set_has_injectentitycontent();
  injectentitycontent_ = value;
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Docflow.GetDocflowEventsRequest.InjectEntityContent)
}

// optional bool PopulatePreviousDocumentStates = 5 [default = false];
inline bool GetDocflowEventsRequest::has_populatepreviousdocumentstates() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GetDocflowEventsRequest::set_has_populatepreviousdocumentstates() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GetDocflowEventsRequest::clear_has_populatepreviousdocumentstates() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GetDocflowEventsRequest::clear_populatepreviousdocumentstates() {
  populatepreviousdocumentstates_ = false;
  clear_has_populatepreviousdocumentstates();
}
inline bool GetDocflowEventsRequest::populatepreviousdocumentstates() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Docflow.GetDocflowEventsRequest.PopulatePreviousDocumentStates)
  return populatepreviousdocumentstates_;
}
inline void GetDocflowEventsRequest::set_populatepreviousdocumentstates(bool value) {
  set_has_populatepreviousdocumentstates();
  populatepreviousdocumentstates_ = value;
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Docflow.GetDocflowEventsRequest.PopulatePreviousDocumentStates)
}

// -------------------------------------------------------------------

// GetDocflowEventsResponse

// optional int32 TotalCount = 1;
inline bool GetDocflowEventsResponse::has_totalcount() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetDocflowEventsResponse::set_has_totalcount() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetDocflowEventsResponse::clear_has_totalcount() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetDocflowEventsResponse::clear_totalcount() {
  totalcount_ = 0;
  clear_has_totalcount();
}
inline ::google::protobuf::int32 GetDocflowEventsResponse::totalcount() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Docflow.GetDocflowEventsResponse.TotalCount)
  return totalcount_;
}
inline void GetDocflowEventsResponse::set_totalcount(::google::protobuf::int32 value) {
  set_has_totalcount();
  totalcount_ = value;
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Docflow.GetDocflowEventsResponse.TotalCount)
}

// repeated .Diadoc.Api.Proto.Docflow.DocflowEvent Events = 2;
inline int GetDocflowEventsResponse::events_size() const {
  return events_.size();
}
inline void GetDocflowEventsResponse::clear_events() {
  events_.Clear();
}
inline const ::Diadoc::Api::Proto::Docflow::DocflowEvent& GetDocflowEventsResponse::events(int index) const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Docflow.GetDocflowEventsResponse.Events)
  return events_.Get(index);
}
inline ::Diadoc::Api::Proto::Docflow::DocflowEvent* GetDocflowEventsResponse::mutable_events(int index) {
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Docflow.GetDocflowEventsResponse.Events)
  return events_.Mutable(index);
}
inline ::Diadoc::Api::Proto::Docflow::DocflowEvent* GetDocflowEventsResponse::add_events() {
  // @@protoc_insertion_point(field_add:Diadoc.Api.Proto.Docflow.GetDocflowEventsResponse.Events)
  return events_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Docflow::DocflowEvent >&
GetDocflowEventsResponse::events() const {
  // @@protoc_insertion_point(field_list:Diadoc.Api.Proto.Docflow.GetDocflowEventsResponse.Events)
  return events_;
}
inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Docflow::DocflowEvent >*
GetDocflowEventsResponse::mutable_events() {
  // @@protoc_insertion_point(field_mutable_list:Diadoc.Api.Proto.Docflow.GetDocflowEventsResponse.Events)
  return &events_;
}

// required .Diadoc.Api.Proto.TotalCountType TotalCountType = 3;
inline bool GetDocflowEventsResponse::has_totalcounttype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetDocflowEventsResponse::set_has_totalcounttype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetDocflowEventsResponse::clear_has_totalcounttype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetDocflowEventsResponse::clear_totalcounttype() {
  totalcounttype_ = 0;
  clear_has_totalcounttype();
}
inline ::Diadoc::Api::Proto::TotalCountType GetDocflowEventsResponse::totalcounttype() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Docflow.GetDocflowEventsResponse.TotalCountType)
  return static_cast< ::Diadoc::Api::Proto::TotalCountType >(totalcounttype_);
}
inline void GetDocflowEventsResponse::set_totalcounttype(::Diadoc::Api::Proto::TotalCountType value) {
  assert(::Diadoc::Api::Proto::TotalCountType_IsValid(value));
  set_has_totalcounttype();
  totalcounttype_ = value;
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Docflow.GetDocflowEventsResponse.TotalCountType)
}

// -------------------------------------------------------------------

// DocflowEvent

// optional string EventId = 1;
inline bool DocflowEvent::has_eventid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DocflowEvent::set_has_eventid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DocflowEvent::clear_has_eventid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DocflowEvent::clear_eventid() {
  if (eventid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    eventid_->clear();
  }
  clear_has_eventid();
}
inline const ::std::string& DocflowEvent::eventid() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Docflow.DocflowEvent.EventId)
  return *eventid_;
}
inline void DocflowEvent::set_eventid(const ::std::string& value) {
  set_has_eventid();
  if (eventid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    eventid_ = new ::std::string;
  }
  eventid_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Docflow.DocflowEvent.EventId)
}
inline void DocflowEvent::set_eventid(const char* value) {
  set_has_eventid();
  if (eventid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    eventid_ = new ::std::string;
  }
  eventid_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Docflow.DocflowEvent.EventId)
}
inline void DocflowEvent::set_eventid(const char* value, size_t size) {
  set_has_eventid();
  if (eventid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    eventid_ = new ::std::string;
  }
  eventid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Docflow.DocflowEvent.EventId)
}
inline ::std::string* DocflowEvent::mutable_eventid() {
  set_has_eventid();
  if (eventid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    eventid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Docflow.DocflowEvent.EventId)
  return eventid_;
}
inline ::std::string* DocflowEvent::release_eventid() {
  clear_has_eventid();
  if (eventid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = eventid_;
    eventid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void DocflowEvent::set_allocated_eventid(::std::string* eventid) {
  if (eventid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete eventid_;
  }
  if (eventid) {
    set_has_eventid();
    eventid_ = eventid;
  } else {
    clear_has_eventid();
    eventid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Docflow.DocflowEvent.EventId)
}

// optional .Diadoc.Api.Proto.Timestamp Timestamp = 2;
inline bool DocflowEvent::has_timestamp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DocflowEvent::set_has_timestamp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DocflowEvent::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DocflowEvent::clear_timestamp() {
  if (timestamp_ != NULL) timestamp_->::Diadoc::Api::Proto::Timestamp::Clear();
  clear_has_timestamp();
}
inline const ::Diadoc::Api::Proto::Timestamp& DocflowEvent::timestamp() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Docflow.DocflowEvent.Timestamp)
  return timestamp_ != NULL ? *timestamp_ : *default_instance_->timestamp_;
}
inline ::Diadoc::Api::Proto::Timestamp* DocflowEvent::mutable_timestamp() {
  set_has_timestamp();
  if (timestamp_ == NULL) timestamp_ = new ::Diadoc::Api::Proto::Timestamp;
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Docflow.DocflowEvent.Timestamp)
  return timestamp_;
}
inline ::Diadoc::Api::Proto::Timestamp* DocflowEvent::release_timestamp() {
  clear_has_timestamp();
  ::Diadoc::Api::Proto::Timestamp* temp = timestamp_;
  timestamp_ = NULL;
  return temp;
}
inline void DocflowEvent::set_allocated_timestamp(::Diadoc::Api::Proto::Timestamp* timestamp) {
  delete timestamp_;
  timestamp_ = timestamp;
  if (timestamp) {
    set_has_timestamp();
  } else {
    clear_has_timestamp();
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Docflow.DocflowEvent.Timestamp)
}

// optional .Diadoc.Api.Proto.DocumentId DocumentId = 3;
inline bool DocflowEvent::has_documentid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DocflowEvent::set_has_documentid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DocflowEvent::clear_has_documentid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DocflowEvent::clear_documentid() {
  if (documentid_ != NULL) documentid_->::Diadoc::Api::Proto::DocumentId::Clear();
  clear_has_documentid();
}
inline const ::Diadoc::Api::Proto::DocumentId& DocflowEvent::documentid() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Docflow.DocflowEvent.DocumentId)
  return documentid_ != NULL ? *documentid_ : *default_instance_->documentid_;
}
inline ::Diadoc::Api::Proto::DocumentId* DocflowEvent::mutable_documentid() {
  set_has_documentid();
  if (documentid_ == NULL) documentid_ = new ::Diadoc::Api::Proto::DocumentId;
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Docflow.DocflowEvent.DocumentId)
  return documentid_;
}
inline ::Diadoc::Api::Proto::DocumentId* DocflowEvent::release_documentid() {
  clear_has_documentid();
  ::Diadoc::Api::Proto::DocumentId* temp = documentid_;
  documentid_ = NULL;
  return temp;
}
inline void DocflowEvent::set_allocated_documentid(::Diadoc::Api::Proto::DocumentId* documentid) {
  delete documentid_;
  documentid_ = documentid;
  if (documentid) {
    set_has_documentid();
  } else {
    clear_has_documentid();
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Docflow.DocflowEvent.DocumentId)
}

// optional bytes IndexKey = 4;
inline bool DocflowEvent::has_indexkey() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DocflowEvent::set_has_indexkey() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DocflowEvent::clear_has_indexkey() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DocflowEvent::clear_indexkey() {
  if (indexkey_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    indexkey_->clear();
  }
  clear_has_indexkey();
}
inline const ::std::string& DocflowEvent::indexkey() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Docflow.DocflowEvent.IndexKey)
  return *indexkey_;
}
inline void DocflowEvent::set_indexkey(const ::std::string& value) {
  set_has_indexkey();
  if (indexkey_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    indexkey_ = new ::std::string;
  }
  indexkey_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Docflow.DocflowEvent.IndexKey)
}
inline void DocflowEvent::set_indexkey(const char* value) {
  set_has_indexkey();
  if (indexkey_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    indexkey_ = new ::std::string;
  }
  indexkey_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Docflow.DocflowEvent.IndexKey)
}
inline void DocflowEvent::set_indexkey(const void* value, size_t size) {
  set_has_indexkey();
  if (indexkey_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    indexkey_ = new ::std::string;
  }
  indexkey_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Docflow.DocflowEvent.IndexKey)
}
inline ::std::string* DocflowEvent::mutable_indexkey() {
  set_has_indexkey();
  if (indexkey_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    indexkey_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Docflow.DocflowEvent.IndexKey)
  return indexkey_;
}
inline ::std::string* DocflowEvent::release_indexkey() {
  clear_has_indexkey();
  if (indexkey_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = indexkey_;
    indexkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void DocflowEvent::set_allocated_indexkey(::std::string* indexkey) {
  if (indexkey_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete indexkey_;
  }
  if (indexkey) {
    set_has_indexkey();
    indexkey_ = indexkey;
  } else {
    clear_has_indexkey();
    indexkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Docflow.DocflowEvent.IndexKey)
}

// optional .Diadoc.Api.Proto.Docflow.DocumentWithDocflow Document = 5;
inline bool DocflowEvent::has_document() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DocflowEvent::set_has_document() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DocflowEvent::clear_has_document() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DocflowEvent::clear_document() {
  if (document_ != NULL) document_->::Diadoc::Api::Proto::Docflow::DocumentWithDocflow::Clear();
  clear_has_document();
}
inline const ::Diadoc::Api::Proto::Docflow::DocumentWithDocflow& DocflowEvent::document() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Docflow.DocflowEvent.Document)
  return document_ != NULL ? *document_ : *default_instance_->document_;
}
inline ::Diadoc::Api::Proto::Docflow::DocumentWithDocflow* DocflowEvent::mutable_document() {
  set_has_document();
  if (document_ == NULL) document_ = new ::Diadoc::Api::Proto::Docflow::DocumentWithDocflow;
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Docflow.DocflowEvent.Document)
  return document_;
}
inline ::Diadoc::Api::Proto::Docflow::DocumentWithDocflow* DocflowEvent::release_document() {
  clear_has_document();
  ::Diadoc::Api::Proto::Docflow::DocumentWithDocflow* temp = document_;
  document_ = NULL;
  return temp;
}
inline void DocflowEvent::set_allocated_document(::Diadoc::Api::Proto::Docflow::DocumentWithDocflow* document) {
  delete document_;
  document_ = document;
  if (document) {
    set_has_document();
  } else {
    clear_has_document();
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Docflow.DocflowEvent.Document)
}

// optional string PreviousEventId = 6;
inline bool DocflowEvent::has_previouseventid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DocflowEvent::set_has_previouseventid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void DocflowEvent::clear_has_previouseventid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void DocflowEvent::clear_previouseventid() {
  if (previouseventid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    previouseventid_->clear();
  }
  clear_has_previouseventid();
}
inline const ::std::string& DocflowEvent::previouseventid() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Docflow.DocflowEvent.PreviousEventId)
  return *previouseventid_;
}
inline void DocflowEvent::set_previouseventid(const ::std::string& value) {
  set_has_previouseventid();
  if (previouseventid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    previouseventid_ = new ::std::string;
  }
  previouseventid_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Docflow.DocflowEvent.PreviousEventId)
}
inline void DocflowEvent::set_previouseventid(const char* value) {
  set_has_previouseventid();
  if (previouseventid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    previouseventid_ = new ::std::string;
  }
  previouseventid_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Docflow.DocflowEvent.PreviousEventId)
}
inline void DocflowEvent::set_previouseventid(const char* value, size_t size) {
  set_has_previouseventid();
  if (previouseventid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    previouseventid_ = new ::std::string;
  }
  previouseventid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Docflow.DocflowEvent.PreviousEventId)
}
inline ::std::string* DocflowEvent::mutable_previouseventid() {
  set_has_previouseventid();
  if (previouseventid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    previouseventid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Docflow.DocflowEvent.PreviousEventId)
  return previouseventid_;
}
inline ::std::string* DocflowEvent::release_previouseventid() {
  clear_has_previouseventid();
  if (previouseventid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = previouseventid_;
    previouseventid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void DocflowEvent::set_allocated_previouseventid(::std::string* previouseventid) {
  if (previouseventid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete previouseventid_;
  }
  if (previouseventid) {
    set_has_previouseventid();
    previouseventid_ = previouseventid;
  } else {
    clear_has_previouseventid();
    previouseventid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Docflow.DocflowEvent.PreviousEventId)
}

// optional .Diadoc.Api.Proto.Docflow.DocumentWithDocflow PreviousDocumentState = 7;
inline bool DocflowEvent::has_previousdocumentstate() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void DocflowEvent::set_has_previousdocumentstate() {
  _has_bits_[0] |= 0x00000040u;
}
inline void DocflowEvent::clear_has_previousdocumentstate() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void DocflowEvent::clear_previousdocumentstate() {
  if (previousdocumentstate_ != NULL) previousdocumentstate_->::Diadoc::Api::Proto::Docflow::DocumentWithDocflow::Clear();
  clear_has_previousdocumentstate();
}
inline const ::Diadoc::Api::Proto::Docflow::DocumentWithDocflow& DocflowEvent::previousdocumentstate() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Docflow.DocflowEvent.PreviousDocumentState)
  return previousdocumentstate_ != NULL ? *previousdocumentstate_ : *default_instance_->previousdocumentstate_;
}
inline ::Diadoc::Api::Proto::Docflow::DocumentWithDocflow* DocflowEvent::mutable_previousdocumentstate() {
  set_has_previousdocumentstate();
  if (previousdocumentstate_ == NULL) previousdocumentstate_ = new ::Diadoc::Api::Proto::Docflow::DocumentWithDocflow;
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Docflow.DocflowEvent.PreviousDocumentState)
  return previousdocumentstate_;
}
inline ::Diadoc::Api::Proto::Docflow::DocumentWithDocflow* DocflowEvent::release_previousdocumentstate() {
  clear_has_previousdocumentstate();
  ::Diadoc::Api::Proto::Docflow::DocumentWithDocflow* temp = previousdocumentstate_;
  previousdocumentstate_ = NULL;
  return temp;
}
inline void DocflowEvent::set_allocated_previousdocumentstate(::Diadoc::Api::Proto::Docflow::DocumentWithDocflow* previousdocumentstate) {
  delete previousdocumentstate_;
  previousdocumentstate_ = previousdocumentstate;
  if (previousdocumentstate) {
    set_has_previousdocumentstate();
  } else {
    clear_has_previousdocumentstate();
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Docflow.DocflowEvent.PreviousDocumentState)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace Docflow
}  // namespace Proto
}  // namespace Api
}  // namespace Diadoc

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::Diadoc::Api::Proto::Docflow::SearchScope> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Diadoc::Api::Proto::Docflow::SearchScope>() {
  return ::Diadoc::Api::Proto::Docflow::SearchScope_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_Docflow_2fDocflowApi_2eproto__INCLUDED
