// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Docflow/AttachmentV3.proto

#ifndef PROTOBUF_Docflow_2fAttachmentV3_2eproto__INCLUDED
#define PROTOBUF_Docflow_2fAttachmentV3_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include "Docflow/Attachment.pb.h"
#include "Content.pb.h"
#include "Timestamp.pb.h"
#include "SignatureVerificationResult.pb.h"
// @@protoc_insertion_point(includes)

namespace Diadoc {
namespace Api {
namespace Proto {
namespace Docflow {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_Docflow_2fAttachmentV3_2eproto();
void protobuf_AssignDesc_Docflow_2fAttachmentV3_2eproto();
void protobuf_ShutdownFile_Docflow_2fAttachmentV3_2eproto();

class SignatureV3;
class SignedAttachmentV3;

// ===================================================================

class SignatureV3 : public ::google::protobuf::Message {
 public:
  SignatureV3();
  virtual ~SignatureV3();

  SignatureV3(const SignatureV3& from);

  inline SignatureV3& operator=(const SignatureV3& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SignatureV3& default_instance();

  void Swap(SignatureV3* other);

  // implements Message ----------------------------------------------

  SignatureV3* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SignatureV3& from);
  void MergeFrom(const SignatureV3& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Diadoc.Api.Proto.Docflow.Entity Cms = 1;
  inline bool has_cms() const;
  inline void clear_cms();
  static const int kCmsFieldNumber = 1;
  inline const ::Diadoc::Api::Proto::Docflow::Entity& cms() const;
  inline ::Diadoc::Api::Proto::Docflow::Entity* mutable_cms();
  inline ::Diadoc::Api::Proto::Docflow::Entity* release_cms();
  inline void set_allocated_cms(::Diadoc::Api::Proto::Docflow::Entity* cms);

  // optional .Diadoc.Api.Proto.Docflow.Entity CadesT = 2;
  inline bool has_cadest() const;
  inline void clear_cadest();
  static const int kCadesTFieldNumber = 2;
  inline const ::Diadoc::Api::Proto::Docflow::Entity& cadest() const;
  inline ::Diadoc::Api::Proto::Docflow::Entity* mutable_cadest();
  inline ::Diadoc::Api::Proto::Docflow::Entity* release_cadest();
  inline void set_allocated_cadest(::Diadoc::Api::Proto::Docflow::Entity* cadest);

  // required string SignerBoxId = 3;
  inline bool has_signerboxid() const;
  inline void clear_signerboxid();
  static const int kSignerBoxIdFieldNumber = 3;
  inline const ::std::string& signerboxid() const;
  inline void set_signerboxid(const ::std::string& value);
  inline void set_signerboxid(const char* value);
  inline void set_signerboxid(const char* value, size_t size);
  inline ::std::string* mutable_signerboxid();
  inline ::std::string* release_signerboxid();
  inline void set_allocated_signerboxid(::std::string* signerboxid);

  // required string SignerDepartmentId = 4;
  inline bool has_signerdepartmentid() const;
  inline void clear_signerdepartmentid();
  static const int kSignerDepartmentIdFieldNumber = 4;
  inline const ::std::string& signerdepartmentid() const;
  inline void set_signerdepartmentid(const ::std::string& value);
  inline void set_signerdepartmentid(const char* value);
  inline void set_signerdepartmentid(const char* value, size_t size);
  inline ::std::string* mutable_signerdepartmentid();
  inline ::std::string* release_signerdepartmentid();
  inline void set_allocated_signerdepartmentid(::std::string* signerdepartmentid);

  // required bool IsValid = 5;
  inline bool has_isvalid() const;
  inline void clear_isvalid();
  static const int kIsValidFieldNumber = 5;
  inline bool isvalid() const;
  inline void set_isvalid(bool value);

  // optional .Diadoc.Api.Proto.SignatureVerificationResult VerificationResult = 6;
  inline bool has_verificationresult() const;
  inline void clear_verificationresult();
  static const int kVerificationResultFieldNumber = 6;
  inline const ::Diadoc::Api::Proto::SignatureVerificationResult& verificationresult() const;
  inline ::Diadoc::Api::Proto::SignatureVerificationResult* mutable_verificationresult();
  inline ::Diadoc::Api::Proto::SignatureVerificationResult* release_verificationresult();
  inline void set_allocated_verificationresult(::Diadoc::Api::Proto::SignatureVerificationResult* verificationresult);

  // optional .Diadoc.Api.Proto.Timestamp DeliveredAt = 7;
  inline bool has_deliveredat() const;
  inline void clear_deliveredat();
  static const int kDeliveredAtFieldNumber = 7;
  inline const ::Diadoc::Api::Proto::Timestamp& deliveredat() const;
  inline ::Diadoc::Api::Proto::Timestamp* mutable_deliveredat();
  inline ::Diadoc::Api::Proto::Timestamp* release_deliveredat();
  inline void set_allocated_deliveredat(::Diadoc::Api::Proto::Timestamp* deliveredat);

  // @@protoc_insertion_point(class_scope:Diadoc.Api.Proto.Docflow.SignatureV3)
 private:
  inline void set_has_cms();
  inline void clear_has_cms();
  inline void set_has_cadest();
  inline void clear_has_cadest();
  inline void set_has_signerboxid();
  inline void clear_has_signerboxid();
  inline void set_has_signerdepartmentid();
  inline void clear_has_signerdepartmentid();
  inline void set_has_isvalid();
  inline void clear_has_isvalid();
  inline void set_has_verificationresult();
  inline void clear_has_verificationresult();
  inline void set_has_deliveredat();
  inline void clear_has_deliveredat();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::Diadoc::Api::Proto::Docflow::Entity* cms_;
  ::Diadoc::Api::Proto::Docflow::Entity* cadest_;
  ::std::string* signerboxid_;
  ::std::string* signerdepartmentid_;
  ::Diadoc::Api::Proto::SignatureVerificationResult* verificationresult_;
  ::Diadoc::Api::Proto::Timestamp* deliveredat_;
  bool isvalid_;
  friend void  protobuf_AddDesc_Docflow_2fAttachmentV3_2eproto();
  friend void protobuf_AssignDesc_Docflow_2fAttachmentV3_2eproto();
  friend void protobuf_ShutdownFile_Docflow_2fAttachmentV3_2eproto();

  void InitAsDefaultInstance();
  static SignatureV3* default_instance_;
};
// -------------------------------------------------------------------

class SignedAttachmentV3 : public ::google::protobuf::Message {
 public:
  SignedAttachmentV3();
  virtual ~SignedAttachmentV3();

  SignedAttachmentV3(const SignedAttachmentV3& from);

  inline SignedAttachmentV3& operator=(const SignedAttachmentV3& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SignedAttachmentV3& default_instance();

  void Swap(SignedAttachmentV3* other);

  // implements Message ----------------------------------------------

  SignedAttachmentV3* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SignedAttachmentV3& from);
  void MergeFrom(const SignedAttachmentV3& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Diadoc.Api.Proto.Docflow.Attachment Attachment = 1;
  inline bool has_attachment() const;
  inline void clear_attachment();
  static const int kAttachmentFieldNumber = 1;
  inline const ::Diadoc::Api::Proto::Docflow::Attachment& attachment() const;
  inline ::Diadoc::Api::Proto::Docflow::Attachment* mutable_attachment();
  inline ::Diadoc::Api::Proto::Docflow::Attachment* release_attachment();
  inline void set_allocated_attachment(::Diadoc::Api::Proto::Docflow::Attachment* attachment);

  // optional .Diadoc.Api.Proto.Docflow.SignatureV3 Signature = 2;
  inline bool has_signature() const;
  inline void clear_signature();
  static const int kSignatureFieldNumber = 2;
  inline const ::Diadoc::Api::Proto::Docflow::SignatureV3& signature() const;
  inline ::Diadoc::Api::Proto::Docflow::SignatureV3* mutable_signature();
  inline ::Diadoc::Api::Proto::Docflow::SignatureV3* release_signature();
  inline void set_allocated_signature(::Diadoc::Api::Proto::Docflow::SignatureV3* signature);

  // optional .Diadoc.Api.Proto.Docflow.Entity Comment = 3;
  inline bool has_comment() const;
  inline void clear_comment();
  static const int kCommentFieldNumber = 3;
  inline const ::Diadoc::Api::Proto::Docflow::Entity& comment() const;
  inline ::Diadoc::Api::Proto::Docflow::Entity* mutable_comment();
  inline ::Diadoc::Api::Proto::Docflow::Entity* release_comment();
  inline void set_allocated_comment(::Diadoc::Api::Proto::Docflow::Entity* comment);

  // required string ContentTypeId = 4;
  inline bool has_contenttypeid() const;
  inline void clear_contenttypeid();
  static const int kContentTypeIdFieldNumber = 4;
  inline const ::std::string& contenttypeid() const;
  inline void set_contenttypeid(const ::std::string& value);
  inline void set_contenttypeid(const char* value);
  inline void set_contenttypeid(const char* value, size_t size);
  inline ::std::string* mutable_contenttypeid();
  inline ::std::string* release_contenttypeid();
  inline void set_allocated_contenttypeid(::std::string* contenttypeid);

  // @@protoc_insertion_point(class_scope:Diadoc.Api.Proto.Docflow.SignedAttachmentV3)
 private:
  inline void set_has_attachment();
  inline void clear_has_attachment();
  inline void set_has_signature();
  inline void clear_has_signature();
  inline void set_has_comment();
  inline void clear_has_comment();
  inline void set_has_contenttypeid();
  inline void clear_has_contenttypeid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::Diadoc::Api::Proto::Docflow::Attachment* attachment_;
  ::Diadoc::Api::Proto::Docflow::SignatureV3* signature_;
  ::Diadoc::Api::Proto::Docflow::Entity* comment_;
  ::std::string* contenttypeid_;
  friend void  protobuf_AddDesc_Docflow_2fAttachmentV3_2eproto();
  friend void protobuf_AssignDesc_Docflow_2fAttachmentV3_2eproto();
  friend void protobuf_ShutdownFile_Docflow_2fAttachmentV3_2eproto();

  void InitAsDefaultInstance();
  static SignedAttachmentV3* default_instance_;
};
// ===================================================================


// ===================================================================

// SignatureV3

// required .Diadoc.Api.Proto.Docflow.Entity Cms = 1;
inline bool SignatureV3::has_cms() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SignatureV3::set_has_cms() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SignatureV3::clear_has_cms() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SignatureV3::clear_cms() {
  if (cms_ != NULL) cms_->::Diadoc::Api::Proto::Docflow::Entity::Clear();
  clear_has_cms();
}
inline const ::Diadoc::Api::Proto::Docflow::Entity& SignatureV3::cms() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Docflow.SignatureV3.Cms)
  return cms_ != NULL ? *cms_ : *default_instance_->cms_;
}
inline ::Diadoc::Api::Proto::Docflow::Entity* SignatureV3::mutable_cms() {
  set_has_cms();
  if (cms_ == NULL) cms_ = new ::Diadoc::Api::Proto::Docflow::Entity;
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Docflow.SignatureV3.Cms)
  return cms_;
}
inline ::Diadoc::Api::Proto::Docflow::Entity* SignatureV3::release_cms() {
  clear_has_cms();
  ::Diadoc::Api::Proto::Docflow::Entity* temp = cms_;
  cms_ = NULL;
  return temp;
}
inline void SignatureV3::set_allocated_cms(::Diadoc::Api::Proto::Docflow::Entity* cms) {
  delete cms_;
  cms_ = cms;
  if (cms) {
    set_has_cms();
  } else {
    clear_has_cms();
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Docflow.SignatureV3.Cms)
}

// optional .Diadoc.Api.Proto.Docflow.Entity CadesT = 2;
inline bool SignatureV3::has_cadest() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SignatureV3::set_has_cadest() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SignatureV3::clear_has_cadest() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SignatureV3::clear_cadest() {
  if (cadest_ != NULL) cadest_->::Diadoc::Api::Proto::Docflow::Entity::Clear();
  clear_has_cadest();
}
inline const ::Diadoc::Api::Proto::Docflow::Entity& SignatureV3::cadest() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Docflow.SignatureV3.CadesT)
  return cadest_ != NULL ? *cadest_ : *default_instance_->cadest_;
}
inline ::Diadoc::Api::Proto::Docflow::Entity* SignatureV3::mutable_cadest() {
  set_has_cadest();
  if (cadest_ == NULL) cadest_ = new ::Diadoc::Api::Proto::Docflow::Entity;
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Docflow.SignatureV3.CadesT)
  return cadest_;
}
inline ::Diadoc::Api::Proto::Docflow::Entity* SignatureV3::release_cadest() {
  clear_has_cadest();
  ::Diadoc::Api::Proto::Docflow::Entity* temp = cadest_;
  cadest_ = NULL;
  return temp;
}
inline void SignatureV3::set_allocated_cadest(::Diadoc::Api::Proto::Docflow::Entity* cadest) {
  delete cadest_;
  cadest_ = cadest;
  if (cadest) {
    set_has_cadest();
  } else {
    clear_has_cadest();
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Docflow.SignatureV3.CadesT)
}

// required string SignerBoxId = 3;
inline bool SignatureV3::has_signerboxid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SignatureV3::set_has_signerboxid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SignatureV3::clear_has_signerboxid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SignatureV3::clear_signerboxid() {
  if (signerboxid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    signerboxid_->clear();
  }
  clear_has_signerboxid();
}
inline const ::std::string& SignatureV3::signerboxid() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Docflow.SignatureV3.SignerBoxId)
  return *signerboxid_;
}
inline void SignatureV3::set_signerboxid(const ::std::string& value) {
  set_has_signerboxid();
  if (signerboxid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    signerboxid_ = new ::std::string;
  }
  signerboxid_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Docflow.SignatureV3.SignerBoxId)
}
inline void SignatureV3::set_signerboxid(const char* value) {
  set_has_signerboxid();
  if (signerboxid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    signerboxid_ = new ::std::string;
  }
  signerboxid_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Docflow.SignatureV3.SignerBoxId)
}
inline void SignatureV3::set_signerboxid(const char* value, size_t size) {
  set_has_signerboxid();
  if (signerboxid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    signerboxid_ = new ::std::string;
  }
  signerboxid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Docflow.SignatureV3.SignerBoxId)
}
inline ::std::string* SignatureV3::mutable_signerboxid() {
  set_has_signerboxid();
  if (signerboxid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    signerboxid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Docflow.SignatureV3.SignerBoxId)
  return signerboxid_;
}
inline ::std::string* SignatureV3::release_signerboxid() {
  clear_has_signerboxid();
  if (signerboxid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = signerboxid_;
    signerboxid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SignatureV3::set_allocated_signerboxid(::std::string* signerboxid) {
  if (signerboxid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete signerboxid_;
  }
  if (signerboxid) {
    set_has_signerboxid();
    signerboxid_ = signerboxid;
  } else {
    clear_has_signerboxid();
    signerboxid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Docflow.SignatureV3.SignerBoxId)
}

// required string SignerDepartmentId = 4;
inline bool SignatureV3::has_signerdepartmentid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SignatureV3::set_has_signerdepartmentid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SignatureV3::clear_has_signerdepartmentid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SignatureV3::clear_signerdepartmentid() {
  if (signerdepartmentid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    signerdepartmentid_->clear();
  }
  clear_has_signerdepartmentid();
}
inline const ::std::string& SignatureV3::signerdepartmentid() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Docflow.SignatureV3.SignerDepartmentId)
  return *signerdepartmentid_;
}
inline void SignatureV3::set_signerdepartmentid(const ::std::string& value) {
  set_has_signerdepartmentid();
  if (signerdepartmentid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    signerdepartmentid_ = new ::std::string;
  }
  signerdepartmentid_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Docflow.SignatureV3.SignerDepartmentId)
}
inline void SignatureV3::set_signerdepartmentid(const char* value) {
  set_has_signerdepartmentid();
  if (signerdepartmentid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    signerdepartmentid_ = new ::std::string;
  }
  signerdepartmentid_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Docflow.SignatureV3.SignerDepartmentId)
}
inline void SignatureV3::set_signerdepartmentid(const char* value, size_t size) {
  set_has_signerdepartmentid();
  if (signerdepartmentid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    signerdepartmentid_ = new ::std::string;
  }
  signerdepartmentid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Docflow.SignatureV3.SignerDepartmentId)
}
inline ::std::string* SignatureV3::mutable_signerdepartmentid() {
  set_has_signerdepartmentid();
  if (signerdepartmentid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    signerdepartmentid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Docflow.SignatureV3.SignerDepartmentId)
  return signerdepartmentid_;
}
inline ::std::string* SignatureV3::release_signerdepartmentid() {
  clear_has_signerdepartmentid();
  if (signerdepartmentid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = signerdepartmentid_;
    signerdepartmentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SignatureV3::set_allocated_signerdepartmentid(::std::string* signerdepartmentid) {
  if (signerdepartmentid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete signerdepartmentid_;
  }
  if (signerdepartmentid) {
    set_has_signerdepartmentid();
    signerdepartmentid_ = signerdepartmentid;
  } else {
    clear_has_signerdepartmentid();
    signerdepartmentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Docflow.SignatureV3.SignerDepartmentId)
}

// required bool IsValid = 5;
inline bool SignatureV3::has_isvalid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SignatureV3::set_has_isvalid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SignatureV3::clear_has_isvalid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SignatureV3::clear_isvalid() {
  isvalid_ = false;
  clear_has_isvalid();
}
inline bool SignatureV3::isvalid() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Docflow.SignatureV3.IsValid)
  return isvalid_;
}
inline void SignatureV3::set_isvalid(bool value) {
  set_has_isvalid();
  isvalid_ = value;
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Docflow.SignatureV3.IsValid)
}

// optional .Diadoc.Api.Proto.SignatureVerificationResult VerificationResult = 6;
inline bool SignatureV3::has_verificationresult() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SignatureV3::set_has_verificationresult() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SignatureV3::clear_has_verificationresult() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SignatureV3::clear_verificationresult() {
  if (verificationresult_ != NULL) verificationresult_->::Diadoc::Api::Proto::SignatureVerificationResult::Clear();
  clear_has_verificationresult();
}
inline const ::Diadoc::Api::Proto::SignatureVerificationResult& SignatureV3::verificationresult() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Docflow.SignatureV3.VerificationResult)
  return verificationresult_ != NULL ? *verificationresult_ : *default_instance_->verificationresult_;
}
inline ::Diadoc::Api::Proto::SignatureVerificationResult* SignatureV3::mutable_verificationresult() {
  set_has_verificationresult();
  if (verificationresult_ == NULL) verificationresult_ = new ::Diadoc::Api::Proto::SignatureVerificationResult;
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Docflow.SignatureV3.VerificationResult)
  return verificationresult_;
}
inline ::Diadoc::Api::Proto::SignatureVerificationResult* SignatureV3::release_verificationresult() {
  clear_has_verificationresult();
  ::Diadoc::Api::Proto::SignatureVerificationResult* temp = verificationresult_;
  verificationresult_ = NULL;
  return temp;
}
inline void SignatureV3::set_allocated_verificationresult(::Diadoc::Api::Proto::SignatureVerificationResult* verificationresult) {
  delete verificationresult_;
  verificationresult_ = verificationresult;
  if (verificationresult) {
    set_has_verificationresult();
  } else {
    clear_has_verificationresult();
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Docflow.SignatureV3.VerificationResult)
}

// optional .Diadoc.Api.Proto.Timestamp DeliveredAt = 7;
inline bool SignatureV3::has_deliveredat() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SignatureV3::set_has_deliveredat() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SignatureV3::clear_has_deliveredat() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SignatureV3::clear_deliveredat() {
  if (deliveredat_ != NULL) deliveredat_->::Diadoc::Api::Proto::Timestamp::Clear();
  clear_has_deliveredat();
}
inline const ::Diadoc::Api::Proto::Timestamp& SignatureV3::deliveredat() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Docflow.SignatureV3.DeliveredAt)
  return deliveredat_ != NULL ? *deliveredat_ : *default_instance_->deliveredat_;
}
inline ::Diadoc::Api::Proto::Timestamp* SignatureV3::mutable_deliveredat() {
  set_has_deliveredat();
  if (deliveredat_ == NULL) deliveredat_ = new ::Diadoc::Api::Proto::Timestamp;
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Docflow.SignatureV3.DeliveredAt)
  return deliveredat_;
}
inline ::Diadoc::Api::Proto::Timestamp* SignatureV3::release_deliveredat() {
  clear_has_deliveredat();
  ::Diadoc::Api::Proto::Timestamp* temp = deliveredat_;
  deliveredat_ = NULL;
  return temp;
}
inline void SignatureV3::set_allocated_deliveredat(::Diadoc::Api::Proto::Timestamp* deliveredat) {
  delete deliveredat_;
  deliveredat_ = deliveredat;
  if (deliveredat) {
    set_has_deliveredat();
  } else {
    clear_has_deliveredat();
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Docflow.SignatureV3.DeliveredAt)
}

// -------------------------------------------------------------------

// SignedAttachmentV3

// required .Diadoc.Api.Proto.Docflow.Attachment Attachment = 1;
inline bool SignedAttachmentV3::has_attachment() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SignedAttachmentV3::set_has_attachment() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SignedAttachmentV3::clear_has_attachment() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SignedAttachmentV3::clear_attachment() {
  if (attachment_ != NULL) attachment_->::Diadoc::Api::Proto::Docflow::Attachment::Clear();
  clear_has_attachment();
}
inline const ::Diadoc::Api::Proto::Docflow::Attachment& SignedAttachmentV3::attachment() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Docflow.SignedAttachmentV3.Attachment)
  return attachment_ != NULL ? *attachment_ : *default_instance_->attachment_;
}
inline ::Diadoc::Api::Proto::Docflow::Attachment* SignedAttachmentV3::mutable_attachment() {
  set_has_attachment();
  if (attachment_ == NULL) attachment_ = new ::Diadoc::Api::Proto::Docflow::Attachment;
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Docflow.SignedAttachmentV3.Attachment)
  return attachment_;
}
inline ::Diadoc::Api::Proto::Docflow::Attachment* SignedAttachmentV3::release_attachment() {
  clear_has_attachment();
  ::Diadoc::Api::Proto::Docflow::Attachment* temp = attachment_;
  attachment_ = NULL;
  return temp;
}
inline void SignedAttachmentV3::set_allocated_attachment(::Diadoc::Api::Proto::Docflow::Attachment* attachment) {
  delete attachment_;
  attachment_ = attachment;
  if (attachment) {
    set_has_attachment();
  } else {
    clear_has_attachment();
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Docflow.SignedAttachmentV3.Attachment)
}

// optional .Diadoc.Api.Proto.Docflow.SignatureV3 Signature = 2;
inline bool SignedAttachmentV3::has_signature() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SignedAttachmentV3::set_has_signature() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SignedAttachmentV3::clear_has_signature() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SignedAttachmentV3::clear_signature() {
  if (signature_ != NULL) signature_->::Diadoc::Api::Proto::Docflow::SignatureV3::Clear();
  clear_has_signature();
}
inline const ::Diadoc::Api::Proto::Docflow::SignatureV3& SignedAttachmentV3::signature() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Docflow.SignedAttachmentV3.Signature)
  return signature_ != NULL ? *signature_ : *default_instance_->signature_;
}
inline ::Diadoc::Api::Proto::Docflow::SignatureV3* SignedAttachmentV3::mutable_signature() {
  set_has_signature();
  if (signature_ == NULL) signature_ = new ::Diadoc::Api::Proto::Docflow::SignatureV3;
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Docflow.SignedAttachmentV3.Signature)
  return signature_;
}
inline ::Diadoc::Api::Proto::Docflow::SignatureV3* SignedAttachmentV3::release_signature() {
  clear_has_signature();
  ::Diadoc::Api::Proto::Docflow::SignatureV3* temp = signature_;
  signature_ = NULL;
  return temp;
}
inline void SignedAttachmentV3::set_allocated_signature(::Diadoc::Api::Proto::Docflow::SignatureV3* signature) {
  delete signature_;
  signature_ = signature;
  if (signature) {
    set_has_signature();
  } else {
    clear_has_signature();
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Docflow.SignedAttachmentV3.Signature)
}

// optional .Diadoc.Api.Proto.Docflow.Entity Comment = 3;
inline bool SignedAttachmentV3::has_comment() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SignedAttachmentV3::set_has_comment() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SignedAttachmentV3::clear_has_comment() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SignedAttachmentV3::clear_comment() {
  if (comment_ != NULL) comment_->::Diadoc::Api::Proto::Docflow::Entity::Clear();
  clear_has_comment();
}
inline const ::Diadoc::Api::Proto::Docflow::Entity& SignedAttachmentV3::comment() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Docflow.SignedAttachmentV3.Comment)
  return comment_ != NULL ? *comment_ : *default_instance_->comment_;
}
inline ::Diadoc::Api::Proto::Docflow::Entity* SignedAttachmentV3::mutable_comment() {
  set_has_comment();
  if (comment_ == NULL) comment_ = new ::Diadoc::Api::Proto::Docflow::Entity;
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Docflow.SignedAttachmentV3.Comment)
  return comment_;
}
inline ::Diadoc::Api::Proto::Docflow::Entity* SignedAttachmentV3::release_comment() {
  clear_has_comment();
  ::Diadoc::Api::Proto::Docflow::Entity* temp = comment_;
  comment_ = NULL;
  return temp;
}
inline void SignedAttachmentV3::set_allocated_comment(::Diadoc::Api::Proto::Docflow::Entity* comment) {
  delete comment_;
  comment_ = comment;
  if (comment) {
    set_has_comment();
  } else {
    clear_has_comment();
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Docflow.SignedAttachmentV3.Comment)
}

// required string ContentTypeId = 4;
inline bool SignedAttachmentV3::has_contenttypeid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SignedAttachmentV3::set_has_contenttypeid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SignedAttachmentV3::clear_has_contenttypeid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SignedAttachmentV3::clear_contenttypeid() {
  if (contenttypeid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    contenttypeid_->clear();
  }
  clear_has_contenttypeid();
}
inline const ::std::string& SignedAttachmentV3::contenttypeid() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Docflow.SignedAttachmentV3.ContentTypeId)
  return *contenttypeid_;
}
inline void SignedAttachmentV3::set_contenttypeid(const ::std::string& value) {
  set_has_contenttypeid();
  if (contenttypeid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    contenttypeid_ = new ::std::string;
  }
  contenttypeid_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Docflow.SignedAttachmentV3.ContentTypeId)
}
inline void SignedAttachmentV3::set_contenttypeid(const char* value) {
  set_has_contenttypeid();
  if (contenttypeid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    contenttypeid_ = new ::std::string;
  }
  contenttypeid_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Docflow.SignedAttachmentV3.ContentTypeId)
}
inline void SignedAttachmentV3::set_contenttypeid(const char* value, size_t size) {
  set_has_contenttypeid();
  if (contenttypeid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    contenttypeid_ = new ::std::string;
  }
  contenttypeid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Docflow.SignedAttachmentV3.ContentTypeId)
}
inline ::std::string* SignedAttachmentV3::mutable_contenttypeid() {
  set_has_contenttypeid();
  if (contenttypeid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    contenttypeid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Docflow.SignedAttachmentV3.ContentTypeId)
  return contenttypeid_;
}
inline ::std::string* SignedAttachmentV3::release_contenttypeid() {
  clear_has_contenttypeid();
  if (contenttypeid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = contenttypeid_;
    contenttypeid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SignedAttachmentV3::set_allocated_contenttypeid(::std::string* contenttypeid) {
  if (contenttypeid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete contenttypeid_;
  }
  if (contenttypeid) {
    set_has_contenttypeid();
    contenttypeid_ = contenttypeid;
  } else {
    clear_has_contenttypeid();
    contenttypeid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Docflow.SignedAttachmentV3.ContentTypeId)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace Docflow
}  // namespace Proto
}  // namespace Api
}  // namespace Diadoc

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_Docflow_2fAttachmentV3_2eproto__INCLUDED
