// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Recognition/Recognition.proto

#ifndef PROTOBUF_Recognition_2fRecognition_2eproto__INCLUDED
#define PROTOBUF_Recognition_2fRecognition_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace Diadoc {
namespace Api {
namespace Proto {
namespace Recognition {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_Recognition_2fRecognition_2eproto();
void protobuf_AssignDesc_Recognition_2fRecognition_2eproto();
void protobuf_ShutdownFile_Recognition_2fRecognition_2eproto();

class Recognized;
class RecognizedInvoice;

enum RecognizedDocumentType {
  UnknownRecognizedDocumentType = -1,
  Invoice = 1
};
bool RecognizedDocumentType_IsValid(int value);
const RecognizedDocumentType RecognizedDocumentType_MIN = UnknownRecognizedDocumentType;
const RecognizedDocumentType RecognizedDocumentType_MAX = Invoice;
const int RecognizedDocumentType_ARRAYSIZE = RecognizedDocumentType_MAX + 1;

const ::google::protobuf::EnumDescriptor* RecognizedDocumentType_descriptor();
inline const ::std::string& RecognizedDocumentType_Name(RecognizedDocumentType value) {
  return ::google::protobuf::internal::NameOfEnum(
    RecognizedDocumentType_descriptor(), value);
}
inline bool RecognizedDocumentType_Parse(
    const ::std::string& name, RecognizedDocumentType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RecognizedDocumentType>(
    RecognizedDocumentType_descriptor(), name, value);
}
// ===================================================================

class Recognized : public ::google::protobuf::Message {
 public:
  Recognized();
  virtual ~Recognized();

  Recognized(const Recognized& from);

  inline Recognized& operator=(const Recognized& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Recognized& default_instance();

  void Swap(Recognized* other);

  // implements Message ----------------------------------------------

  Recognized* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Recognized& from);
  void MergeFrom(const Recognized& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string RecognitionId = 1;
  inline bool has_recognitionid() const;
  inline void clear_recognitionid();
  static const int kRecognitionIdFieldNumber = 1;
  inline const ::std::string& recognitionid() const;
  inline void set_recognitionid(const ::std::string& value);
  inline void set_recognitionid(const char* value);
  inline void set_recognitionid(const char* value, size_t size);
  inline ::std::string* mutable_recognitionid();
  inline ::std::string* release_recognitionid();
  inline void set_allocated_recognitionid(::std::string* recognitionid);

  // optional string ErrorMessage = 2;
  inline bool has_errormessage() const;
  inline void clear_errormessage();
  static const int kErrorMessageFieldNumber = 2;
  inline const ::std::string& errormessage() const;
  inline void set_errormessage(const ::std::string& value);
  inline void set_errormessage(const char* value);
  inline void set_errormessage(const char* value, size_t size);
  inline ::std::string* mutable_errormessage();
  inline ::std::string* release_errormessage();
  inline void set_allocated_errormessage(::std::string* errormessage);

  // optional string FileName = 3;
  inline bool has_filename() const;
  inline void clear_filename();
  static const int kFileNameFieldNumber = 3;
  inline const ::std::string& filename() const;
  inline void set_filename(const ::std::string& value);
  inline void set_filename(const char* value);
  inline void set_filename(const char* value, size_t size);
  inline ::std::string* mutable_filename();
  inline ::std::string* release_filename();
  inline void set_allocated_filename(::std::string* filename);

  // optional .Diadoc.Api.Proto.Recognition.RecognizedDocumentType DocumentType = 4 [default = UnknownRecognizedDocumentType];
  inline bool has_documenttype() const;
  inline void clear_documenttype();
  static const int kDocumentTypeFieldNumber = 4;
  inline ::Diadoc::Api::Proto::Recognition::RecognizedDocumentType documenttype() const;
  inline void set_documenttype(::Diadoc::Api::Proto::Recognition::RecognizedDocumentType value);

  // optional bytes Content = 5;
  inline bool has_content() const;
  inline void clear_content();
  static const int kContentFieldNumber = 5;
  inline const ::std::string& content() const;
  inline void set_content(const ::std::string& value);
  inline void set_content(const char* value);
  inline void set_content(const void* value, size_t size);
  inline ::std::string* mutable_content();
  inline ::std::string* release_content();
  inline void set_allocated_content(::std::string* content);

  // optional .Diadoc.Api.Proto.Recognition.RecognizedInvoice Invoice = 6;
  inline bool has_invoice() const;
  inline void clear_invoice();
  static const int kInvoiceFieldNumber = 6;
  inline const ::Diadoc::Api::Proto::Recognition::RecognizedInvoice& invoice() const;
  inline ::Diadoc::Api::Proto::Recognition::RecognizedInvoice* mutable_invoice();
  inline ::Diadoc::Api::Proto::Recognition::RecognizedInvoice* release_invoice();
  inline void set_allocated_invoice(::Diadoc::Api::Proto::Recognition::RecognizedInvoice* invoice);

  // @@protoc_insertion_point(class_scope:Diadoc.Api.Proto.Recognition.Recognized)
 private:
  inline void set_has_recognitionid();
  inline void clear_has_recognitionid();
  inline void set_has_errormessage();
  inline void clear_has_errormessage();
  inline void set_has_filename();
  inline void clear_has_filename();
  inline void set_has_documenttype();
  inline void clear_has_documenttype();
  inline void set_has_content();
  inline void clear_has_content();
  inline void set_has_invoice();
  inline void clear_has_invoice();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* recognitionid_;
  ::std::string* errormessage_;
  ::std::string* filename_;
  ::std::string* content_;
  ::Diadoc::Api::Proto::Recognition::RecognizedInvoice* invoice_;
  int documenttype_;
  friend void  protobuf_AddDesc_Recognition_2fRecognition_2eproto();
  friend void protobuf_AssignDesc_Recognition_2fRecognition_2eproto();
  friend void protobuf_ShutdownFile_Recognition_2fRecognition_2eproto();

  void InitAsDefaultInstance();
  static Recognized* default_instance_;
};
// -------------------------------------------------------------------

class RecognizedInvoice : public ::google::protobuf::Message {
 public:
  RecognizedInvoice();
  virtual ~RecognizedInvoice();

  RecognizedInvoice(const RecognizedInvoice& from);

  inline RecognizedInvoice& operator=(const RecognizedInvoice& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RecognizedInvoice& default_instance();

  void Swap(RecognizedInvoice* other);

  // implements Message ----------------------------------------------

  RecognizedInvoice* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RecognizedInvoice& from);
  void MergeFrom(const RecognizedInvoice& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string MetadataJson = 1;
  inline bool has_metadatajson() const;
  inline void clear_metadatajson();
  static const int kMetadataJsonFieldNumber = 1;
  inline const ::std::string& metadatajson() const;
  inline void set_metadatajson(const ::std::string& value);
  inline void set_metadatajson(const char* value);
  inline void set_metadatajson(const char* value, size_t size);
  inline ::std::string* mutable_metadatajson();
  inline ::std::string* release_metadatajson();
  inline void set_allocated_metadatajson(::std::string* metadatajson);

  // optional string ValidationErrorMessage = 2;
  inline bool has_validationerrormessage() const;
  inline void clear_validationerrormessage();
  static const int kValidationErrorMessageFieldNumber = 2;
  inline const ::std::string& validationerrormessage() const;
  inline void set_validationerrormessage(const ::std::string& value);
  inline void set_validationerrormessage(const char* value);
  inline void set_validationerrormessage(const char* value, size_t size);
  inline ::std::string* mutable_validationerrormessage();
  inline ::std::string* release_validationerrormessage();
  inline void set_allocated_validationerrormessage(::std::string* validationerrormessage);

  // @@protoc_insertion_point(class_scope:Diadoc.Api.Proto.Recognition.RecognizedInvoice)
 private:
  inline void set_has_metadatajson();
  inline void clear_has_metadatajson();
  inline void set_has_validationerrormessage();
  inline void clear_has_validationerrormessage();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* metadatajson_;
  ::std::string* validationerrormessage_;
  friend void  protobuf_AddDesc_Recognition_2fRecognition_2eproto();
  friend void protobuf_AssignDesc_Recognition_2fRecognition_2eproto();
  friend void protobuf_ShutdownFile_Recognition_2fRecognition_2eproto();

  void InitAsDefaultInstance();
  static RecognizedInvoice* default_instance_;
};
// ===================================================================


// ===================================================================

// Recognized

// required string RecognitionId = 1;
inline bool Recognized::has_recognitionid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Recognized::set_has_recognitionid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Recognized::clear_has_recognitionid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Recognized::clear_recognitionid() {
  if (recognitionid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    recognitionid_->clear();
  }
  clear_has_recognitionid();
}
inline const ::std::string& Recognized::recognitionid() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Recognition.Recognized.RecognitionId)
  return *recognitionid_;
}
inline void Recognized::set_recognitionid(const ::std::string& value) {
  set_has_recognitionid();
  if (recognitionid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    recognitionid_ = new ::std::string;
  }
  recognitionid_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Recognition.Recognized.RecognitionId)
}
inline void Recognized::set_recognitionid(const char* value) {
  set_has_recognitionid();
  if (recognitionid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    recognitionid_ = new ::std::string;
  }
  recognitionid_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Recognition.Recognized.RecognitionId)
}
inline void Recognized::set_recognitionid(const char* value, size_t size) {
  set_has_recognitionid();
  if (recognitionid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    recognitionid_ = new ::std::string;
  }
  recognitionid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Recognition.Recognized.RecognitionId)
}
inline ::std::string* Recognized::mutable_recognitionid() {
  set_has_recognitionid();
  if (recognitionid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    recognitionid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Recognition.Recognized.RecognitionId)
  return recognitionid_;
}
inline ::std::string* Recognized::release_recognitionid() {
  clear_has_recognitionid();
  if (recognitionid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = recognitionid_;
    recognitionid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Recognized::set_allocated_recognitionid(::std::string* recognitionid) {
  if (recognitionid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete recognitionid_;
  }
  if (recognitionid) {
    set_has_recognitionid();
    recognitionid_ = recognitionid;
  } else {
    clear_has_recognitionid();
    recognitionid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Recognition.Recognized.RecognitionId)
}

// optional string ErrorMessage = 2;
inline bool Recognized::has_errormessage() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Recognized::set_has_errormessage() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Recognized::clear_has_errormessage() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Recognized::clear_errormessage() {
  if (errormessage_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errormessage_->clear();
  }
  clear_has_errormessage();
}
inline const ::std::string& Recognized::errormessage() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Recognition.Recognized.ErrorMessage)
  return *errormessage_;
}
inline void Recognized::set_errormessage(const ::std::string& value) {
  set_has_errormessage();
  if (errormessage_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errormessage_ = new ::std::string;
  }
  errormessage_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Recognition.Recognized.ErrorMessage)
}
inline void Recognized::set_errormessage(const char* value) {
  set_has_errormessage();
  if (errormessage_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errormessage_ = new ::std::string;
  }
  errormessage_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Recognition.Recognized.ErrorMessage)
}
inline void Recognized::set_errormessage(const char* value, size_t size) {
  set_has_errormessage();
  if (errormessage_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errormessage_ = new ::std::string;
  }
  errormessage_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Recognition.Recognized.ErrorMessage)
}
inline ::std::string* Recognized::mutable_errormessage() {
  set_has_errormessage();
  if (errormessage_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errormessage_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Recognition.Recognized.ErrorMessage)
  return errormessage_;
}
inline ::std::string* Recognized::release_errormessage() {
  clear_has_errormessage();
  if (errormessage_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = errormessage_;
    errormessage_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Recognized::set_allocated_errormessage(::std::string* errormessage) {
  if (errormessage_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete errormessage_;
  }
  if (errormessage) {
    set_has_errormessage();
    errormessage_ = errormessage;
  } else {
    clear_has_errormessage();
    errormessage_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Recognition.Recognized.ErrorMessage)
}

// optional string FileName = 3;
inline bool Recognized::has_filename() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Recognized::set_has_filename() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Recognized::clear_has_filename() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Recognized::clear_filename() {
  if (filename_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    filename_->clear();
  }
  clear_has_filename();
}
inline const ::std::string& Recognized::filename() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Recognition.Recognized.FileName)
  return *filename_;
}
inline void Recognized::set_filename(const ::std::string& value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Recognition.Recognized.FileName)
}
inline void Recognized::set_filename(const char* value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Recognition.Recognized.FileName)
}
inline void Recognized::set_filename(const char* value, size_t size) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    filename_ = new ::std::string;
  }
  filename_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Recognition.Recognized.FileName)
}
inline ::std::string* Recognized::mutable_filename() {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    filename_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Recognition.Recognized.FileName)
  return filename_;
}
inline ::std::string* Recognized::release_filename() {
  clear_has_filename();
  if (filename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = filename_;
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Recognized::set_allocated_filename(::std::string* filename) {
  if (filename_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete filename_;
  }
  if (filename) {
    set_has_filename();
    filename_ = filename;
  } else {
    clear_has_filename();
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Recognition.Recognized.FileName)
}

// optional .Diadoc.Api.Proto.Recognition.RecognizedDocumentType DocumentType = 4 [default = UnknownRecognizedDocumentType];
inline bool Recognized::has_documenttype() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Recognized::set_has_documenttype() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Recognized::clear_has_documenttype() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Recognized::clear_documenttype() {
  documenttype_ = -1;
  clear_has_documenttype();
}
inline ::Diadoc::Api::Proto::Recognition::RecognizedDocumentType Recognized::documenttype() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Recognition.Recognized.DocumentType)
  return static_cast< ::Diadoc::Api::Proto::Recognition::RecognizedDocumentType >(documenttype_);
}
inline void Recognized::set_documenttype(::Diadoc::Api::Proto::Recognition::RecognizedDocumentType value) {
  assert(::Diadoc::Api::Proto::Recognition::RecognizedDocumentType_IsValid(value));
  set_has_documenttype();
  documenttype_ = value;
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Recognition.Recognized.DocumentType)
}

// optional bytes Content = 5;
inline bool Recognized::has_content() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Recognized::set_has_content() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Recognized::clear_has_content() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Recognized::clear_content() {
  if (content_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_->clear();
  }
  clear_has_content();
}
inline const ::std::string& Recognized::content() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Recognition.Recognized.Content)
  return *content_;
}
inline void Recognized::set_content(const ::std::string& value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_ = new ::std::string;
  }
  content_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Recognition.Recognized.Content)
}
inline void Recognized::set_content(const char* value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_ = new ::std::string;
  }
  content_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Recognition.Recognized.Content)
}
inline void Recognized::set_content(const void* value, size_t size) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_ = new ::std::string;
  }
  content_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Recognition.Recognized.Content)
}
inline ::std::string* Recognized::mutable_content() {
  set_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Recognition.Recognized.Content)
  return content_;
}
inline ::std::string* Recognized::release_content() {
  clear_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = content_;
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Recognized::set_allocated_content(::std::string* content) {
  if (content_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete content_;
  }
  if (content) {
    set_has_content();
    content_ = content;
  } else {
    clear_has_content();
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Recognition.Recognized.Content)
}

// optional .Diadoc.Api.Proto.Recognition.RecognizedInvoice Invoice = 6;
inline bool Recognized::has_invoice() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Recognized::set_has_invoice() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Recognized::clear_has_invoice() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Recognized::clear_invoice() {
  if (invoice_ != NULL) invoice_->::Diadoc::Api::Proto::Recognition::RecognizedInvoice::Clear();
  clear_has_invoice();
}
inline const ::Diadoc::Api::Proto::Recognition::RecognizedInvoice& Recognized::invoice() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Recognition.Recognized.Invoice)
  return invoice_ != NULL ? *invoice_ : *default_instance_->invoice_;
}
inline ::Diadoc::Api::Proto::Recognition::RecognizedInvoice* Recognized::mutable_invoice() {
  set_has_invoice();
  if (invoice_ == NULL) invoice_ = new ::Diadoc::Api::Proto::Recognition::RecognizedInvoice;
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Recognition.Recognized.Invoice)
  return invoice_;
}
inline ::Diadoc::Api::Proto::Recognition::RecognizedInvoice* Recognized::release_invoice() {
  clear_has_invoice();
  ::Diadoc::Api::Proto::Recognition::RecognizedInvoice* temp = invoice_;
  invoice_ = NULL;
  return temp;
}
inline void Recognized::set_allocated_invoice(::Diadoc::Api::Proto::Recognition::RecognizedInvoice* invoice) {
  delete invoice_;
  invoice_ = invoice;
  if (invoice) {
    set_has_invoice();
  } else {
    clear_has_invoice();
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Recognition.Recognized.Invoice)
}

// -------------------------------------------------------------------

// RecognizedInvoice

// required string MetadataJson = 1;
inline bool RecognizedInvoice::has_metadatajson() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RecognizedInvoice::set_has_metadatajson() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RecognizedInvoice::clear_has_metadatajson() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RecognizedInvoice::clear_metadatajson() {
  if (metadatajson_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    metadatajson_->clear();
  }
  clear_has_metadatajson();
}
inline const ::std::string& RecognizedInvoice::metadatajson() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Recognition.RecognizedInvoice.MetadataJson)
  return *metadatajson_;
}
inline void RecognizedInvoice::set_metadatajson(const ::std::string& value) {
  set_has_metadatajson();
  if (metadatajson_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    metadatajson_ = new ::std::string;
  }
  metadatajson_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Recognition.RecognizedInvoice.MetadataJson)
}
inline void RecognizedInvoice::set_metadatajson(const char* value) {
  set_has_metadatajson();
  if (metadatajson_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    metadatajson_ = new ::std::string;
  }
  metadatajson_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Recognition.RecognizedInvoice.MetadataJson)
}
inline void RecognizedInvoice::set_metadatajson(const char* value, size_t size) {
  set_has_metadatajson();
  if (metadatajson_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    metadatajson_ = new ::std::string;
  }
  metadatajson_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Recognition.RecognizedInvoice.MetadataJson)
}
inline ::std::string* RecognizedInvoice::mutable_metadatajson() {
  set_has_metadatajson();
  if (metadatajson_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    metadatajson_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Recognition.RecognizedInvoice.MetadataJson)
  return metadatajson_;
}
inline ::std::string* RecognizedInvoice::release_metadatajson() {
  clear_has_metadatajson();
  if (metadatajson_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = metadatajson_;
    metadatajson_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RecognizedInvoice::set_allocated_metadatajson(::std::string* metadatajson) {
  if (metadatajson_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete metadatajson_;
  }
  if (metadatajson) {
    set_has_metadatajson();
    metadatajson_ = metadatajson;
  } else {
    clear_has_metadatajson();
    metadatajson_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Recognition.RecognizedInvoice.MetadataJson)
}

// optional string ValidationErrorMessage = 2;
inline bool RecognizedInvoice::has_validationerrormessage() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RecognizedInvoice::set_has_validationerrormessage() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RecognizedInvoice::clear_has_validationerrormessage() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RecognizedInvoice::clear_validationerrormessage() {
  if (validationerrormessage_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    validationerrormessage_->clear();
  }
  clear_has_validationerrormessage();
}
inline const ::std::string& RecognizedInvoice::validationerrormessage() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Recognition.RecognizedInvoice.ValidationErrorMessage)
  return *validationerrormessage_;
}
inline void RecognizedInvoice::set_validationerrormessage(const ::std::string& value) {
  set_has_validationerrormessage();
  if (validationerrormessage_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    validationerrormessage_ = new ::std::string;
  }
  validationerrormessage_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Recognition.RecognizedInvoice.ValidationErrorMessage)
}
inline void RecognizedInvoice::set_validationerrormessage(const char* value) {
  set_has_validationerrormessage();
  if (validationerrormessage_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    validationerrormessage_ = new ::std::string;
  }
  validationerrormessage_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Recognition.RecognizedInvoice.ValidationErrorMessage)
}
inline void RecognizedInvoice::set_validationerrormessage(const char* value, size_t size) {
  set_has_validationerrormessage();
  if (validationerrormessage_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    validationerrormessage_ = new ::std::string;
  }
  validationerrormessage_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Recognition.RecognizedInvoice.ValidationErrorMessage)
}
inline ::std::string* RecognizedInvoice::mutable_validationerrormessage() {
  set_has_validationerrormessage();
  if (validationerrormessage_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    validationerrormessage_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Recognition.RecognizedInvoice.ValidationErrorMessage)
  return validationerrormessage_;
}
inline ::std::string* RecognizedInvoice::release_validationerrormessage() {
  clear_has_validationerrormessage();
  if (validationerrormessage_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = validationerrormessage_;
    validationerrormessage_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RecognizedInvoice::set_allocated_validationerrormessage(::std::string* validationerrormessage) {
  if (validationerrormessage_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete validationerrormessage_;
  }
  if (validationerrormessage) {
    set_has_validationerrormessage();
    validationerrormessage_ = validationerrormessage;
  } else {
    clear_has_validationerrormessage();
    validationerrormessage_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Recognition.RecognizedInvoice.ValidationErrorMessage)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace Recognition
}  // namespace Proto
}  // namespace Api
}  // namespace Diadoc

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::Diadoc::Api::Proto::Recognition::RecognizedDocumentType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Diadoc::Api::Proto::Recognition::RecognizedDocumentType>() {
  return ::Diadoc::Api::Proto::Recognition::RecognizedDocumentType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_Recognition_2fRecognition_2eproto__INCLUDED
