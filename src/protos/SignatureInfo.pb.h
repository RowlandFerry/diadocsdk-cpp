// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: SignatureInfo.proto

#ifndef PROTOBUF_SignatureInfo_2eproto__INCLUDED
#define PROTOBUF_SignatureInfo_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include "SignatureVerificationResult.pb.h"
#include "Timestamp.pb.h"
// @@protoc_insertion_point(includes)

namespace Diadoc {
namespace Api {
namespace Proto {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_SignatureInfo_2eproto();
void protobuf_AssignDesc_SignatureInfo_2eproto();
void protobuf_ShutdownFile_SignatureInfo_2eproto();

class SignatureInfo;

// ===================================================================

class SignatureInfo : public ::google::protobuf::Message {
 public:
  SignatureInfo();
  virtual ~SignatureInfo();

  SignatureInfo(const SignatureInfo& from);

  inline SignatureInfo& operator=(const SignatureInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SignatureInfo& default_instance();

  void Swap(SignatureInfo* other);

  // implements Message ----------------------------------------------

  SignatureInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SignatureInfo& from);
  void MergeFrom(const SignatureInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Diadoc.Api.Proto.Timestamp SigningTime = 1;
  inline bool has_signingtime() const;
  inline void clear_signingtime();
  static const int kSigningTimeFieldNumber = 1;
  inline const ::Diadoc::Api::Proto::Timestamp& signingtime() const;
  inline ::Diadoc::Api::Proto::Timestamp* mutable_signingtime();
  inline ::Diadoc::Api::Proto::Timestamp* release_signingtime();
  inline void set_allocated_signingtime(::Diadoc::Api::Proto::Timestamp* signingtime);

  // optional .Diadoc.Api.Proto.Timestamp SignatureVerificationTime = 2;
  inline bool has_signatureverificationtime() const;
  inline void clear_signatureverificationtime();
  static const int kSignatureVerificationTimeFieldNumber = 2;
  inline const ::Diadoc::Api::Proto::Timestamp& signatureverificationtime() const;
  inline ::Diadoc::Api::Proto::Timestamp* mutable_signatureverificationtime();
  inline ::Diadoc::Api::Proto::Timestamp* release_signatureverificationtime();
  inline void set_allocated_signatureverificationtime(::Diadoc::Api::Proto::Timestamp* signatureverificationtime);

  // optional .Diadoc.Api.Proto.SignatureVerificationResult SignatureVerificationResult = 3;
  inline bool has_signatureverificationresult() const;
  inline void clear_signatureverificationresult();
  static const int kSignatureVerificationResultFieldNumber = 3;
  inline const ::Diadoc::Api::Proto::SignatureVerificationResult& signatureverificationresult() const;
  inline ::Diadoc::Api::Proto::SignatureVerificationResult* mutable_signatureverificationresult();
  inline ::Diadoc::Api::Proto::SignatureVerificationResult* release_signatureverificationresult();
  inline void set_allocated_signatureverificationresult(::Diadoc::Api::Proto::SignatureVerificationResult* signatureverificationresult);

  // required string Thumbprint = 4;
  inline bool has_thumbprint() const;
  inline void clear_thumbprint();
  static const int kThumbprintFieldNumber = 4;
  inline const ::std::string& thumbprint() const;
  inline void set_thumbprint(const ::std::string& value);
  inline void set_thumbprint(const char* value);
  inline void set_thumbprint(const char* value, size_t size);
  inline ::std::string* mutable_thumbprint();
  inline ::std::string* release_thumbprint();
  inline void set_allocated_thumbprint(::std::string* thumbprint);

  // required string SerialNumber = 5;
  inline bool has_serialnumber() const;
  inline void clear_serialnumber();
  static const int kSerialNumberFieldNumber = 5;
  inline const ::std::string& serialnumber() const;
  inline void set_serialnumber(const ::std::string& value);
  inline void set_serialnumber(const char* value);
  inline void set_serialnumber(const char* value, size_t size);
  inline ::std::string* mutable_serialnumber();
  inline ::std::string* release_serialnumber();
  inline void set_allocated_serialnumber(::std::string* serialnumber);

  // optional string Issuer = 6;
  inline bool has_issuer() const;
  inline void clear_issuer();
  static const int kIssuerFieldNumber = 6;
  inline const ::std::string& issuer() const;
  inline void set_issuer(const ::std::string& value);
  inline void set_issuer(const char* value);
  inline void set_issuer(const char* value, size_t size);
  inline ::std::string* mutable_issuer();
  inline ::std::string* release_issuer();
  inline void set_allocated_issuer(::std::string* issuer);

  // optional string StartDate = 7;
  inline bool has_startdate() const;
  inline void clear_startdate();
  static const int kStartDateFieldNumber = 7;
  inline const ::std::string& startdate() const;
  inline void set_startdate(const ::std::string& value);
  inline void set_startdate(const char* value);
  inline void set_startdate(const char* value, size_t size);
  inline ::std::string* mutable_startdate();
  inline ::std::string* release_startdate();
  inline void set_allocated_startdate(::std::string* startdate);

  // optional string EndDate = 8;
  inline bool has_enddate() const;
  inline void clear_enddate();
  static const int kEndDateFieldNumber = 8;
  inline const ::std::string& enddate() const;
  inline void set_enddate(const ::std::string& value);
  inline void set_enddate(const char* value);
  inline void set_enddate(const char* value, size_t size);
  inline ::std::string* mutable_enddate();
  inline ::std::string* release_enddate();
  inline void set_allocated_enddate(::std::string* enddate);

  // optional string OrgName = 9;
  inline bool has_orgname() const;
  inline void clear_orgname();
  static const int kOrgNameFieldNumber = 9;
  inline const ::std::string& orgname() const;
  inline void set_orgname(const ::std::string& value);
  inline void set_orgname(const char* value);
  inline void set_orgname(const char* value, size_t size);
  inline ::std::string* mutable_orgname();
  inline ::std::string* release_orgname();
  inline void set_allocated_orgname(::std::string* orgname);

  // optional string OrgInn = 10;
  inline bool has_orginn() const;
  inline void clear_orginn();
  static const int kOrgInnFieldNumber = 10;
  inline const ::std::string& orginn() const;
  inline void set_orginn(const ::std::string& value);
  inline void set_orginn(const char* value);
  inline void set_orginn(const char* value, size_t size);
  inline ::std::string* mutable_orginn();
  inline ::std::string* release_orginn();
  inline void set_allocated_orginn(::std::string* orginn);

  // optional string JobTitle = 11;
  inline bool has_jobtitle() const;
  inline void clear_jobtitle();
  static const int kJobTitleFieldNumber = 11;
  inline const ::std::string& jobtitle() const;
  inline void set_jobtitle(const ::std::string& value);
  inline void set_jobtitle(const char* value);
  inline void set_jobtitle(const char* value, size_t size);
  inline ::std::string* mutable_jobtitle();
  inline ::std::string* release_jobtitle();
  inline void set_allocated_jobtitle(::std::string* jobtitle);

  // optional string FirstName = 12;
  inline bool has_firstname() const;
  inline void clear_firstname();
  static const int kFirstNameFieldNumber = 12;
  inline const ::std::string& firstname() const;
  inline void set_firstname(const ::std::string& value);
  inline void set_firstname(const char* value);
  inline void set_firstname(const char* value, size_t size);
  inline ::std::string* mutable_firstname();
  inline ::std::string* release_firstname();
  inline void set_allocated_firstname(::std::string* firstname);

  // optional string Surname = 13;
  inline bool has_surname() const;
  inline void clear_surname();
  static const int kSurnameFieldNumber = 13;
  inline const ::std::string& surname() const;
  inline void set_surname(const ::std::string& value);
  inline void set_surname(const char* value);
  inline void set_surname(const char* value, size_t size);
  inline ::std::string* mutable_surname();
  inline ::std::string* release_surname();
  inline void set_allocated_surname(::std::string* surname);

  // optional string Snils = 14;
  inline bool has_snils() const;
  inline void clear_snils();
  static const int kSnilsFieldNumber = 14;
  inline const ::std::string& snils() const;
  inline void set_snils(const ::std::string& value);
  inline void set_snils(const char* value);
  inline void set_snils(const char* value, size_t size);
  inline ::std::string* mutable_snils();
  inline ::std::string* release_snils();
  inline void set_allocated_snils(::std::string* snils);

  // optional string Email = 15;
  inline bool has_email() const;
  inline void clear_email();
  static const int kEmailFieldNumber = 15;
  inline const ::std::string& email() const;
  inline void set_email(const ::std::string& value);
  inline void set_email(const char* value);
  inline void set_email(const char* value, size_t size);
  inline ::std::string* mutable_email();
  inline ::std::string* release_email();
  inline void set_allocated_email(::std::string* email);

  // @@protoc_insertion_point(class_scope:Diadoc.Api.Proto.SignatureInfo)
 private:
  inline void set_has_signingtime();
  inline void clear_has_signingtime();
  inline void set_has_signatureverificationtime();
  inline void clear_has_signatureverificationtime();
  inline void set_has_signatureverificationresult();
  inline void clear_has_signatureverificationresult();
  inline void set_has_thumbprint();
  inline void clear_has_thumbprint();
  inline void set_has_serialnumber();
  inline void clear_has_serialnumber();
  inline void set_has_issuer();
  inline void clear_has_issuer();
  inline void set_has_startdate();
  inline void clear_has_startdate();
  inline void set_has_enddate();
  inline void clear_has_enddate();
  inline void set_has_orgname();
  inline void clear_has_orgname();
  inline void set_has_orginn();
  inline void clear_has_orginn();
  inline void set_has_jobtitle();
  inline void clear_has_jobtitle();
  inline void set_has_firstname();
  inline void clear_has_firstname();
  inline void set_has_surname();
  inline void clear_has_surname();
  inline void set_has_snils();
  inline void clear_has_snils();
  inline void set_has_email();
  inline void clear_has_email();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::Diadoc::Api::Proto::Timestamp* signingtime_;
  ::Diadoc::Api::Proto::Timestamp* signatureverificationtime_;
  ::Diadoc::Api::Proto::SignatureVerificationResult* signatureverificationresult_;
  ::std::string* thumbprint_;
  ::std::string* serialnumber_;
  ::std::string* issuer_;
  ::std::string* startdate_;
  ::std::string* enddate_;
  ::std::string* orgname_;
  ::std::string* orginn_;
  ::std::string* jobtitle_;
  ::std::string* firstname_;
  ::std::string* surname_;
  ::std::string* snils_;
  ::std::string* email_;
  friend void  protobuf_AddDesc_SignatureInfo_2eproto();
  friend void protobuf_AssignDesc_SignatureInfo_2eproto();
  friend void protobuf_ShutdownFile_SignatureInfo_2eproto();

  void InitAsDefaultInstance();
  static SignatureInfo* default_instance_;
};
// ===================================================================


// ===================================================================

// SignatureInfo

// required .Diadoc.Api.Proto.Timestamp SigningTime = 1;
inline bool SignatureInfo::has_signingtime() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SignatureInfo::set_has_signingtime() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SignatureInfo::clear_has_signingtime() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SignatureInfo::clear_signingtime() {
  if (signingtime_ != NULL) signingtime_->::Diadoc::Api::Proto::Timestamp::Clear();
  clear_has_signingtime();
}
inline const ::Diadoc::Api::Proto::Timestamp& SignatureInfo::signingtime() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.SignatureInfo.SigningTime)
  return signingtime_ != NULL ? *signingtime_ : *default_instance_->signingtime_;
}
inline ::Diadoc::Api::Proto::Timestamp* SignatureInfo::mutable_signingtime() {
  set_has_signingtime();
  if (signingtime_ == NULL) signingtime_ = new ::Diadoc::Api::Proto::Timestamp;
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.SignatureInfo.SigningTime)
  return signingtime_;
}
inline ::Diadoc::Api::Proto::Timestamp* SignatureInfo::release_signingtime() {
  clear_has_signingtime();
  ::Diadoc::Api::Proto::Timestamp* temp = signingtime_;
  signingtime_ = NULL;
  return temp;
}
inline void SignatureInfo::set_allocated_signingtime(::Diadoc::Api::Proto::Timestamp* signingtime) {
  delete signingtime_;
  signingtime_ = signingtime;
  if (signingtime) {
    set_has_signingtime();
  } else {
    clear_has_signingtime();
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.SignatureInfo.SigningTime)
}

// optional .Diadoc.Api.Proto.Timestamp SignatureVerificationTime = 2;
inline bool SignatureInfo::has_signatureverificationtime() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SignatureInfo::set_has_signatureverificationtime() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SignatureInfo::clear_has_signatureverificationtime() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SignatureInfo::clear_signatureverificationtime() {
  if (signatureverificationtime_ != NULL) signatureverificationtime_->::Diadoc::Api::Proto::Timestamp::Clear();
  clear_has_signatureverificationtime();
}
inline const ::Diadoc::Api::Proto::Timestamp& SignatureInfo::signatureverificationtime() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.SignatureInfo.SignatureVerificationTime)
  return signatureverificationtime_ != NULL ? *signatureverificationtime_ : *default_instance_->signatureverificationtime_;
}
inline ::Diadoc::Api::Proto::Timestamp* SignatureInfo::mutable_signatureverificationtime() {
  set_has_signatureverificationtime();
  if (signatureverificationtime_ == NULL) signatureverificationtime_ = new ::Diadoc::Api::Proto::Timestamp;
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.SignatureInfo.SignatureVerificationTime)
  return signatureverificationtime_;
}
inline ::Diadoc::Api::Proto::Timestamp* SignatureInfo::release_signatureverificationtime() {
  clear_has_signatureverificationtime();
  ::Diadoc::Api::Proto::Timestamp* temp = signatureverificationtime_;
  signatureverificationtime_ = NULL;
  return temp;
}
inline void SignatureInfo::set_allocated_signatureverificationtime(::Diadoc::Api::Proto::Timestamp* signatureverificationtime) {
  delete signatureverificationtime_;
  signatureverificationtime_ = signatureverificationtime;
  if (signatureverificationtime) {
    set_has_signatureverificationtime();
  } else {
    clear_has_signatureverificationtime();
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.SignatureInfo.SignatureVerificationTime)
}

// optional .Diadoc.Api.Proto.SignatureVerificationResult SignatureVerificationResult = 3;
inline bool SignatureInfo::has_signatureverificationresult() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SignatureInfo::set_has_signatureverificationresult() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SignatureInfo::clear_has_signatureverificationresult() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SignatureInfo::clear_signatureverificationresult() {
  if (signatureverificationresult_ != NULL) signatureverificationresult_->::Diadoc::Api::Proto::SignatureVerificationResult::Clear();
  clear_has_signatureverificationresult();
}
inline const ::Diadoc::Api::Proto::SignatureVerificationResult& SignatureInfo::signatureverificationresult() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.SignatureInfo.SignatureVerificationResult)
  return signatureverificationresult_ != NULL ? *signatureverificationresult_ : *default_instance_->signatureverificationresult_;
}
inline ::Diadoc::Api::Proto::SignatureVerificationResult* SignatureInfo::mutable_signatureverificationresult() {
  set_has_signatureverificationresult();
  if (signatureverificationresult_ == NULL) signatureverificationresult_ = new ::Diadoc::Api::Proto::SignatureVerificationResult;
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.SignatureInfo.SignatureVerificationResult)
  return signatureverificationresult_;
}
inline ::Diadoc::Api::Proto::SignatureVerificationResult* SignatureInfo::release_signatureverificationresult() {
  clear_has_signatureverificationresult();
  ::Diadoc::Api::Proto::SignatureVerificationResult* temp = signatureverificationresult_;
  signatureverificationresult_ = NULL;
  return temp;
}
inline void SignatureInfo::set_allocated_signatureverificationresult(::Diadoc::Api::Proto::SignatureVerificationResult* signatureverificationresult) {
  delete signatureverificationresult_;
  signatureverificationresult_ = signatureverificationresult;
  if (signatureverificationresult) {
    set_has_signatureverificationresult();
  } else {
    clear_has_signatureverificationresult();
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.SignatureInfo.SignatureVerificationResult)
}

// required string Thumbprint = 4;
inline bool SignatureInfo::has_thumbprint() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SignatureInfo::set_has_thumbprint() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SignatureInfo::clear_has_thumbprint() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SignatureInfo::clear_thumbprint() {
  if (thumbprint_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    thumbprint_->clear();
  }
  clear_has_thumbprint();
}
inline const ::std::string& SignatureInfo::thumbprint() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.SignatureInfo.Thumbprint)
  return *thumbprint_;
}
inline void SignatureInfo::set_thumbprint(const ::std::string& value) {
  set_has_thumbprint();
  if (thumbprint_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    thumbprint_ = new ::std::string;
  }
  thumbprint_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.SignatureInfo.Thumbprint)
}
inline void SignatureInfo::set_thumbprint(const char* value) {
  set_has_thumbprint();
  if (thumbprint_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    thumbprint_ = new ::std::string;
  }
  thumbprint_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.SignatureInfo.Thumbprint)
}
inline void SignatureInfo::set_thumbprint(const char* value, size_t size) {
  set_has_thumbprint();
  if (thumbprint_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    thumbprint_ = new ::std::string;
  }
  thumbprint_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.SignatureInfo.Thumbprint)
}
inline ::std::string* SignatureInfo::mutable_thumbprint() {
  set_has_thumbprint();
  if (thumbprint_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    thumbprint_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.SignatureInfo.Thumbprint)
  return thumbprint_;
}
inline ::std::string* SignatureInfo::release_thumbprint() {
  clear_has_thumbprint();
  if (thumbprint_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = thumbprint_;
    thumbprint_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SignatureInfo::set_allocated_thumbprint(::std::string* thumbprint) {
  if (thumbprint_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete thumbprint_;
  }
  if (thumbprint) {
    set_has_thumbprint();
    thumbprint_ = thumbprint;
  } else {
    clear_has_thumbprint();
    thumbprint_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.SignatureInfo.Thumbprint)
}

// required string SerialNumber = 5;
inline bool SignatureInfo::has_serialnumber() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SignatureInfo::set_has_serialnumber() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SignatureInfo::clear_has_serialnumber() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SignatureInfo::clear_serialnumber() {
  if (serialnumber_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    serialnumber_->clear();
  }
  clear_has_serialnumber();
}
inline const ::std::string& SignatureInfo::serialnumber() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.SignatureInfo.SerialNumber)
  return *serialnumber_;
}
inline void SignatureInfo::set_serialnumber(const ::std::string& value) {
  set_has_serialnumber();
  if (serialnumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    serialnumber_ = new ::std::string;
  }
  serialnumber_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.SignatureInfo.SerialNumber)
}
inline void SignatureInfo::set_serialnumber(const char* value) {
  set_has_serialnumber();
  if (serialnumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    serialnumber_ = new ::std::string;
  }
  serialnumber_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.SignatureInfo.SerialNumber)
}
inline void SignatureInfo::set_serialnumber(const char* value, size_t size) {
  set_has_serialnumber();
  if (serialnumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    serialnumber_ = new ::std::string;
  }
  serialnumber_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.SignatureInfo.SerialNumber)
}
inline ::std::string* SignatureInfo::mutable_serialnumber() {
  set_has_serialnumber();
  if (serialnumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    serialnumber_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.SignatureInfo.SerialNumber)
  return serialnumber_;
}
inline ::std::string* SignatureInfo::release_serialnumber() {
  clear_has_serialnumber();
  if (serialnumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = serialnumber_;
    serialnumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SignatureInfo::set_allocated_serialnumber(::std::string* serialnumber) {
  if (serialnumber_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete serialnumber_;
  }
  if (serialnumber) {
    set_has_serialnumber();
    serialnumber_ = serialnumber;
  } else {
    clear_has_serialnumber();
    serialnumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.SignatureInfo.SerialNumber)
}

// optional string Issuer = 6;
inline bool SignatureInfo::has_issuer() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SignatureInfo::set_has_issuer() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SignatureInfo::clear_has_issuer() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SignatureInfo::clear_issuer() {
  if (issuer_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    issuer_->clear();
  }
  clear_has_issuer();
}
inline const ::std::string& SignatureInfo::issuer() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.SignatureInfo.Issuer)
  return *issuer_;
}
inline void SignatureInfo::set_issuer(const ::std::string& value) {
  set_has_issuer();
  if (issuer_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    issuer_ = new ::std::string;
  }
  issuer_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.SignatureInfo.Issuer)
}
inline void SignatureInfo::set_issuer(const char* value) {
  set_has_issuer();
  if (issuer_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    issuer_ = new ::std::string;
  }
  issuer_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.SignatureInfo.Issuer)
}
inline void SignatureInfo::set_issuer(const char* value, size_t size) {
  set_has_issuer();
  if (issuer_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    issuer_ = new ::std::string;
  }
  issuer_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.SignatureInfo.Issuer)
}
inline ::std::string* SignatureInfo::mutable_issuer() {
  set_has_issuer();
  if (issuer_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    issuer_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.SignatureInfo.Issuer)
  return issuer_;
}
inline ::std::string* SignatureInfo::release_issuer() {
  clear_has_issuer();
  if (issuer_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = issuer_;
    issuer_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SignatureInfo::set_allocated_issuer(::std::string* issuer) {
  if (issuer_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete issuer_;
  }
  if (issuer) {
    set_has_issuer();
    issuer_ = issuer;
  } else {
    clear_has_issuer();
    issuer_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.SignatureInfo.Issuer)
}

// optional string StartDate = 7;
inline bool SignatureInfo::has_startdate() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SignatureInfo::set_has_startdate() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SignatureInfo::clear_has_startdate() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SignatureInfo::clear_startdate() {
  if (startdate_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    startdate_->clear();
  }
  clear_has_startdate();
}
inline const ::std::string& SignatureInfo::startdate() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.SignatureInfo.StartDate)
  return *startdate_;
}
inline void SignatureInfo::set_startdate(const ::std::string& value) {
  set_has_startdate();
  if (startdate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    startdate_ = new ::std::string;
  }
  startdate_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.SignatureInfo.StartDate)
}
inline void SignatureInfo::set_startdate(const char* value) {
  set_has_startdate();
  if (startdate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    startdate_ = new ::std::string;
  }
  startdate_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.SignatureInfo.StartDate)
}
inline void SignatureInfo::set_startdate(const char* value, size_t size) {
  set_has_startdate();
  if (startdate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    startdate_ = new ::std::string;
  }
  startdate_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.SignatureInfo.StartDate)
}
inline ::std::string* SignatureInfo::mutable_startdate() {
  set_has_startdate();
  if (startdate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    startdate_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.SignatureInfo.StartDate)
  return startdate_;
}
inline ::std::string* SignatureInfo::release_startdate() {
  clear_has_startdate();
  if (startdate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = startdate_;
    startdate_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SignatureInfo::set_allocated_startdate(::std::string* startdate) {
  if (startdate_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete startdate_;
  }
  if (startdate) {
    set_has_startdate();
    startdate_ = startdate;
  } else {
    clear_has_startdate();
    startdate_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.SignatureInfo.StartDate)
}

// optional string EndDate = 8;
inline bool SignatureInfo::has_enddate() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void SignatureInfo::set_has_enddate() {
  _has_bits_[0] |= 0x00000080u;
}
inline void SignatureInfo::clear_has_enddate() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void SignatureInfo::clear_enddate() {
  if (enddate_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    enddate_->clear();
  }
  clear_has_enddate();
}
inline const ::std::string& SignatureInfo::enddate() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.SignatureInfo.EndDate)
  return *enddate_;
}
inline void SignatureInfo::set_enddate(const ::std::string& value) {
  set_has_enddate();
  if (enddate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    enddate_ = new ::std::string;
  }
  enddate_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.SignatureInfo.EndDate)
}
inline void SignatureInfo::set_enddate(const char* value) {
  set_has_enddate();
  if (enddate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    enddate_ = new ::std::string;
  }
  enddate_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.SignatureInfo.EndDate)
}
inline void SignatureInfo::set_enddate(const char* value, size_t size) {
  set_has_enddate();
  if (enddate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    enddate_ = new ::std::string;
  }
  enddate_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.SignatureInfo.EndDate)
}
inline ::std::string* SignatureInfo::mutable_enddate() {
  set_has_enddate();
  if (enddate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    enddate_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.SignatureInfo.EndDate)
  return enddate_;
}
inline ::std::string* SignatureInfo::release_enddate() {
  clear_has_enddate();
  if (enddate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = enddate_;
    enddate_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SignatureInfo::set_allocated_enddate(::std::string* enddate) {
  if (enddate_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete enddate_;
  }
  if (enddate) {
    set_has_enddate();
    enddate_ = enddate;
  } else {
    clear_has_enddate();
    enddate_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.SignatureInfo.EndDate)
}

// optional string OrgName = 9;
inline bool SignatureInfo::has_orgname() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void SignatureInfo::set_has_orgname() {
  _has_bits_[0] |= 0x00000100u;
}
inline void SignatureInfo::clear_has_orgname() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void SignatureInfo::clear_orgname() {
  if (orgname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    orgname_->clear();
  }
  clear_has_orgname();
}
inline const ::std::string& SignatureInfo::orgname() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.SignatureInfo.OrgName)
  return *orgname_;
}
inline void SignatureInfo::set_orgname(const ::std::string& value) {
  set_has_orgname();
  if (orgname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    orgname_ = new ::std::string;
  }
  orgname_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.SignatureInfo.OrgName)
}
inline void SignatureInfo::set_orgname(const char* value) {
  set_has_orgname();
  if (orgname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    orgname_ = new ::std::string;
  }
  orgname_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.SignatureInfo.OrgName)
}
inline void SignatureInfo::set_orgname(const char* value, size_t size) {
  set_has_orgname();
  if (orgname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    orgname_ = new ::std::string;
  }
  orgname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.SignatureInfo.OrgName)
}
inline ::std::string* SignatureInfo::mutable_orgname() {
  set_has_orgname();
  if (orgname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    orgname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.SignatureInfo.OrgName)
  return orgname_;
}
inline ::std::string* SignatureInfo::release_orgname() {
  clear_has_orgname();
  if (orgname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = orgname_;
    orgname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SignatureInfo::set_allocated_orgname(::std::string* orgname) {
  if (orgname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete orgname_;
  }
  if (orgname) {
    set_has_orgname();
    orgname_ = orgname;
  } else {
    clear_has_orgname();
    orgname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.SignatureInfo.OrgName)
}

// optional string OrgInn = 10;
inline bool SignatureInfo::has_orginn() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void SignatureInfo::set_has_orginn() {
  _has_bits_[0] |= 0x00000200u;
}
inline void SignatureInfo::clear_has_orginn() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void SignatureInfo::clear_orginn() {
  if (orginn_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    orginn_->clear();
  }
  clear_has_orginn();
}
inline const ::std::string& SignatureInfo::orginn() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.SignatureInfo.OrgInn)
  return *orginn_;
}
inline void SignatureInfo::set_orginn(const ::std::string& value) {
  set_has_orginn();
  if (orginn_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    orginn_ = new ::std::string;
  }
  orginn_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.SignatureInfo.OrgInn)
}
inline void SignatureInfo::set_orginn(const char* value) {
  set_has_orginn();
  if (orginn_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    orginn_ = new ::std::string;
  }
  orginn_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.SignatureInfo.OrgInn)
}
inline void SignatureInfo::set_orginn(const char* value, size_t size) {
  set_has_orginn();
  if (orginn_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    orginn_ = new ::std::string;
  }
  orginn_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.SignatureInfo.OrgInn)
}
inline ::std::string* SignatureInfo::mutable_orginn() {
  set_has_orginn();
  if (orginn_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    orginn_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.SignatureInfo.OrgInn)
  return orginn_;
}
inline ::std::string* SignatureInfo::release_orginn() {
  clear_has_orginn();
  if (orginn_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = orginn_;
    orginn_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SignatureInfo::set_allocated_orginn(::std::string* orginn) {
  if (orginn_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete orginn_;
  }
  if (orginn) {
    set_has_orginn();
    orginn_ = orginn;
  } else {
    clear_has_orginn();
    orginn_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.SignatureInfo.OrgInn)
}

// optional string JobTitle = 11;
inline bool SignatureInfo::has_jobtitle() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void SignatureInfo::set_has_jobtitle() {
  _has_bits_[0] |= 0x00000400u;
}
inline void SignatureInfo::clear_has_jobtitle() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void SignatureInfo::clear_jobtitle() {
  if (jobtitle_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    jobtitle_->clear();
  }
  clear_has_jobtitle();
}
inline const ::std::string& SignatureInfo::jobtitle() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.SignatureInfo.JobTitle)
  return *jobtitle_;
}
inline void SignatureInfo::set_jobtitle(const ::std::string& value) {
  set_has_jobtitle();
  if (jobtitle_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    jobtitle_ = new ::std::string;
  }
  jobtitle_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.SignatureInfo.JobTitle)
}
inline void SignatureInfo::set_jobtitle(const char* value) {
  set_has_jobtitle();
  if (jobtitle_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    jobtitle_ = new ::std::string;
  }
  jobtitle_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.SignatureInfo.JobTitle)
}
inline void SignatureInfo::set_jobtitle(const char* value, size_t size) {
  set_has_jobtitle();
  if (jobtitle_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    jobtitle_ = new ::std::string;
  }
  jobtitle_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.SignatureInfo.JobTitle)
}
inline ::std::string* SignatureInfo::mutable_jobtitle() {
  set_has_jobtitle();
  if (jobtitle_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    jobtitle_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.SignatureInfo.JobTitle)
  return jobtitle_;
}
inline ::std::string* SignatureInfo::release_jobtitle() {
  clear_has_jobtitle();
  if (jobtitle_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = jobtitle_;
    jobtitle_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SignatureInfo::set_allocated_jobtitle(::std::string* jobtitle) {
  if (jobtitle_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete jobtitle_;
  }
  if (jobtitle) {
    set_has_jobtitle();
    jobtitle_ = jobtitle;
  } else {
    clear_has_jobtitle();
    jobtitle_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.SignatureInfo.JobTitle)
}

// optional string FirstName = 12;
inline bool SignatureInfo::has_firstname() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void SignatureInfo::set_has_firstname() {
  _has_bits_[0] |= 0x00000800u;
}
inline void SignatureInfo::clear_has_firstname() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void SignatureInfo::clear_firstname() {
  if (firstname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    firstname_->clear();
  }
  clear_has_firstname();
}
inline const ::std::string& SignatureInfo::firstname() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.SignatureInfo.FirstName)
  return *firstname_;
}
inline void SignatureInfo::set_firstname(const ::std::string& value) {
  set_has_firstname();
  if (firstname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    firstname_ = new ::std::string;
  }
  firstname_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.SignatureInfo.FirstName)
}
inline void SignatureInfo::set_firstname(const char* value) {
  set_has_firstname();
  if (firstname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    firstname_ = new ::std::string;
  }
  firstname_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.SignatureInfo.FirstName)
}
inline void SignatureInfo::set_firstname(const char* value, size_t size) {
  set_has_firstname();
  if (firstname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    firstname_ = new ::std::string;
  }
  firstname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.SignatureInfo.FirstName)
}
inline ::std::string* SignatureInfo::mutable_firstname() {
  set_has_firstname();
  if (firstname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    firstname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.SignatureInfo.FirstName)
  return firstname_;
}
inline ::std::string* SignatureInfo::release_firstname() {
  clear_has_firstname();
  if (firstname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = firstname_;
    firstname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SignatureInfo::set_allocated_firstname(::std::string* firstname) {
  if (firstname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete firstname_;
  }
  if (firstname) {
    set_has_firstname();
    firstname_ = firstname;
  } else {
    clear_has_firstname();
    firstname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.SignatureInfo.FirstName)
}

// optional string Surname = 13;
inline bool SignatureInfo::has_surname() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void SignatureInfo::set_has_surname() {
  _has_bits_[0] |= 0x00001000u;
}
inline void SignatureInfo::clear_has_surname() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void SignatureInfo::clear_surname() {
  if (surname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    surname_->clear();
  }
  clear_has_surname();
}
inline const ::std::string& SignatureInfo::surname() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.SignatureInfo.Surname)
  return *surname_;
}
inline void SignatureInfo::set_surname(const ::std::string& value) {
  set_has_surname();
  if (surname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    surname_ = new ::std::string;
  }
  surname_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.SignatureInfo.Surname)
}
inline void SignatureInfo::set_surname(const char* value) {
  set_has_surname();
  if (surname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    surname_ = new ::std::string;
  }
  surname_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.SignatureInfo.Surname)
}
inline void SignatureInfo::set_surname(const char* value, size_t size) {
  set_has_surname();
  if (surname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    surname_ = new ::std::string;
  }
  surname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.SignatureInfo.Surname)
}
inline ::std::string* SignatureInfo::mutable_surname() {
  set_has_surname();
  if (surname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    surname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.SignatureInfo.Surname)
  return surname_;
}
inline ::std::string* SignatureInfo::release_surname() {
  clear_has_surname();
  if (surname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = surname_;
    surname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SignatureInfo::set_allocated_surname(::std::string* surname) {
  if (surname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete surname_;
  }
  if (surname) {
    set_has_surname();
    surname_ = surname;
  } else {
    clear_has_surname();
    surname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.SignatureInfo.Surname)
}

// optional string Snils = 14;
inline bool SignatureInfo::has_snils() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void SignatureInfo::set_has_snils() {
  _has_bits_[0] |= 0x00002000u;
}
inline void SignatureInfo::clear_has_snils() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void SignatureInfo::clear_snils() {
  if (snils_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    snils_->clear();
  }
  clear_has_snils();
}
inline const ::std::string& SignatureInfo::snils() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.SignatureInfo.Snils)
  return *snils_;
}
inline void SignatureInfo::set_snils(const ::std::string& value) {
  set_has_snils();
  if (snils_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    snils_ = new ::std::string;
  }
  snils_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.SignatureInfo.Snils)
}
inline void SignatureInfo::set_snils(const char* value) {
  set_has_snils();
  if (snils_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    snils_ = new ::std::string;
  }
  snils_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.SignatureInfo.Snils)
}
inline void SignatureInfo::set_snils(const char* value, size_t size) {
  set_has_snils();
  if (snils_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    snils_ = new ::std::string;
  }
  snils_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.SignatureInfo.Snils)
}
inline ::std::string* SignatureInfo::mutable_snils() {
  set_has_snils();
  if (snils_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    snils_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.SignatureInfo.Snils)
  return snils_;
}
inline ::std::string* SignatureInfo::release_snils() {
  clear_has_snils();
  if (snils_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = snils_;
    snils_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SignatureInfo::set_allocated_snils(::std::string* snils) {
  if (snils_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete snils_;
  }
  if (snils) {
    set_has_snils();
    snils_ = snils;
  } else {
    clear_has_snils();
    snils_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.SignatureInfo.Snils)
}

// optional string Email = 15;
inline bool SignatureInfo::has_email() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void SignatureInfo::set_has_email() {
  _has_bits_[0] |= 0x00004000u;
}
inline void SignatureInfo::clear_has_email() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void SignatureInfo::clear_email() {
  if (email_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    email_->clear();
  }
  clear_has_email();
}
inline const ::std::string& SignatureInfo::email() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.SignatureInfo.Email)
  return *email_;
}
inline void SignatureInfo::set_email(const ::std::string& value) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    email_ = new ::std::string;
  }
  email_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.SignatureInfo.Email)
}
inline void SignatureInfo::set_email(const char* value) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    email_ = new ::std::string;
  }
  email_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.SignatureInfo.Email)
}
inline void SignatureInfo::set_email(const char* value, size_t size) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    email_ = new ::std::string;
  }
  email_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.SignatureInfo.Email)
}
inline ::std::string* SignatureInfo::mutable_email() {
  set_has_email();
  if (email_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    email_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.SignatureInfo.Email)
  return email_;
}
inline ::std::string* SignatureInfo::release_email() {
  clear_has_email();
  if (email_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = email_;
    email_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SignatureInfo::set_allocated_email(::std::string* email) {
  if (email_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete email_;
  }
  if (email) {
    set_has_email();
    email_ = email;
  } else {
    clear_has_email();
    email_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.SignatureInfo.Email)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace Proto
}  // namespace Api
}  // namespace Diadoc

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_SignatureInfo_2eproto__INCLUDED
